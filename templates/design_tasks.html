{% extends "base.html" %}
{% block title %}Design Tasks Â· Eleva ERP{% endblock %}

{% block content %}
<div class="px-6 py-6 space-y-6 overflow-y-auto h-full">
  <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
    <div>
      <p class="text-sm uppercase text-slate-500">Design</p>
      <h1 class="text-2xl font-semibold">Design Tasks</h1>
      <p class="text-sm text-slate-600">Track requests across stages on a Kanban board.</p>
    </div>
    <button
      type="button"
      data-design-task-modal="designTaskModal"
      class="inline-flex items-center gap-2 px-4 py-2 btn-primary btn-shimmer rounded-xl shadow hover:shadow-lg hover:scale-[1.02] transition"
    >
      <span class="text-lg">+</span> New Task
    </button>
  </div>

  <div id="kanbanBoard">
    {% include "partials/design_tasks_board.html" %}
  </div>
</div>

{% with
  modal_id='designTaskModal',
  modal_title='Create design task',
  submit_label='Create',
  projects=projects,
  users=users,
  default_origin_type='manual',
  default_priority='medium'
%}
  {% include 'partials/design_task_modal.html' %}
{% endwith %}

<script>
  const canMove = {{ 'true' if can_move_cards else 'false' }};
  const statusLabels = {{ statuses|tojson }};
  const kanbanBoard = document.getElementById('kanbanBoard');
  let isDragging = false;

  function formatStatusLabel(status){
    if (statusLabels[status]) return statusLabels[status];
    return status;
  }

  function showStatusUpdateError(message){
    window.alert(message || 'Unable to update task status. Please try again.');
  }

  function getColumnForStatus(status){
    return kanbanBoard ? kanbanBoard.querySelector(`[data-status-column="${CSS.escape(status)}"] [data-cards-grid]`) : null;
  }

  function recalculateColumnCounts(){
    if (!kanbanBoard) return;
    kanbanBoard.querySelectorAll('[data-status-column]').forEach(column => {
      const countBadge = column.querySelector('[data-status-count]');
      const cards = column.querySelectorAll('[data-task-id]');
      if (countBadge) countBadge.textContent = String(cards.length);
    });
  }

  function updateCardStatus(card, status){
    if (!card) return;
    card.dataset.status = status;
    const badge = card.querySelector('[data-status-label]');
    if (badge){
      badge.textContent = formatStatusLabel(status);
    }
  }

  function moveCardToStatusColumn(card, status){
    const columnGrid = getColumnForStatus(status);
    if (!card || !columnGrid) return false;
    columnGrid.appendChild(card);
    recalculateColumnCounts();
    return true;
  }

  async function postTaskStatus(taskId, status){
    const response = await fetch(`/design/tasks/${taskId}/update_status`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Accept': 'application/json'},
      body: JSON.stringify({status})
    });
    const data = await response.json().catch(() => ({}));
    if (!response.ok || !data.ok){
      throw new Error(data.message || 'Unable to update task status.');
    }
    return data;
  }

  function initDragAndDrop(){
    if (!canMove || !kanbanBoard) return;
    let dragged = null;
    const dropzones = kanbanBoard.querySelectorAll('.dropzone');
    kanbanBoard.querySelectorAll('[draggable="true"]').forEach(card => {
      card.addEventListener('dragstart', ()=>{
        dragged = card;
        isDragging = true;
        setTimeout(()=>card.classList.add('opacity-50'), 0);
      });
      card.addEventListener('dragend', ()=>{
        card.classList.remove('opacity-50');
        dragged = null;
        isDragging = false;
      });
    });

    dropzones.forEach(zone => {
      zone.addEventListener('dragover', (e)=>{ e.preventDefault(); zone.classList.add('ring','ring-orange-200');});
      zone.addEventListener('dragleave', ()=> zone.classList.remove('ring','ring-orange-200'));
      zone.addEventListener('drop', async (e)=>{
        e.preventDefault();
        zone.classList.remove('ring','ring-orange-200');
        if(!dragged) return;

        const card = dragged;
        const taskId = card.dataset.taskId;
        const nextStatus = zone.dataset.status;
        const previousStatus = card.dataset.status;
        if (!taskId || !nextStatus || previousStatus === nextStatus) return;

        updateCardStatus(card, nextStatus);
        moveCardToStatusColumn(card, nextStatus);
        try {
          const data = await postTaskStatus(taskId, nextStatus);
          updateCardStatus(card, data.status);
          moveCardToStatusColumn(card, data.status);
          const select = card.querySelector('[data-status-select]');
          if (select){
            select.value = data.status;
            select.dataset.currentStatus = data.status;
          }
        } catch (error) {
          updateCardStatus(card, previousStatus);
          moveCardToStatusColumn(card, previousStatus);
          const select = card.querySelector('[data-status-select]');
          if (select){
            select.value = previousStatus;
            select.dataset.currentStatus = previousStatus;
          }
          showStatusUpdateError(error.message);
        } finally {
          isDragging = false;
        }
      });
    });
  }

  function initStatusControls(){
    if (!kanbanBoard) return;
    kanbanBoard.querySelectorAll('[data-status-select]').forEach(select => {
      select.addEventListener('click', (event) => event.stopPropagation());
      select.addEventListener('mousedown', (event) => event.stopPropagation());
      select.addEventListener('change', async (event) => {
        event.stopPropagation();
        const taskId = select.dataset.taskId;
        const nextStatus = select.value;
        const card = select.closest('[data-task-id]');
        const previousStatus = select.dataset.currentStatus || card?.dataset.status || nextStatus;

        if (!taskId || !card || previousStatus === nextStatus) return;

        select.disabled = true;
        select.dataset.currentStatus = nextStatus;
        updateCardStatus(card, nextStatus);
        moveCardToStatusColumn(card, nextStatus);

        try {
          const data = await postTaskStatus(taskId, nextStatus);
          const persistedStatus = data.status;
          select.value = persistedStatus;
          select.dataset.currentStatus = persistedStatus;
          updateCardStatus(card, persistedStatus);
          moveCardToStatusColumn(card, persistedStatus);
        } catch (error) {
          select.value = previousStatus;
          select.dataset.currentStatus = previousStatus;
          updateCardStatus(card, previousStatus);
          moveCardToStatusColumn(card, previousStatus);
          showStatusUpdateError(error.message);
        } finally {
          select.disabled = false;
        }
      });
    });
  }

  function refreshBoard(){
    if (isDragging || !kanbanBoard) return;
    fetch('/design/tasks/json')
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data && data.html){
          kanbanBoard.innerHTML = data.html;
          initDragAndDrop();
          initStatusControls();
        }
      })
      .catch(()=>{});
  }

  initDragAndDrop();
  initStatusControls();
  recalculateColumnCounts();
  setInterval(refreshBoard, 15000);
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden) refreshBoard();
  });
</script>
{% endblock %}

from flask import (
    render_template,
    request,
    redirect,
    url_for,
    flash,
    jsonify,
    abort,
    session,
    send_file,
    current_app,
)
from flask_login import (
    login_user,
    login_required,
    logout_user,
    current_user,
)
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge
import os, json, datetime, sqlite3, threading, re, uuid, random, string, copy, calendar, base64, shutil, time, math, ast, html
from decimal import Decimal, InvalidOperation
from datetime import datetime as datetime_cls, date
import importlib.util
import csv
from io import BytesIO, StringIO
from collections import OrderedDict, Counter, defaultdict
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from sqlalchemy import Integer, case, inspect, func, or_, and_, event
from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import joinedload, subqueryload, load_only, object_session
from sqlalchemy.engine.url import make_url

from eleva_app import create_app, csrf, db, login_manager
from eleva_app.common_import_utils import clean_str, parse_int_field, stringify_cell
from utils.notifications import create_notification

def _is_password_hashed(value: Optional[str]) -> bool:
    if not value or not isinstance(value, str):
        return False
    return value.startswith(("pbkdf2:", "scrypt:", "argon2:", "bcrypt$"))


def _get_timeout_env(name: str, default: int) -> int:
    raw_value = os.environ.get(name)
    if not raw_value:
        return default
    try:
        parsed = int(raw_value)
        if parsed > 0:
            return parsed
    except ValueError:
        pass
    return default


def _is_odoo_import_enabled() -> bool:
    try:
        return bool(current_app.config.get("PURCHASE_ODOO_IMPORT_ENABLED", True))
    except RuntimeError:
        return True


OPENPYXL_AVAILABLE = importlib.util.find_spec("openpyxl") is not None

if OPENPYXL_AVAILABLE:
    from openpyxl import Workbook, load_workbook
    from openpyxl.styles import Alignment, Font
else:
    Workbook = load_workbook = Alignment = Font = None  # type: ignore[assignment]

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
INDIA_TIMEZONE = datetime.timezone(datetime.timedelta(hours=5, minutes=30), name="IST")
DEFAULT_MAX_UPLOAD_SIZE_MB = 45
DEFAULT_MAX_UPLOAD_SIZE = DEFAULT_MAX_UPLOAD_SIZE_MB * 1024 * 1024
ADMIN_SETTINGS_PATH = os.path.join(BASE_DIR, "instance", "admin_settings.json")
INVENTORY_CONTROL_PATH = os.path.join(BASE_DIR, "instance", "inventory_control.json")


def _default_admin_settings():
    return {"max_upload_size_mb": DEFAULT_MAX_UPLOAD_SIZE_MB}


def _load_admin_settings():
    settings = _default_admin_settings()
    try:
        with open(ADMIN_SETTINGS_PATH, "r", encoding="utf-8") as f:
            file_data = json.load(f)
        if isinstance(file_data, dict):
            settings.update(file_data)
    except FileNotFoundError:
        pass
    except (OSError, json.JSONDecodeError):
        pass
    return settings


def _save_admin_settings(settings):
    merged = {**_default_admin_settings(), **(settings or {})}
    os.makedirs(os.path.dirname(ADMIN_SETTINGS_PATH), exist_ok=True)
    with open(ADMIN_SETTINGS_PATH, "w", encoding="utf-8") as f:
        json.dump(merged, f, indent=2)
    return merged


def _default_inventory_control():
    return {
        "ODOO_INVENTORY_IMPORT_ENABLED": True,
        "INVENTORY_BASELINE_COMPLETED": False,
    }


def _load_inventory_control():
    settings = _default_inventory_control()
    try:
        with open(INVENTORY_CONTROL_PATH, "r", encoding="utf-8") as f:
            file_data = json.load(f)
        if isinstance(file_data, dict):
            for key, default in settings.items():
                if key in file_data:
                    settings[key] = bool(file_data.get(key))
    except FileNotFoundError:
        pass
    except (OSError, json.JSONDecodeError):
        pass
    return settings


def _save_inventory_control(settings):
    merged = {**_default_inventory_control(), **(settings or {})}
    os.makedirs(os.path.dirname(INVENTORY_CONTROL_PATH), exist_ok=True)
    with open(INVENTORY_CONTROL_PATH, "w", encoding="utf-8") as f:
        json.dump(merged, f, indent=2)
    return merged


def _get_inventory_control():
    settings = _load_inventory_control()
    try:
        current_app.config["INVENTORY_CONTROL"] = settings
    except RuntimeError:
        # Outside an application context
        pass
    return settings


def _get_max_upload_size_bytes(settings=None):
    settings = settings or _load_admin_settings()
    try:
        configured = float(settings.get("max_upload_size_mb", DEFAULT_MAX_UPLOAD_SIZE_MB))
    except (TypeError, ValueError):
        configured = DEFAULT_MAX_UPLOAD_SIZE_MB
    clamped_mb = max(1, min(DEFAULT_MAX_UPLOAD_SIZE_MB, configured))
    return int(clamped_mb * 1024 * 1024)


class MissingDependencyError(RuntimeError):
    """Raised when an optional dependency required for a feature is unavailable."""


OPENPYXL_MISSING_MESSAGE = (
    "Excel support requires the openpyxl package. Install dependencies with "
    "`pip install -r requirements.txt` and restart the application."
)

PANDAS_MISSING_MESSAGE = (
    "Drawing History imports require the pandas package. Install dependencies "
    "with `pip install -r requirements.txt` and restart the application."
)


ORG_BACKUP_PATH = os.path.join(BASE_DIR, "instance", "org_structure_backup.json")
CUSTOMER_SUPPORT_DATA_PATH = os.path.join(
    BASE_DIR, "instance", "customer_support_data.json"
)
BOM_UNIT_OPTIONS = ["Nos", "Set", "Mtr", "Kg", "Sqft", "Ltr"]


def _ensure_openpyxl():
    if not OPENPYXL_AVAILABLE:
        raise MissingDependencyError(OPENPYXL_MISSING_MESSAGE)


def _parse_boolean_cell(value, *, default=True):
    if value is None:
        return default
    if isinstance(value, bool):
        return value
    if isinstance(value, (int, float)):
        return value != 0
    return str(value).strip().lower() in {"1", "true", "yes", "y", "on", "active"}


def _parse_bool_payload(value, *, default=False):
    if value is None:
        return default
    if isinstance(value, bool):
        return value
    if isinstance(value, (int, float)):
        return value != 0
    normalized = str(value).strip().lower()
    if normalized in {"1", "true", "yes", "y", "on", "active"}:
        return True
    if normalized in {"0", "false", "no", "n", "off", "inactive"}:
        return False
    return default


def _part_class_payload(part_class):
    primary_part_name = None
    if getattr(part_class, "primary_part_id", None):
        primary_part = Product.query.get(part_class.primary_part_id)
        if primary_part:
            primary_part_name = _product_option_label(primary_part)

    return {
        "id": part_class.id,
        "name": part_class.name,
        "description": part_class.description,
        "is_active": bool(part_class.active),
        "sort_order": part_class.sort_order or 0,
        "associated_sections": _parse_associated_sections(part_class.associated_sections),
        "primary_part_id": part_class.primary_part_id,
        "primary_part_name": primary_part_name,
    }


def _parse_optional_int(value):
    if value in (None, "", "null"):
        return None
    try:
        return int(value)
    except (TypeError, ValueError):
        return None


def _is_purchase_user(user) -> bool:
    role = (getattr(user, "role", "") or "").strip().lower()
    return bool(getattr(user, "is_admin", False) or "purchase" in role)


def _is_design_user(user) -> bool:
    role = (getattr(user, "role", "") or "").strip().lower()
    return bool(getattr(user, "is_admin", False) or "design" in role)


def _product_option_label(product):
    if not product:
        return ""
    unit = (product.uom or product.purchase_uom or "").strip()
    if unit:
        return f"{product.name} ({unit})"
    return product.name


def _parse_associated_sections(raw_value) -> List[str]:
    if raw_value is None:
        return []
    if isinstance(raw_value, list):
        return [str(item).strip() for item in raw_value if str(item).strip()]
    if isinstance(raw_value, str):
        if not raw_value.strip():
            return []
        try:
            parsed = json.loads(raw_value)
        except json.JSONDecodeError:
            parsed = None
        if isinstance(parsed, list):
            return [str(item).strip() for item in parsed if str(item).strip()]
        return [item.strip() for item in raw_value.split(",") if item.strip()]
    return []


def _serialize_associated_sections(raw_value) -> Optional[str]:
    items = _parse_associated_sections(raw_value)
    if not items:
        return None
    unique_items = list(dict.fromkeys(items))
    return json.dumps(unique_items)


def _part_class_name_exists(name, *, exclude_id=None):
    query = PartClass.query.filter(func.lower(PartClass.name) == name.lower())
    if exclude_id is not None:
        query = query.filter(PartClass.id != exclude_id)
    return db.session.query(query.exists()).scalar()


def _get_sqlite_db_path() -> Optional[str]:
    uri = app.config.get("SQLALCHEMY_DATABASE_URI")
    try:
        url = make_url(uri)
    except Exception:
        return None

    if not url.drivername.startswith("sqlite"):
        return None

    database = url.database
    if not database or database == ":memory:":
        return None

    if os.path.isabs(database):
        return database

    return os.path.abspath(os.path.join(BASE_DIR, database))


def _connect_sqlite_db():
    db_path = _get_sqlite_db_path()
    if not db_path:
        return None, None

    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    return sqlite3.connect(db_path), db_path


def _encode_special_types(value):
    if isinstance(value, datetime.datetime):
        return {"__type__": "datetime", "value": value.isoformat()}
    if isinstance(value, datetime.date):
        return {"__type__": "date", "value": value.isoformat()}
    if isinstance(value, list):
        return [_encode_special_types(item) for item in value]
    if isinstance(value, dict):
        return {key: _encode_special_types(item) for key, item in value.items()}
    return value


def _decode_special_types(value):
    if isinstance(value, dict):
        marker = value.get("__type__")
        if marker == "datetime":
            try:
                return datetime.datetime.fromisoformat(value.get("value", ""))
            except (TypeError, ValueError):
                return value.get("value")
        if marker == "date":
            try:
                return datetime.date.fromisoformat(value.get("value", ""))
            except (TypeError, ValueError):
                return value.get("value")
        return {key: _decode_special_types(item) for key, item in value.items()}
    if isinstance(value, list):
        return [_decode_special_types(item) for item in value]
    return value


def _normalize_extension(extension):
    if not extension:
        return ""
    ext = extension.lower().strip()
    if ext and not ext.startswith("."):
        ext = f".{ext}"
    return ext


BOM_INPUT_DATA_TYPES = ["number", "integer", "boolean", "text"]
_BOM_ALLOWED_FUNCS = {"roundup", "min", "max"}


def _parse_bom_input_value(raw_value, data_type, required=False):
    value = raw_value if raw_value is not None else ""
    value = value.strip() if isinstance(value, str) else value
    if value in ("", None):
        if required:
            return None, "Required input missing."
        return None, None

    if data_type == "integer":
        try:
            return int(value), None
        except (TypeError, ValueError):
            return None, "Expected an integer."
    if data_type == "boolean":
        if isinstance(value, bool):
            return value, None
        if isinstance(value, (int, float)):
            return bool(value), None
        if isinstance(value, str):
            lowered = value.strip().lower()
            if lowered in {"1", "true", "yes", "y", "on"}:
                return True, None
            if lowered in {"0", "false", "no", "n", "off"}:
                return False, None
        return None, "Expected a boolean (true/false)."
    if data_type == "text":
        return str(value), None
    try:
        return float(value), None
    except (TypeError, ValueError):
        return None, "Expected a number."


def _roundup(value, decimals=0):
    try:
        decimals = int(decimals)
    except (TypeError, ValueError):
        raise ValueError("roundup decimals must be an integer.")
    if decimals not in {0, 1}:
        raise ValueError("roundup only supports 0 or 1 decimal places.")
    factor = 10 ** decimals
    return math.ceil(float(value) * factor) / factor


def _validate_expression_ast(expr):
    parsed = ast.parse(expr, mode="eval")
    allowed_nodes = (
        ast.Expression,
        ast.BinOp,
        ast.UnaryOp,
        ast.BoolOp,
        ast.Compare,
        ast.Call,
        ast.Name,
        ast.Constant,
        ast.Load,
    )
    allowed_ops = (
        ast.Add,
        ast.Sub,
        ast.Mult,
        ast.Div,
        ast.UAdd,
        ast.USub,
        ast.And,
        ast.Or,
        ast.Not,
        ast.Eq,
        ast.NotEq,
        ast.Lt,
        ast.LtE,
        ast.Gt,
        ast.GtE,
    )
    for node in ast.walk(parsed):
        if not isinstance(node, allowed_nodes):
            raise ValueError(f"Unsupported expression element: {node.__class__.__name__}")
        if isinstance(node, ast.BinOp) and not isinstance(node.op, allowed_ops):
            raise ValueError("Unsupported arithmetic operator.")
        if isinstance(node, ast.UnaryOp) and not isinstance(node.op, allowed_ops):
            raise ValueError("Unsupported unary operator.")
        if isinstance(node, ast.BoolOp) and not isinstance(node.op, allowed_ops):
            raise ValueError("Unsupported boolean operator.")
        if isinstance(node, ast.Compare):
            for op in node.ops:
                if not isinstance(op, allowed_ops):
                    raise ValueError("Unsupported comparison operator.")
        if isinstance(node, ast.Call):
            if not isinstance(node.func, ast.Name):
                raise ValueError("Only simple function calls are allowed.")
            if node.func.id not in _BOM_ALLOWED_FUNCS:
                raise ValueError(f"Function '{node.func.id}' is not allowed.")
    return parsed


def _safe_eval_expr(expr, variables):
    parsed = _validate_expression_ast(expr)

    def _comparison_label(value):
        if isinstance(value, bool):
            return "boolean"
        if isinstance(value, str):
            return "text"
        if isinstance(value, (int, float)):
            return "number"
        return "unknown"

    def _ensure_comparable(left, right):
        left_label = _comparison_label(left)
        right_label = _comparison_label(right)
        if left_label != right_label:
            raise ValueError(f"Cannot compare {left_label} to {right_label}")
        return left_label

    def _eval(node):
        if isinstance(node, ast.Expression):
            return _eval(node.body)
        if isinstance(node, ast.Constant):
            return node.value
        if isinstance(node, ast.Name):
            lowered = node.id.lower()
            if lowered in {"true", "false"}:
                return lowered == "true"
            if node.id in variables:
                return variables[node.id]
            raise ValueError(f"Unknown reference '{node.id}'.")
        if isinstance(node, ast.BinOp):
            left = _eval(node.left)
            right = _eval(node.right)
            if isinstance(node.op, ast.Add):
                return left + right
            if isinstance(node.op, ast.Sub):
                return left - right
            if isinstance(node.op, ast.Mult):
                return left * right
            if isinstance(node.op, ast.Div):
                return left / right
            raise ValueError("Unsupported arithmetic operator.")
        if isinstance(node, ast.UnaryOp):
            operand = _eval(node.operand)
            if isinstance(node.op, ast.UAdd):
                return +operand
            if isinstance(node.op, ast.USub):
                return -operand
            if isinstance(node.op, ast.Not):
                return not operand
            raise ValueError("Unsupported unary operator.")
        if isinstance(node, ast.BoolOp):
            values = [_eval(value) for value in node.values]
            if isinstance(node.op, ast.And):
                return all(values)
            if isinstance(node.op, ast.Or):
                return any(values)
            raise ValueError("Unsupported boolean operator.")
        if isinstance(node, ast.Compare):
            left = _eval(node.left)
            for op, comparator in zip(node.ops, node.comparators):
                right = _eval(comparator)
                label = _ensure_comparable(left, right)
                if isinstance(op, ast.Eq) and not (left == right):
                    return False
                if isinstance(op, ast.NotEq) and not (left != right):
                    return False
                if isinstance(op, ast.Lt):
                    if label == "boolean":
                        raise ValueError("Cannot compare boolean values.")
                    if not (left < right):
                        return False
                if isinstance(op, ast.LtE):
                    if label == "boolean":
                        raise ValueError("Cannot compare boolean values.")
                    if not (left <= right):
                        return False
                if isinstance(op, ast.Gt):
                    if label == "boolean":
                        raise ValueError("Cannot compare boolean values.")
                    if not (left > right):
                        return False
                if isinstance(op, ast.GtE):
                    if label == "boolean":
                        raise ValueError("Cannot compare boolean values.")
                    if not (left >= right):
                        return False
                left = right
            return True
        if isinstance(node, ast.Call):
            func_name = node.func.id
            args = [_eval(arg) for arg in node.args]
            if func_name == "roundup":
                if len(args) == 1:
                    return _roundup(args[0], 0)
                if len(args) == 2:
                    return _roundup(args[0], args[1])
                raise ValueError("roundup expects 1 or 2 arguments.")
            if func_name == "min":
                if len(args) < 2:
                    raise ValueError("min expects at least 2 arguments.")
                return min(args)
            if func_name == "max":
                if len(args) < 2:
                    raise ValueError("max expects at least 2 arguments.")
                return max(args)
        raise ValueError("Unsupported expression.")

    return _eval(parsed)


def _collect_expr_names(expr):
    try:
        parsed = ast.parse(expr, mode="eval")
    except (SyntaxError, ValueError):
        return set()
    names = set()
    for node in ast.walk(parsed):
        if isinstance(node, ast.Name):
            names.add(node.id)
    return names


def evaluate_bom_template(template, input_values=None):
    input_values = input_values or {}
    results = []
    errors = []
    expression_errors = []
    expression_error_counts = defaultdict(int)
    input_map = {}
    input_errors = {}
    input_keys = []
    line_contexts = {}

    def _line_display_name(line):
        candidates = [
            line.specification_text,
            line.part_class.name if line.part_class else None,
            line.unit,
        ]
        for candidate in candidates:
            if candidate is None:
                continue
            value = str(candidate).strip()
            if value:
                return value
        return ""

    def _record_expression_error(line_id, field_name, expr_text, message):
        meta = line_contexts.get(line_id, {})
        payload = {
            "stage_id": meta.get("stage_id"),
            "stage_name": meta.get("stage_name") or "",
            "section_id": meta.get("section_id"),
            "section_name": meta.get("section_name") or "",
            "line_id": line_id,
            "line_ref_key": meta.get("line_ref_key") or "",
            "line_display_name": meta.get("line_display_name") or "",
            "field_name": field_name,
            "expression_text": expr_text or "",
            "error_message": str(message),
        }
        expression_errors.append(payload)
        section_id = meta.get("section_id")
        if section_id is not None:
            expression_error_counts[section_id] += 1

    for template_input in template.inputs:
        key = (template_input.input_key or "").strip()
        if not key:
            input_errors[template_input.id] = "Input key is required."
            continue
        if key in input_map:
            input_errors[template_input.id] = "Duplicate input key."
            continue
        input_keys.append(key)
        raw_value = input_values.get(key, template_input.default_value)
        parsed, error = _parse_bom_input_value(
            raw_value,
            template_input.data_type or "number",
            required=bool(template_input.required),
        )
        if error:
            input_errors[template_input.id] = error
        input_map[key] = parsed

    if input_errors:
        for input_id, message in input_errors.items():
            errors.append({"type": "input", "id": input_id, "message": message})

    section_includes = {}
    for stage in sorted(template.stages, key=lambda st: (st.display_order or 0, st.id)):
        for section in sorted(stage.sections, key=lambda sec: (sec.display_order or 0, sec.id)):
            include_expr = (section.include_if_expr or "").strip()
            include_errors = []
            include = True
            if include_expr:
                names = _collect_expr_names(include_expr)
                for name in names:
                    if name in _BOM_ALLOWED_FUNCS:
                        continue
                    if name not in input_map:
                        include_errors.append(f"Unknown reference '{name}'.")
                if include_errors:
                    include = False
                else:
                    try:
                        include = bool(_safe_eval_expr(include_expr, input_map))
                    except Exception as exc:
                        include_errors.append(f"include_if_expr error: {exc}")
                        include = False
            section_includes[section.id] = {
                "include": include,
                "errors": include_errors,
                "expr": include_expr,
            }
            if include_errors:
                for message in include_errors:
                    errors.append({"type": "section", "id": section.id, "message": message})

    lines = []
    for stage in sorted(template.stages, key=lambda st: (st.display_order or 0, st.id)):
        for section in sorted(stage.sections, key=lambda sec: (sec.display_order or 0, sec.id)):
            if not section_includes.get(section.id, {}).get("include", True):
                continue
            sorted_section_lines = sorted(section.lines, key=lambda ln: (ln.display_order or 0, ln.id))
            for line in sorted_section_lines:
                lines.append(line)
                line_contexts[line.id] = {
                    "stage_id": stage.id,
                    "stage_name": stage.stage_name,
                    "section_id": section.id,
                    "section_name": section.section_name,
                    "line_ref_key": (line.ref_key or "").strip(),
                    "line_display_name": _line_display_name(line),
                }

    ref_map = {}
    ref_duplicates = set()
    for line in lines:
        ref_key = (line.ref_key or "").strip()
        if not ref_key:
            errors.append({"type": "line", "id": line.id, "message": "Missing ref_key."})
            continue
        if ref_key in ref_map:
            ref_duplicates.add(ref_key)
        else:
            ref_map[ref_key] = line

    for ref_key in ref_duplicates:
        errors.append({"type": "line", "ref_key": ref_key, "message": "Duplicate ref_key in template."})

    if set(input_keys) & set(ref_map.keys()):
        overlap = sorted(set(input_keys) & set(ref_map.keys()))
        errors.append({"type": "template", "message": f"Input keys overlap with line ref_keys: {', '.join(overlap)}"})

    dependencies = {}
    line_errors = {line.id: [] for line in lines}
    for line in lines:
        ref_key = (line.ref_key or "").strip()
        deps = set()
        expressions = [
            ("include_if_expr", line.include_if_expr),
            ("qty_expr", line.qty_expr),
            ("override_if_expr", line.override_if_expr),
            ("override_qty_expr", line.override_qty_expr),
        ]
        for field_name, expr in expressions:
            if not expr:
                continue
            names = _collect_expr_names(expr)
            for name in names:
                if name in _BOM_ALLOWED_FUNCS:
                    continue
                if name in input_map:
                    continue
                if name in ref_map:
                    deps.add(name)
                else:
                    message = f"Unknown reference '{name}'."
                    line_errors[line.id].append(message)
                    _record_expression_error(line.id, field_name, expr, message)
        dependencies[ref_key] = deps

    sorted_lines = []
    visiting = set()
    visited = set()

    def _visit(line_key, line_obj):
        if line_key in visited:
            return
        if line_key in visiting:
            line_errors[line_obj.id].append("Circular dependency detected.")
            return
        visiting.add(line_key)
        for dep in dependencies.get(line_key, set()):
            dep_line = ref_map.get(dep)
            if dep_line:
                _visit(dep, dep_line)
        visiting.remove(line_key)
        visited.add(line_key)
        sorted_lines.append(line_obj)

    for line in lines:
        ref_key = (line.ref_key or "").strip()
        if ref_key:
            _visit(ref_key, line)

    values = {}
    for line in sorted_lines:
        ref_key = (line.ref_key or "").strip()
        line_result = {
            "id": line.id,
            "ref_key": ref_key,
            "line": line,
            "final_qty": 0,
            "errors": [],
        }

        if line_errors.get(line.id):
            line_result["errors"].extend(line_errors[line.id])
            results.append(line_result)
            values[ref_key] = 0
            continue

        context = {**input_map, **values}
        include_expr = (line.include_if_expr or "").strip()
        qty_expr = (line.qty_expr or "").strip()
        override_if_expr = (line.override_if_expr or "").strip()
        override_qty_expr = (line.override_qty_expr or "").strip()

        try:
            include = True
            if include_expr:
                include = bool(_safe_eval_expr(include_expr, context))
        except Exception as exc:
            message = f"include_if_expr error: {exc}"
            line_result["errors"].append(message)
            _record_expression_error(line.id, "include_if_expr", include_expr, message)
            include = False

        try:
            qty_value = _safe_eval_expr(qty_expr, context)
        except Exception as exc:
            message = f"qty_expr error: {exc}"
            line_result["errors"].append(message)
            _record_expression_error(line.id, "qty_expr", qty_expr, message)
            qty_value = 0

        if qty_expr and not isinstance(qty_value, (int, float)):
            message = "qty_expr did not return a number."
            line_result["errors"].append(message)
            _record_expression_error(line.id, "qty_expr", qty_expr, message)
            qty_value = 0

        if not include:
            qty_value = 0

        final_qty = qty_value
        if include and override_if_expr:
            try:
                override = bool(_safe_eval_expr(override_if_expr, context))
            except Exception as exc:
                message = f"override_if_expr error: {exc}"
                line_result["errors"].append(message)
                _record_expression_error(line.id, "override_if_expr", override_if_expr, message)
                override = False

            if override:
                if not override_qty_expr:
                    line_result["errors"].append("override_qty_expr missing.")
                    final_qty = 0
                else:
                    try:
                        override_qty = _safe_eval_expr(override_qty_expr, context)
                    except Exception as exc:
                        message = f"override_qty_expr error: {exc}"
                        line_result["errors"].append(message)
                        _record_expression_error(
                            line.id,
                            "override_qty_expr",
                            override_qty_expr,
                            message,
                        )
                        override_qty = 0

                    if not isinstance(override_qty, (int, float)):
                        message = "override_qty_expr did not return a number."
                        line_result["errors"].append(message)
                        _record_expression_error(
                            line.id,
                            "override_qty_expr",
                            override_qty_expr,
                            message,
                        )
                        override_qty = 0
                    final_qty = override_qty

        if line_result["errors"]:
            final_qty = 0

        line_result["final_qty"] = float(final_qty or 0)
        values[ref_key] = float(final_qty or 0)
        results.append(line_result)

    for line in lines:
        if line_errors.get(line.id):
            for message in line_errors[line.id]:
                errors.append({"type": "line", "id": line.id, "message": message})

    return {
        "inputs": input_map,
        "input_errors": input_errors,
        "section_includes": section_includes,
        "lines": results,
        "errors": errors,
        "expression_errors": expression_errors,
        "expression_error_counts": dict(expression_error_counts),
    }


def _get_or_create_design_task_bom(task, *, bom_name="Task BOM"):
    bom = (
        BillOfMaterials.query.filter_by(design_task_id=task.id)
        .order_by(BillOfMaterials.id.asc())
        .first()
    )
    if bom:
        return bom
    bom = BillOfMaterials(
        project_id=task.project_id,
        design_task_id=task.id,
        bom_name=bom_name,
        status="draft",
        bom_type=BOM_TYPE_MAIN,
        created_by_user_id=current_user.id,
    )
    db.session.add(bom)
    db.session.flush()
    return bom


def _get_or_create_default_bom_package(bom, *, name="Main Lift BOM"):
    package = (
        BOMPackage.query.filter_by(bom_id=bom.id)
        .order_by(BOMPackage.id.asc())
        .first()
    )
    if package:
        return package
    package = BOMPackage(
        bom_id=bom.id,
        name=name,
        status="draft",
        created_at=datetime.datetime.utcnow(),
    )
    db.session.add(package)
    db.session.flush()
    return package


def _parse_bom_package_inputs(package):
    raw = package.input_snapshot_json if package else None
    if not raw:
        return {}
    try:
        payload = json.loads(raw)
    except (TypeError, json.JSONDecodeError):
        return {}
    return payload if isinstance(payload, dict) else {}


def _bom_line_spec_required(item):
    """Treat specification as mandatory for most classes (all classified lines)."""
    return bool(item and item.part_class_id)


def _bom_package_missing_spec_items(package_id):
    items = BOMItem.query.filter_by(bom_package_id=package_id).all()
    return [
        item
        for item in items
        if _bom_line_spec_required(item) and not (item.specification or "").strip()
    ]


def _normalize_package_status(value):
    normalized = (value or "").strip().lower()
    if normalized in {"draft", "final"}:
        return normalized
    return "draft"


def _to_india_time(value):
    if not value:
        return value
    if isinstance(value, datetime.datetime):
        dt = value
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=datetime.timezone.utc)
        return dt.astimezone(INDIA_TIMEZONE)
    return value


def _format_india_datetime(value, fmt="%Y-%m-%d %H:%M"):
    localized = _to_india_time(value)
    if isinstance(localized, (datetime.datetime, datetime.date)):
        try:
            return localized.strftime(fmt)
        except Exception:
            return ""
    return ""


class UploadValidationError(ValueError):
    """Raised when an uploaded file fails validation checks."""


def _validate_upload_stream(
    upload,
    *,
    allowed_extensions=None,
    allow_office_processing: bool = False,
):
    if not upload or not upload.filename:
        raise UploadValidationError("Select a file to upload.")

    extension = _normalize_extension(os.path.splitext(upload.filename)[1])

    if not allow_office_processing and extension in {".doc", ".docx", ".xls", ".xlsx", ".xlsm", ".xltm"}:
        raise UploadValidationError(
            "Office documents are only stored for download and are not processed on the server."
        )

    if allowed_extensions and extension not in allowed_extensions:
        allowed_display = ", ".join(sorted(allowed_extensions))
        raise UploadValidationError(
            f"Upload a file with one of the allowed extensions: {allowed_display}."
        )

    content_length = upload.content_length or request.content_length
    max_upload_size = _get_max_upload_size_bytes()
    if content_length and content_length > max_upload_size:
        raise UploadValidationError(
            f"Uploads are limited to {int(max_upload_size / (1024 * 1024))} MB."
        )

    try:
        current_position = upload.stream.tell()
        upload.stream.seek(0, os.SEEK_END)
        stream_size = upload.stream.tell()
        upload.stream.seek(current_position)
        if stream_size and stream_size > max_upload_size:
            raise UploadValidationError(
                f"Uploads are limited to {int(max_upload_size / (1024 * 1024))} MB."
            )
    except Exception:
        # Fall back silently if the stream is not seekable; MAX_CONTENT_LENGTH still applies.
        pass

    return extension


def _random_digits(length=10):
    return "".join(random.choice(string.digits) for _ in range(length))


def generate_random_phone(country_code="+91"):
    return f"{country_code}-{_random_digits(10)}"


def generate_random_email(domains=None):
    domain_pool = domains or [
        "example.com",
        "maildrop.cc",
        "inbound.test",
        "demo.local",
    ]
    local_part = "".join(random.choice(string.ascii_lowercase + string.digits) for _ in range(8))
    return f"{local_part}@{random.choice(domain_pool)}"


def generate_linked_task_id():
    """Generate a short, human-friendly identifier for linked tasks."""
    return f"TASK-{uuid.uuid4().hex[:6].upper()}"


def _sales_task_due_date_for_priority(sla_preset, *, created_at=None):
    created_at = created_at or datetime.datetime.utcnow()
    preset_id = (sla_preset.get("id") or "").lower() if isinstance(sla_preset, dict) else ""

    if preset_id in {"critical", "priority"}:
        return created_at.date()

    if isinstance(sla_preset, dict):
        resolution_hours = sla_preset.get("resolution_hours")
        if resolution_hours is not None:
            try:
                hours = float(resolution_hours)
                return (created_at + datetime.timedelta(hours=hours)).date()
            except (TypeError, ValueError):
                pass

    return created_at.date()


def parse_optional_date(value):
    if not value:
        return None
    if isinstance(value, datetime.date):
        return value
    try:
        return datetime.datetime.strptime(value, "%Y-%m-%d").date()
    except (TypeError, ValueError):
        return None


def parse_float_field(value, label):
    value = clean_str(value)
    if value is None or value == "":
        return None, None
    try:
        return float(value), None
    except (TypeError, ValueError):
        return None, f"{label} must be a number."


def parse_excel_date(cell_value):
    """
    Parse Excel date-like cell values into a Python date.

    Accepts:
    - datetime.date
    - datetime.datetime
    - Strings in "YYYY-MM-DD" or "DD/MM/YYYY" or "DD-MM-YYYY" formats.

    Returns:
    - date object, or
    - None if cannot parse.
    """
    if isinstance(cell_value, date) and not isinstance(cell_value, datetime_cls):
        return cell_value

    if isinstance(cell_value, datetime_cls):
        return cell_value.date()

    if cell_value is None:
        return None

    text = str(cell_value).strip()
    if not text:
        return None

    for fmt in ("%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y"):
        try:
            return datetime_cls.strptime(text, fmt).date()
        except ValueError:
            continue

    return None


def parse_date_field(value, label):
    value = clean_str(value)
    if not value:
        return None, None
    if isinstance(value, str) and value.lower() == "none":
        return None, None
    parsed = parse_optional_date(value)
    if not parsed:
        return None, f"{label} must be in YYYY-MM-DD format."
    return parsed, None


def parse_time_field(value, label):
    value = clean_str(value)
    if not value:
        return None, None
    try:
        parsed = datetime.datetime.strptime(value, "%H:%M").time()
    except (TypeError, ValueError):
        return None, f"{label} must be in 24-hour HH:MM format."
    return parsed, None


PREFERRED_SERVICE_DATE_BASE_YEAR = 2000
PREFERRED_SERVICE_DATE_BASE_MONTH = 1


def parse_preferred_service_date(value):
    value = clean_str(value)
    if not value:
        return None, None
    if re.fullmatch(r"0?[1-9]|[12][0-9]|30", value):
        day = int(value)
        return (
            datetime.date(
                PREFERRED_SERVICE_DATE_BASE_YEAR,
                PREFERRED_SERVICE_DATE_BASE_MONTH,
                day,
            ),
            None,
        )
    return None, "Preferred service date must be a day between 01 and 30."


def parse_preferred_service_days(values):
    if not values:
        return [], None
    if isinstance(values, str):
        values = [values]
    selected = []
    for value in values:
        cleaned = clean_str(value)
        if not cleaned:
            continue
        lowered = cleaned.lower()
        if lowered not in SERVICE_PREFERRED_DAY_LABELS:
            return [], "Select valid preferred service days."
        if lowered == "any":
            selected = ["any"]
            break
        if lowered not in selected:
            selected.append(lowered)
    return selected, None


def is_monthly_preference_date(value):
    if isinstance(value, datetime.datetime):
        value = value.date()
    return (
        isinstance(value, datetime.date)
        and value.year == PREFERRED_SERVICE_DATE_BASE_YEAR
        and value.month == PREFERRED_SERVICE_DATE_BASE_MONTH
    )


def add_months(date_obj, months):
    if not isinstance(date_obj, datetime.date):
        return None
    month = date_obj.month - 1 + int(months)
    year = date_obj.year + month // 12
    month = month % 12 + 1
    day = min(date_obj.day, calendar.monthrange(year, month)[1])
    return datetime.date(year, month, day)


def calculate_amc_end_date(start_date, duration_key):
    if not isinstance(start_date, datetime.date):
        return None
    if not duration_key:
        return None
    duration_key = duration_key.strip().lower()
    months = AMC_DURATION_MONTHS.get(duration_key)
    if not months:
        return None
    target = add_months(start_date, months)
    if not target:
        return None
    return target - datetime.timedelta(days=1)


def normalize_amc_status(value):
    value = clean_str(value)
    if not value:
        return None, None
    lowered = value.lower()
    if lowered in AMC_STATUS_NORMALIZED:
        return AMC_STATUS_NORMALIZED[lowered], None
    valid_options = ", ".join(sorted(AMC_STATUS_OPTIONS))
    return None, f"AMC status must be one of: {valid_options}."


def normalize_amc_duration(value):
    value = clean_str(value)
    if not value:
        return None, None
    lowered = value.lower().strip()

    def _add_candidate(bucket, candidate):
        candidate = (candidate or "").strip()
        if candidate and candidate not in bucket:
            bucket.append(candidate)

    candidates: List[str] = []
    _add_candidate(candidates, lowered)

    # Split by parentheses/brackets so values like "1 year (1_year)" are supported.
    for part in re.split(r"[()\[\]]", lowered):
        _add_candidate(candidates, part)

    # Also split by other separators that users may copy from the UI (commas, pipes, slashes).
    for part in re.split(r"[\|/,;]+", lowered):
        _add_candidate(candidates, part)

    # Hyphen or dash separated values are also common in manually typed inputs.
    for part in re.split(r"[-–—]+", lowered):
        _add_candidate(candidates, part)

    for candidate in candidates:
        normalized = re.sub(r"[^a-z0-9]+", "_", candidate).strip("_")
        if normalized in AMC_DURATION_MONTHS and ("_" in candidate or normalized == candidate):
            return normalized, None

    for candidate in candidates:
        normalized = re.sub(r"[^a-z0-9]+", "_", candidate).strip("_")
        if normalized in AMC_DURATION_MONTHS:
            return normalized, None
        for key, label in AMC_DURATION_CHOICES:
            if not key or not label:
                continue
            if label.lower() == candidate:
                return key, None

    for candidate in candidates:
        match = re.search(r"(\d+(?:\.\d+)?)", candidate)
        if not match:
            continue
        try:
            months = int(float(match.group(1)))
        except (TypeError, ValueError):
            continue
        if not months:
            continue
        for key, duration_months in AMC_DURATION_MONTHS.items():
            if duration_months == months:
                return key, None

    valid_options = ", ".join(sorted(AMC_DURATION_LABELS.values()))
    return None, f"AMC duration must match one of: {valid_options}."


def parse_optional_service_time(value, label):
    """Blank values mean 'Any time'."""
    if value is None:
        return None, None
    if isinstance(value, str) and not value.strip():
        return None, None
    return parse_time_field(value, label)


def parse_preferred_service_days_from_string(value):
    if not value:
        return [], None
    if isinstance(value, str):
        raw_values = [item.strip() for item in re.split(r"[,;/]", value) if item.strip()]
    elif isinstance(value, (list, tuple, set)):
        raw_values = [clean_str(item) for item in value if clean_str(item)]
    else:
        raw_values = [clean_str(value)] if clean_str(value) else []
    if not raw_values:
        return [], None
    parsed, error = parse_preferred_service_days(raw_values)
    if error:
        return [], error
    return parsed, None


def _customer_upload_row(customer):
    return [
        customer.external_customer_id or "",
        customer.customer_code or "",
        customer.company_name or "",
        customer.contact_person or "",
        customer.phone or "",
        customer.mobile or "",
        customer.email or "",
        customer.gst_no or "",
        customer.billing_address_line1 or "",
        customer.billing_address_line2 or "",
        customer.city or "",
        customer.state or "",
        customer.pincode or "",
        customer.country or "",
        customer.route or "",
        customer.sector or "",
        customer.branch or "",
        customer.notes or "",
        customer.office_address_line1 or "",
        customer.office_address_line2 or "",
        customer.office_city or "",
        customer.office_state or "",
        customer.office_pincode or "",
    ]


def _build_csv_output(headers, rows):
    csv_buffer = StringIO()
    writer = csv.writer(csv_buffer)
    writer.writerow(headers)
    for row in rows:
        writer.writerow(row)
    output = BytesIO(csv_buffer.getvalue().encode("utf-8-sig"))
    output.seek(0)
    return output


def _format_date_iso(value):
    if isinstance(value, datetime.datetime):
        value = value.date()
    if isinstance(value, datetime.date):
        return value.isoformat()
    return ""


def _format_time_hhmm(value):
    if isinstance(value, datetime.datetime):
        value = value.time()
    if isinstance(value, datetime.time):
        return value.strftime("%H:%M")
    return ""


def build_customer_upload_workbook():
    _ensure_openpyxl()
    workbook = Workbook()
    instructions_sheet = workbook.active
    instructions_sheet.title = "Instructions"
    instructions_sheet["A1"] = "Customer upload template"
    instructions_sheet["A1"].font = Font(bold=True, size=14)
    instructions_sheet["A3"] = "Fill the Customers sheet with one customer per row."
    instructions_sheet["A4"] = (
        "Provide an External Customer ID to map lifts during AMC uploads."
    )
    instructions_sheet["A5"] = (
        "Customer codes are auto-generated if left blank. Keep them unique if provided."
    )
    instructions_sheet["A6"] = (
        "Route should match an active service route. Branch must be one of "
        + ", ".join(SERVICE_BRANCH_OPTIONS)
        + "."
    )

    data_sheet = workbook.create_sheet(CUSTOMER_UPLOAD_TEMPLATE_SHEET_NAME)
    data_sheet.append(CUSTOMER_UPLOAD_TEMPLATE_HEADERS)
    example_row = ["" for _ in CUSTOMER_UPLOAD_TEMPLATE_HEADERS]
    data_sheet.append(example_row)

    for idx, header in enumerate(CUSTOMER_UPLOAD_TEMPLATE_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def build_customer_export_workbook(customers):
    _ensure_openpyxl()
    workbook = Workbook()
    data_sheet = workbook.active
    data_sheet.title = CUSTOMER_UPLOAD_TEMPLATE_SHEET_NAME
    data_sheet.append(CUSTOMER_UPLOAD_TEMPLATE_HEADERS)

    for customer in customers:
        data_sheet.append(_customer_upload_row(customer))

    for idx, header in enumerate(CUSTOMER_UPLOAD_TEMPLATE_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def _lift_export_row(lift):
    preferred_days = ", ".join(day.title() for day in (lift.preferred_service_days or []))
    preferred_date = _format_date_iso(getattr(lift, "preferred_service_date", None))
    preferred_time = _format_time_hhmm(getattr(lift, "preferred_service_time", None))
    next_due = _format_date_iso(getattr(lift, "next_service_due", None))

    customer = getattr(lift, "customer", None)
    return [
        (customer.external_customer_id if customer else "") or "",
        lift.lift_code or "",
        lift.external_lift_id or "",
        lift.customer_code or "",
        (customer.company_name if customer else "") or "",
        lift.building_villa_number or "",
        lift.site_address_line1 or "",
        lift.site_address_line2 or "",
        lift.city or "",
        lift.state or "",
        lift.pincode or "",
        lift.route or "",
        lift.lift_type or "",
        lift.lift_brand or "",
        lift.capacity_persons or "",
        lift.capacity_kg or "",
        lift.speed_mps or "",
        lift.amc_status or "",
        _format_date_iso(getattr(lift, "amc_start", None)),
        lift.amc_duration_key or "",
        _format_date_iso(getattr(lift, "amc_end", None)),
        preferred_days,
        preferred_date,
        preferred_time,
        next_due,
        lift.notes or "",
    ]


def build_lift_export_workbook(lifts):
    _ensure_openpyxl()
    workbook = Workbook()
    data_sheet = workbook.active
    data_sheet.title = AMC_LIFT_TEMPLATE_SHEET_NAME
    data_sheet.append(AMC_LIFT_TEMPLATE_HEADERS)

    for lift in lifts:
        data_sheet.append(_lift_export_row(lift))

    for idx, header in enumerate(AMC_LIFT_TEMPLATE_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


SERVICE_CONTRACT_EXPORT_HEADERS = [
    "Contract ID",
    "Type",
    "Coverage",
    "Start",
    "End",
    "Visit frequency",
    "SLA matrix",
    "Renewal date",
    "Pending invoices",
    "Billing hooks",
]


def _contract_export_row(contract):
    data = contract or {}

    def _stringify(value):
        if isinstance(value, (list, tuple, set)):
            return ", ".join(str(item) for item in value if item not in (None, ""))
        return value or ""

    return [
        data.get("id", ""),
        data.get("type", ""),
        data.get("coverage", ""),
        _format_date_iso(data.get("start")),
        _format_date_iso(data.get("end")),
        data.get("visits", ""),
        data.get("sla", ""),
        _format_date_iso(data.get("renewal")),
        data.get("pending_invoices", ""),
        _stringify(data.get("billing_hooks", "")),
    ]


def build_contract_export_workbook(contracts):
    _ensure_openpyxl()
    workbook = Workbook()
    data_sheet = workbook.active
    data_sheet.title = "Contracts"
    data_sheet.append(SERVICE_CONTRACT_EXPORT_HEADERS)

    for contract in contracts:
        data_sheet.append(_contract_export_row(contract))

    for idx, header in enumerate(SERVICE_CONTRACT_EXPORT_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def _sales_client_upload_row(client):
    owner_email = ""
    if client.owner and getattr(client.owner, "email", None):
        owner_email = client.owner.email or ""
    return [
        client.display_name or "",
        client.company_name or "",
        client.email or "",
        client.phone or "",
        client.email_opt_out or "",
        client.tag or "",
        client.category or "",
        owner_email,
        client.lifecycle_stage or "",
        client.description or "",
    ]


def build_sales_client_upload_workbook():
    _ensure_openpyxl()
    workbook = Workbook()
    instructions = workbook.active
    instructions.title = "Instructions"
    instructions["A1"] = "Sales clients upload template"
    instructions["A1"].font = Font(bold=True, size=14)
    instructions["A3"] = "Add or update client records in bulk. One client per row."
    instructions["A4"] = "Provide the owner email to assign the client. Leave blank to assign yourself."
    if SALES_CLIENT_LIFECYCLE_STAGES:
        instructions["A5"] = (
            "Lifecycle Stage must be one of: "
            + ", ".join(SALES_CLIENT_LIFECYCLE_STAGES)
            + "."
        )

    data_sheet = workbook.create_sheet(SALES_CLIENT_TEMPLATE_SHEET_NAME)
    data_sheet.append(SALES_CLIENT_UPLOAD_HEADERS)
    data_sheet.append(["" for _ in SALES_CLIENT_UPLOAD_HEADERS])

    for idx, header in enumerate(SALES_CLIENT_UPLOAD_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def build_sales_client_export_workbook(clients):
    _ensure_openpyxl()
    workbook = Workbook()
    data_sheet = workbook.active
    data_sheet.title = SALES_CLIENT_TEMPLATE_SHEET_NAME
    data_sheet.append(SALES_CLIENT_UPLOAD_HEADERS)

    for client in clients:
        data_sheet.append(_sales_client_upload_row(client))

    for idx, header in enumerate(SALES_CLIENT_UPLOAD_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def _sales_opportunity_upload_row(opportunity):
    owner_email = ""
    if opportunity.owner and getattr(opportunity.owner, "email", None):
        owner_email = opportunity.owner.email or ""
    client_name = opportunity.client.display_name if opportunity.client else ""
    expected_close = (
        opportunity.expected_close_date.isoformat()
        if opportunity.expected_close_date
        else ""
    )
    return [
        opportunity.title or "",
        opportunity.pipeline or "",
        opportunity.stage or "",
        opportunity.status or "",
        (opportunity.temperature or "") if opportunity.temperature else "",
        opportunity.amount if opportunity.amount is not None else "",
        opportunity.currency or "₹",
        expected_close,
        opportunity.probability if opportunity.probability is not None else "",
        owner_email,
        client_name,
        opportunity.related_project or "",
        opportunity.description or "",
    ]


def build_sales_opportunity_upload_workbook(pipeline_key):
    _ensure_openpyxl()
    workbook = Workbook()
    instructions = workbook.active
    instructions.title = "Instructions"
    instructions["A1"] = "Sales opportunities upload template"
    instructions["A1"].font = Font(bold=True, size=14)
    instructions["A3"] = "Populate the Opportunities sheet with one deal per row."
    instructions["A4"] = (
        "Pipeline accepts the keys: "
        + ", ".join(f"{key} ({cfg['label']})" for key, cfg in SALES_PIPELINES.items())
        + "."
    )
    instructions["A5"] = (
        "Leave Pipeline blank to default to the selected pipeline in the app."
    )

    row_index = 7
    for key, cfg in SALES_PIPELINES.items():
        instructions[f"A{row_index}"] = f"{cfg['label']} pipeline stages ({key}):"
        instructions[f"A{row_index + 1}"] = ", ".join(cfg.get("stages", []))
        row_index += 2

    data_sheet = workbook.create_sheet(SALES_OPPORTUNITY_TEMPLATE_SHEET_NAME)
    data_sheet.append(SALES_OPPORTUNITY_UPLOAD_HEADERS)
    config = get_pipeline_config(pipeline_key)
    sample_stage = config["stages"][0] if config.get("stages") else ""
    data_sheet.append(
        [
            "Sample Opportunity",
            pipeline_key,
            sample_stage,
            "Open",
            "warm",
            "500000",
            "₹",
            datetime.date.today().isoformat(),
            "40",
            "sales@example.com",
            "Sample Client",
            "Reference Project",
            "Notes about the deal",
        ]
    )

    for idx, header in enumerate(SALES_OPPORTUNITY_UPLOAD_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def build_sales_opportunity_export_workbook(opportunities):
    _ensure_openpyxl()
    workbook = Workbook()
    data_sheet = workbook.active
    data_sheet.title = SALES_OPPORTUNITY_TEMPLATE_SHEET_NAME
    data_sheet.append(SALES_OPPORTUNITY_UPLOAD_HEADERS)

    for opportunity in opportunities:
        data_sheet.append(_sales_opportunity_upload_row(opportunity))

    for idx, header in enumerate(SALES_OPPORTUNITY_UPLOAD_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def _customer_query_for_export(search_query):
    query = Customer.query
    if search_query:
        like = f"%{search_query.lower()}%"
        query = query.filter(
            or_(
                func.lower(Customer.customer_code).like(like),
                func.lower(Customer.company_name).like(like),
                func.lower(Customer.contact_person).like(like),
                func.lower(Customer.city).like(like),
                func.lower(Customer.state).like(like),
                func.lower(Customer.route).like(like),
                func.lower(Customer.branch).like(like),
                func.lower(Customer.sector).like(like),
                func.lower(Customer.notes).like(like),
            )
        )
    return query.order_by(func.lower(Customer.company_name))


def build_amc_lift_upload_workbook():
    _ensure_openpyxl()
    workbook = Workbook()
    instructions_sheet = workbook.active
    instructions_sheet.title = "Instructions"
    instructions_sheet["A1"] = "AMC lift upload template"
    instructions_sheet["A1"].font = Font(bold=True, size=14)
    instructions_sheet["A3"] = "Fill the AMC Lifts sheet with one lift per row."
    instructions_sheet["A4"] = (
        "Provide the customer external ID from the customer upload or the customer code/name."
    )
    instructions_sheet["A5"] = "Valid AMC statuses: " + ", ".join(AMC_STATUS_OPTIONS)
    instructions_sheet["A6"] = "Valid AMC durations: " + ", ".join(AMC_DURATION_LABELS.values())
    instructions_sheet["A7"] = "Dates must be in YYYY-MM-DD format. Preferred service date accepts 01-30."
    instructions_sheet["A8"] = "Preferred service days can be comma separated (e.g. Monday,Wednesday)."

    data_sheet = workbook.create_sheet(AMC_LIFT_TEMPLATE_SHEET_NAME)
    data_sheet.append(AMC_LIFT_TEMPLATE_HEADERS)
    example_row = ["" for _ in AMC_LIFT_TEMPLATE_HEADERS]
    data_sheet.append(example_row)

    for idx, header in enumerate(AMC_LIFT_TEMPLATE_HEADERS, start=1):
        cell = data_sheet.cell(row=1, column=idx)
        cell.font = Font(bold=True)
        cell.alignment = Alignment(wrap_text=True)
        column_letter = data_sheet.cell(row=1, column=idx).column_letter
        data_sheet.column_dimensions[column_letter].width = max(18, len(header) + 2)

    return workbook


def format_preferred_service_date(value):
    if not value:
        return "—"
    if isinstance(value, datetime.datetime):
        value = value.date()
    if is_monthly_preference_date(value):
        return f"Day {value.day:02d}"
    return value.strftime("%d %b %Y")


def preferred_service_date_matches(preferred_value, visit_date):
    if not preferred_value or not visit_date:
        return False
    if isinstance(preferred_value, datetime.datetime):
        preferred_value = preferred_value.date()
    if isinstance(visit_date, datetime.datetime):
        visit_date = visit_date.date()
    if not isinstance(preferred_value, datetime.date) or not isinstance(visit_date, datetime.date):
        return False
    if is_monthly_preference_date(preferred_value):
        return preferred_value.day == visit_date.day
    return preferred_value == visit_date


def validate_branch(value, *, label="Branch", required=False):
    branch_value = clean_str(value)
    if not branch_value:
        if required:
            return None, f"{label} is required."
        return None, None

    lowered = branch_value.lower()
    if lowered not in SERVICE_BRANCH_OPTION_SET:
        allowed = ", ".join(SERVICE_BRANCH_OPTIONS)
        return None, f"{label} must be one of {allowed}."

    for option in SERVICE_BRANCH_OPTIONS:
        if option.lower() == lowered:
            return option, None

    return branch_value, None


def _next_sequential_code(model, column_attr, *, prefix, width):
    column = getattr(model, column_attr)
    numeric_part = func.substr(column, len(prefix) + 1)
    try:
        max_value = (
            db.session.query(
                func.coalesce(func.max(func.cast(numeric_part, Integer)), 0)
            )
            .filter(column.isnot(None))
            .filter(column.like(f"{prefix}%"))
            .scalar()
        ) or 0
    except Exception:
        max_value = 0
    next_value = int(max_value) + 1
    return f"{prefix}{next_value:0{width}d}"


def generate_next_customer_code():
    return _next_sequential_code(Customer, "customer_code", prefix="CUS", width=4)


def generate_next_lift_code():
    return _next_sequential_code(Lift, "lift_code", prefix="LFT", width=4)


def get_service_contract_by_id(contract_id):
    if not contract_id:
        return None
    for contract in SERVICE_CONTRACTS:
        contract_code = str(contract.get("id") or "").strip()
        if contract_code and contract_code.lower() == str(contract_id).strip().lower():
            return contract
    return None


# ---------------------- QC Profile choices (visible in UI) ----------------------
STAGES = [
    "Template QC", "Stage 1", "Stage 2", "Stage 3",
    "Completion", "Completion QC", "Structure", "Cladding", "Service", "Repair", "Material"
]
LIFT_TYPE_OPTIONS = ["Hydraulic", "MR", "MRL", "Goods", "Dumbwaiter"]
LIFT_TYPES = list(LIFT_TYPE_OPTIONS)

LIFT_CAPACITY_PERSON_OPTIONS = [
    ("", "Select capacity"),
    ("0", "0"),
    ("4", "4 Pass"),
    ("6", "6 Pass"),
    ("8", "8 Pass"),
    ("10", "10 Pass"),
    ("13", "13 Pass"),
    ("15", "15 Pass"),
    ("20", "20 Pass"),
    ("25", "25 Pass"),
]

MACHINE_TYPE_OPTIONS = ["Geared", "Gearless", "Hydraulic", "Drum", "Stiltz"]
DOOR_TYPE_OPTIONS = ["ATO-LH", "ATO-RH", "ACO", "Swing", "Collapsible", "Gate", "IMP"]
DOOR_FINISH_OPTIONS = ["SS H/L", "SS Mirror", "MS"]
POWER_SUPPLY_OPTIONS = ["1 Phase", "3 Phase"]
AMC_STATUS_OPTIONS = ["Active", "Expired", "Renewal Pending", "Call Basis"]
AMC_STATUS_NORMALIZED = {option.lower(): option for option in AMC_STATUS_OPTIONS}

SERVICE_VISIT_STATUS_OPTIONS = [
    ("scheduled", "Scheduled"),
    ("completed", "Completed"),
    ("overdue", "Overdue"),
]
SERVICE_VISIT_STATUS_LABELS = {
    value: label for value, label in SERVICE_VISIT_STATUS_OPTIONS
}
SERVICE_TYPE_OPTIONS = [
    ("type_1", "Type 1"),
    ("type_2", "Type 2"),
    ("type_3", "Type 3"),
    ("type_4", "Type 4"),
]
SERVICE_TYPE_LABELS = {value: label for value, label in SERVICE_TYPE_OPTIONS}
LIFT_STATUS_OPTIONS = ["On", "Off", "Protected", "Decommissioned"]
SERVICE_BRANCH_OPTIONS = ["Goa", "Mumbai"]
SERVICE_BRANCH_OPTION_SET = {option.lower() for option in SERVICE_BRANCH_OPTIONS}

SERVICE_PREFERRED_DAY_OPTIONS = [
    ("", "No preference"),
    ("any", "Any day"),
    ("monday", "Monday"),
    ("tuesday", "Tuesday"),
    ("wednesday", "Wednesday"),
    ("thursday", "Thursday"),
    ("friday", "Friday"),
    ("saturday", "Saturday"),
    ("sunday", "Sunday"),
]
SERVICE_PREFERRED_DAY_LABELS = {
    key: label for key, label in SERVICE_PREFERRED_DAY_OPTIONS if key
}

AMC_DURATION_CHOICES = [
    ("", "Select AMC duration"),
    ("1_year", "1 year"),
    ("2_years", "2 years"),
    ("3_years", "3 years"),
    ("4_years", "4 years"),
    ("5_years", "5 years"),
    ("1_year_bimonthly", "1 year bimonthly"),
    ("1_year_quarterly", "1 year quarterly"),
    ("6_months", "6 months"),
]
AMC_DURATION_LABELS = {key: label for key, label in AMC_DURATION_CHOICES if key}
AMC_DURATION_MONTHS = {
    "1_year": 12,
    "2_years": 24,
    "3_years": 36,
    "4_years": 48,
    "5_years": 60,
    "1_year_bimonthly": 12,
    "1_year_quarterly": 12,
    "6_months": 6,
}
AMC_LIFT_TEMPLATE_SHEET_NAME = "AMC Lifts"
AMC_LIFT_TEMPLATE_HEADERS = [
    "Customer External ID",
    "Lift Code",
    "External Lift ID",
    "Customer Code",
    "Customer Name",
    "Building / Villa No.",
    "Site Address Line 1",
    "Site Address Line 2",
    "City",
    "State",
    "Pincode",
    "Route",
    "Lift Type",
    "Lift Brand",
    "Capacity (persons)",
    "Capacity (kg)",
    "Speed (m/s)",
    "AMC Status",
    "AMC Start (YYYY-MM-DD)",
    "AMC Duration",
    "AMC End (YYYY-MM-DD)",
    "Preferred Service Days",
    "Preferred Service Date (DD)",
    "Preferred Service Time (HH:MM)",
    "Next Service Due (YYYY-MM-DD)",
    "Notes",
]

CUSTOMER_UPLOAD_TEMPLATE_SHEET_NAME = "Customers"
CUSTOMER_UPLOAD_TEMPLATE_FIELDS = [
    ("External Customer ID", "external_customer_id"),
    ("Customer Code", "customer_code"),
    ("Company Name", "company_name"),
    ("Contact Person", "contact_person"),
    ("Phone", "phone"),
    ("Mobile", "mobile"),
    ("Email", "email"),
    ("GST No", "gst_no"),
    ("Billing Address Line 1", "billing_address_line1"),
    ("Billing Address Line 2", "billing_address_line2"),
    ("City", "city"),
    ("State", "state"),
    ("Pincode", "pincode"),
    ("Country", "country"),
    ("Route", "route"),
    ("Sector", "sector"),
    ("Branch", "branch"),
    ("Notes", "notes"),
    ("Office Address Line 1", "office_address_line1"),
    ("Office Address Line 2", "office_address_line2"),
    ("Office City", "office_city"),
    ("Office State", "office_state"),
    ("Office Pincode", "office_pincode"),
]
CUSTOMER_UPLOAD_TEMPLATE_HEADERS = [label for label, _ in CUSTOMER_UPLOAD_TEMPLATE_FIELDS]

DROPDOWN_FIELD_DEFINITIONS = {
    "lift_type": {
        "label": "Lift Type",
        "value_editable": False,
        "default_options": [
            {"value": option, "label": option}
            for option in ["Hydraulic", "MR", "MRL", "Goods", "Dumbwaiter", "Passenger"]
        ],
    },
    "door_type": {
        "label": "Door Type",
        "value_editable": False,
        "default_options": [
            {"value": option, "label": option}
            for option in [
                "ATO-LH",
                "ATO-RH",
                "ACO",
                "Swing",
                "Collapsible",
                "Gate",
                "IMP",
                "Manual",
            ]
        ],
    },
    "door_finish": {
        "label": "Door Finish",
        "value_editable": False,
        "default_options": [
            {"value": option, "label": option}
            for option in ["SS H/L", "SS Mirror", "MS", "Powder Coated"]
        ],
    },
    "power_supply": {
        "label": "Power Supply",
        "value_editable": False,
        "default_options": [
            {"value": option, "label": option}
            for option in ["1 Phase", "3 Phase"]
        ],
    },
    "machine_type": {
        "label": "Machine Type",
        "value_editable": False,
        "default_options": [
            {"value": option, "label": option}
            for option in ["Geared", "Gearless", "Hydraulic", "Drum", "Stiltz"]
        ],
    },
    "passenger_capacity": {
        "label": "Passenger Capacity",
        "value_editable": True,
        "default_options": [
            {"value": value, "label": label}
            for value, label in [
                ("0", "0"),
                ("4", "4 Pass"),
                ("6", "6 Pass"),
                ("8", "8 Pass"),
                ("10", "10 Pass"),
                ("13", "13 Pass"),
                ("15", "15 Pass"),
                ("20", "20 Pass"),
                ("25", "25 Pass"),
            ]
        ],
    },
    "load_capacity": {
        "label": "Load Capacity (Kg)",
        "value_editable": True,
        "default_options": [
            {"value": value, "label": f"{value} Kg"}
            for value in ["170", "272", "408", "544", "680", "800", "1000", "1500"]
        ],
    },
}


def _default_client_requirement_schema():
    """Return a structured schema for the Client Requirements Form template."""

    door_type_options = [
        {"label": "Collapsible", "value": "collapsible"},
        {"label": "Manual swing", "value": "manual_swing"},
        {"label": "Automatic", "value": "automatic"},
    ]

    door_finish_options = [
        {"label": "Powder coated", "value": "powder_coated"},
        {"label": "SS Hairline", "value": "ss_hl"},
        {"label": "SS Mirror", "value": "ss_mirror"},
        {"label": "Designer", "value": "designer"},
    ]

    urgency_options = [
        {"label": "Normal", "value": "normal"},
        {"label": "Urgent", "value": "urgent"},
        {"label": "Delayed", "value": "delayed"},
    ]

    sales_sections = [
        {
            "id": "lead_details",
            "title": "Lead Details",
            "role": "sales",
            "fields": [
                {"id": "quote_in_name_of", "type": "text", "label": "Quote in the Name of", "required": True},
                {"id": "priority", "type": "select", "label": "Priority", "options": urgency_options, "required": True},
                {"id": "site_name", "type": "text", "label": "Site Name", "required": True},
                {"id": "site_address", "type": "textarea", "label": "Site Address"},
                {"id": "lift_type", "type": "select", "label": "Lift Type", "options": [
                    {"label": "Villa", "value": "villa"},
                    {"label": "Apartment", "value": "apartment"},
                    {"label": "Commercial", "value": "commercial"},
                ], "required": True},
                {"id": "start_date", "type": "date", "label": "Start Date"},
                {"id": "completion_by", "type": "date", "label": "Completion By"},
                {"id": "order_value", "type": "number", "label": "Order Value"},
                {"id": "sales_representative", "type": "text", "label": "Sales Representative", "required": True},
                {"id": "sales_manager", "type": "text", "label": "Sales Manager"},
                {"id": "closed_by", "type": "select", "label": "Closed By", "options": [
                    {"label": "Sales Rep", "value": "sales_rep"},
                    {"label": "Manager", "value": "manager"},
                    {"label": "Director", "value": "director"},
                ]},
            ],
        },
        {
            "id": "client_details",
            "title": "Client Details",
            "role": "sales",
            "fields": [
                {"id": "owner_name", "type": "text", "label": "Owner Name", "required": True},
                {"id": "owner_phone", "type": "text", "label": "Owner Phone"},
                {"id": "owner_email", "type": "text", "label": "Owner Email"},
                {"id": "alt_contact_name", "type": "text", "label": "Alternate Contact Name"},
                {"id": "alt_contact_phone", "type": "text", "label": "Alternate Contact Phone"},
                {"id": "alt_contact_email", "type": "text", "label": "Alternate Contact Email"},
                {"id": "architect", "type": "text", "label": "Architect"},
                {"id": "rcc_consultant", "type": "text", "label": "RCC Consultant"},
            ],
        },
        {
            "id": "requirement_details",
            "title": "Requirement Details",
            "role": "sales",
            "fields": [
                {"id": "lift_configuration", "type": "select", "label": "Lift Type", "options": [
                    {"label": "MR", "value": "mr"},
                    {"label": "MRL", "value": "mrl"},
                    {"label": "Hydraulic", "value": "hydraulic"},
                    {"label": "Dumbwaiter", "value": "dumbwaiter"},
                    {"label": "Goods", "value": "goods"},
                ], "required": True},
                {"id": "motor_type", "type": "select", "label": "Motor Type", "options": [
                    {"label": "Geared", "value": "geared"},
                    {"label": "Gearless", "value": "gearless"},
                    {"label": "Drum", "value": "drum"},
                    {"label": "Hydraulic", "value": "hydraulic"},
                ]},
                {
                    "id": "structure_required",
                    "type": "if_else",
                    "label": "Structure Required",
                    "options": [
                        {"label": "Yes", "value": "yes"},
                        {"label": "No", "value": "no"},
                    ],
                    "branches": {
                        "yes": [
                            {
                                "id": "structure_placement",
                                "type": "select",
                                "label": "Structure Placement",
                                "options": [
                                    {"label": "Inside shaft", "value": "inside"},
                                    {"label": "Outside shaft", "value": "outside"},
                                    {"label": "Not applicable", "value": "na"},
                                ],
                            },
                            {
                                "id": "entry_platform",
                                "type": "select",
                                "label": "Entry Platform",
                                "options": [
                                    {"label": "Yes", "value": "yes"},
                                    {"label": "No", "value": "no"},
                                ],
                            },
                        ],
                        "no": [],
                    },
                },
                {"id": "lift_placement", "type": "select", "label": "Lift Placement", "options": [
                    {"label": "Indoor", "value": "indoor"},
                    {"label": "Outdoor", "value": "outdoor"},
                ]},
                {"id": "platform_size", "type": "text", "label": "Platform Size"},
                {"id": "cladding_type", "type": "select", "label": "Cladding Type", "options": [
                    {"label": "ACP Solid", "value": "acp_solid"},
                    {"label": "ACP Designer", "value": "acp_designer"},
                    {"label": "Glass (8mm)", "value": "glass_8mm"},
                ]},
                {"id": "structure_finish", "type": "text", "label": "Structure Finish"},
                {"id": "cabin_finish", "type": "select", "label": "Cabin Finish", "options": [
                    {"label": "SS Hairline", "value": "ss_hl"},
                    {"label": "SS Mirror", "value": "ss_mirror"},
                    {"label": "SS Designer", "value": "ss_designer"},
                    {"label": "Wooden", "value": "wooden"},
                    {"label": "MS1", "value": "ms1"},
                    {"label": "MS2", "value": "ms2"},
                    {"label": "Other", "value": "other"},
                ]},
                {"id": "shaft_width", "type": "number", "label": "Shaft Width (mm)"},
                {"id": "shaft_depth", "type": "number", "label": "Shaft Depth (mm)"},
                {"id": "number_of_floors", "type": "number", "label": "Number of Floors"},
                {"id": "shaft_plastering_done", "type": "select", "label": "Shaft Plastering Done?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "front_side_masonry", "type": "select", "label": "Front Side Masonry Done?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "dual_opening", "type": "select", "label": "Dual Opening Required?", "options": [
                    {"label": "Opposite", "value": "opposite"},
                    {"label": "Adjacent", "value": "adjacent"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "wheel_chair", "type": "select", "label": "Wheel Chair?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "mechanism_side", "type": "select", "label": "Mechanism Side", "options": [
                    {"label": "Back", "value": "back"},
                    {"label": "Right", "value": "right"},
                    {"label": "Left", "value": "left"},
                ]},
                {"id": "passengers", "type": "number", "label": "Passengers"},
                {"id": "door_details", "type": "table", "label": "Door Details", "columns": [
                    {"id": "notation", "label": "Notation", "type": "text"},
                    {"id": "floor_height", "label": "Floor Height (mm)", "type": "number"},
                    {"id": "opening_side", "label": "Opening Side", "type": "select", "options": [
                        {"label": "Front", "value": "front"},
                        {"label": "Left", "value": "left"},
                        {"label": "Right", "value": "right"},
                        {"label": "Back", "value": "back"},
                    ]},
                    {"id": "door_type", "label": "Door Type", "type": "select", "options": door_type_options},
                    {"id": "door_finish", "label": "Door Finish", "type": "select", "options": door_finish_options},
                    {"id": "opening_width", "label": "Opening (mm)", "type": "number"},
                    {"id": "position", "label": "Position", "type": "select", "options": [
                        {"label": "In-shaft", "value": "in_shaft"},
                        {"label": "Out", "value": "out"},
                        {"label": "APD", "value": "apd"},
                    ]},
                    {"id": "remarks", "label": "Remarks", "type": "textarea"},
                ]},
                {"id": "photos_clicked", "type": "select", "label": "Photos clicked", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "construct_as_per_drawing", "type": "select", "label": "Shaft to construct as per drawing?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ]},
                {"id": "representative_name", "type": "text", "label": "Rep Name"},
            ],
        },
    ]

    design_sections = [
        {
            "id": "design_confirmation",
            "title": "Design Confirmation",
            "role": "design",
            "fields": [
                {"id": "pit_height_ok", "type": "select", "label": "Pit Height OK?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ], "required": True},
                {"id": "pit_height_remarks", "type": "textarea", "label": "Pit Height Remarks"},
                {"id": "overhead_height_ok", "type": "select", "label": "Overhead Height OK?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ], "required": True},
                {"id": "overhead_height_remarks", "type": "textarea", "label": "Overhead Height Remarks"},
                {"id": "lintel_height_ok", "type": "select", "label": "Lintel Height OK?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ], "required": True},
                {"id": "lintel_height_remarks", "type": "textarea", "label": "Lintel Height Remarks"},
                {"id": "floor_height_ok", "type": "select", "label": "Floor Height OK?", "options": [
                    {"label": "Yes", "value": "yes"},
                    {"label": "No", "value": "no"},
                ], "required": True},
                {"id": "floor_height_remarks", "type": "textarea", "label": "Floor Height Remarks"},
                {"id": "option1", "type": "group", "label": "Option 1", "fields": [
                    {"id": "option1_cabin_size", "type": "text", "label": "Cabin Inside Size"},
                    {"id": "option1_doors", "type": "table", "label": "Door Configuration", "columns": [
                        {"id": "side", "label": "Side", "type": "select", "options": [
                            {"label": "Front", "value": "front"},
                            {"label": "Back", "value": "back"},
                            {"label": "Left", "value": "left"},
                            {"label": "Right", "value": "right"},
                        ]},
                        {"id": "opening_size", "label": "Opening Size (mm)", "type": "number"},
                        {"id": "car_door_type", "label": "Car Door Type", "type": "select", "options": door_type_options},
                        {"id": "landing_door_type", "label": "Landing Door Type", "type": "select", "options": door_type_options},
                        {"id": "floors", "label": "Floor (All / list)", "type": "text"},
                        {"id": "landing_position", "label": "Landing Door Position", "type": "select", "options": [
                            {"label": "Inside", "value": "inside"},
                            {"label": "Outside", "value": "outside"},
                        ]},
                        {"id": "frame_position", "label": "Door Frame Position", "type": "select", "options": [
                            {"label": "Inside", "value": "inside"},
                            {"label": "Outside", "value": "outside"},
                        ]},
                        {"id": "mechanism_side", "label": "Mechanism Side", "type": "select", "options": [
                            {"label": "Front", "value": "front"},
                            {"label": "Back", "value": "back"},
                            {"label": "Left", "value": "left"},
                            {"label": "Right", "value": "right"},
                        ]},
                        {"id": "remarks", "label": "Remarks", "type": "textarea"},
                    ]},
                ]},
                {"id": "option2", "type": "group", "label": "Option 2", "fields": [
                    {"id": "option2_cabin_size", "type": "text", "label": "Cabin Inside Size"},
                    {"id": "option2_doors", "type": "table", "label": "Door Configuration", "columns": [
                        {"id": "side", "label": "Side", "type": "select", "options": [
                            {"label": "Front", "value": "front"},
                            {"label": "Back", "value": "back"},
                            {"label": "Left", "value": "left"},
                            {"label": "Right", "value": "right"},
                        ]},
                        {"id": "opening_size", "label": "Opening Size (mm)", "type": "number"},
                        {"id": "car_door_type", "label": "Car Door Type", "type": "select", "options": door_type_options},
                        {"id": "landing_door_type", "label": "Landing Door Type", "type": "select", "options": door_type_options},
                        {"id": "floors", "label": "Floor (All / list)", "type": "text"},
                        {"id": "landing_position", "label": "Landing Door Position", "type": "select", "options": [
                            {"label": "Inside", "value": "inside"},
                            {"label": "Outside", "value": "outside"},
                        ]},
                        {"id": "frame_position", "label": "Door Frame Position", "type": "select", "options": [
                            {"label": "Inside", "value": "inside"},
                            {"label": "Outside", "value": "outside"},
                        ]},
                        {"id": "mechanism_side", "label": "Mechanism Side", "type": "select", "options": [
                            {"label": "Front", "value": "front"},
                            {"label": "Back", "value": "back"},
                            {"label": "Left", "value": "left"},
                            {"label": "Right", "value": "right"},
                        ]},
                        {"id": "remarks", "label": "Remarks", "type": "textarea"},
                    ]},
                ]},
                {"id": "preferred_option", "type": "select", "label": "Preferred Option", "options": [
                    {"label": "Option 1", "value": "option1"},
                    {"label": "Option 2", "value": "option2"},
                ]},
                {"id": "engineering_remarks", "type": "textarea", "label": "Engineering Team Remarks"},
                {"id": "engineer_name", "type": "text", "label": "Engineer Name"},
            ],
        }
    ]

    return {"sections": sales_sections + design_sections}


def ensure_client_requirement_template_seed():
    """Ensure a primary client requirements form template exists."""

    existing = FormTemplate.query.filter_by(type="client_requirements").all()
    primary = next((tpl for tpl in existing if tpl.is_primary and tpl.is_active), None)

    if not primary:
        schema = json.dumps(_default_client_requirement_schema(), indent=2)
        template = FormTemplate(
            name="Client Requirements – Standard",
            slug="client_requirements_standard",
            type="client_requirements",
            is_primary=True,
            is_active=True,
            schema_json=schema,
        )
        db.session.add(template)
        db.session.flush()
        existing.append(template)
        print("✅ Seeded primary Client Requirements form template")

    if existing:
        # Ensure only one template is marked primary for this type.
        primaries = [tpl for tpl in existing if tpl.is_primary and tpl.is_active]
        if primaries:
            for tpl in primaries[1:]:
                tpl.is_primary = False
        else:
            existing[0].is_primary = True

    db.session.commit()

LEGACY_DEMO_CUSTOMERS = {
    "CUS0001": "St. Marys Convent",
    "CUS0002": "Kilowott Agency Pvt. Ltd.",
    "CUS0003": "Satguru Apartments Society",
    "CUS0004": "Jonathan Fernandes",
    "CUS0005": "Mr. Anirudh",
}

LEGACY_DEMO_LIFTS = {
    "G192": ("CUS0001", LEGACY_DEMO_CUSTOMERS["CUS0001"]),
    "G208": ("CUS0005", LEGACY_DEMO_CUSTOMERS["CUS0005"]),
    "G167": ("CUS0004", LEGACY_DEMO_CUSTOMERS["CUS0004"]),
    "G084": ("CUS0002", LEGACY_DEMO_CUSTOMERS["CUS0002"]),
    "G044": ("CUS0003", LEGACY_DEMO_CUSTOMERS["CUS0003"]),
}


def purge_legacy_demo_records():
    """Remove legacy demo customers and lifts shipped in earlier seeds."""

    removed_lifts = []
    removed_customers = []

    if "Lift" in globals():
        legacy_lift_codes = list(LEGACY_DEMO_LIFTS.keys())
        if legacy_lift_codes:
            lifts = (
                Lift.query.filter(Lift.lift_code.in_(legacy_lift_codes)).all()
            )
            for lift in lifts:
                expected_customer_code, expected_customer_name = LEGACY_DEMO_LIFTS.get(
                    lift.lift_code, (None, None)
                )
                customer_code_matches = (
                    (lift.customer_code or "").strip().upper() == expected_customer_code
                )
                customer_name_matches = True
                related_customer = getattr(lift, "customer", None)
                if related_customer and expected_customer_name:
                    customer_name_matches = (
                        (related_customer.company_name or "").strip()
                        == expected_customer_name
                    )
                if customer_code_matches and customer_name_matches:
                    delete_lift_record(lift)
                    removed_lifts.append(lift.lift_code)

    if removed_lifts:
        db.session.flush()

    if "Customer" in globals():
        legacy_customer_codes = list(LEGACY_DEMO_CUSTOMERS.keys())
        if legacy_customer_codes:
            customers = (
                Customer.query.filter(Customer.customer_code.in_(legacy_customer_codes)).all()
            )
            for customer in customers:
                expected_name = LEGACY_DEMO_CUSTOMERS.get(customer.customer_code)
                if (customer.company_name or "").strip() == expected_name:
                    db.session.delete(customer)
                    removed_customers.append(customer.customer_code)

    if removed_lifts:
        print(
            "♻️ Removed legacy demo lifts: " + ", ".join(sorted(removed_lifts))
        )
    if removed_customers:
        print(
            "♻️ Removed legacy demo customers: "
            + ", ".join(sorted(removed_customers))
        )


def ensure_dropdown_options_seed():
    for field_key, definition in DROPDOWN_FIELD_DEFINITIONS.items():
        if DropdownOption.query.filter_by(field_key=field_key).count() > 0:
            continue
        default_options = definition.get("default_options") or []
        for index, option in enumerate(default_options):
            db.session.add(
                DropdownOption(
                    field_key=field_key,
                    value=option.get("value"),
                    label=option.get("label"),
                    order_index=index,
                )
            )
    db.session.commit()


def ensure_default_org_structure_seed():
    """Seed a minimal department/position structure for fresh databases."""

    if restore_org_structure_from_backup():
        return True

    seeded = False

    if Department.query.count() == 0:
        hq = Department(
            name="Management",
            branch=DEPARTMENT_BRANCHES[0],
            description="Leadership and administration",
            active=True,
        )
        service = Department(
            name="Service",
            branch=DEPARTMENT_BRANCHES[0],
            description="Field service and maintenance",
            active=True,
        )
        sales = Department(
            name="Sales",
            branch=DEPARTMENT_BRANCHES[0],
            description="Business development and client relations",
            active=True,
        )

        db.session.add_all([hq, service, sales])
        db.session.flush()
        seeded = True

    if Position.query.count() == 0:
        management = Department.query.filter_by(name="Management").first()
        service = Department.query.filter_by(name="Service").first()
        sales = Department.query.filter_by(name="Sales").first()

        defaults = [
            Position(title="Administrator", department=management, active=True),
            Position(title="Service Technician", department=service, active=True),
            Position(title="Sales Executive", department=sales, active=True),
        ]
        db.session.add_all([p for p in defaults if p.department is not None])

        seeded = seeded or bool(defaults)

    return seeded


def get_dropdown_choices(field_key):
    definition = DROPDOWN_FIELD_DEFINITIONS.get(field_key)
    if not definition:
        return []
    options = (
        DropdownOption.query.filter_by(field_key=field_key)
        .order_by(DropdownOption.order_index.asc(), DropdownOption.id.asc())
        .all()
    )
    if not options:
        return [option.copy() for option in definition.get("default_options", [])]
    return [option.as_choice() for option in options]


def get_dropdown_options_map():
    return {
        field_key: get_dropdown_choices(field_key)
        for field_key in DROPDOWN_FIELD_DEFINITIONS.keys()
    }


SERVICE_DROPDOWN_CATEGORIES = {
    "g_plus": "Floors",
    "lift_brand": "Lift Brand Options",
}


def get_service_dropdown_options(category, active_only=True):
    query = ServiceDropdownOption.query.filter_by(category=category)
    if active_only:
        query = query.filter_by(is_active=True)
    return query.order_by(
        ServiceDropdownOption.sort_order.asc(),
        func.lower(ServiceDropdownOption.value).asc(),
    ).all()


def _next_service_dropdown_sort_order(category):
    max_sort_order = (
        db.session.query(func.max(ServiceDropdownOption.sort_order))
        .filter(ServiceDropdownOption.category == category)
        .scalar()
    )
    return (max_sort_order or 0) + 1


def _shift_service_dropdown_sort_orders(category, requested_sort_order, exclude_option_id=None):
    query = ServiceDropdownOption.query.filter(
        ServiceDropdownOption.category == category,
        ServiceDropdownOption.sort_order >= requested_sort_order,
    )
    if exclude_option_id is not None:
        query = query.filter(ServiceDropdownOption.id != exclude_option_id)

    options_to_shift = query.order_by(ServiceDropdownOption.sort_order.desc()).all()
    for option in options_to_shift:
        option.sort_order = (option.sort_order or 0) + 1


def service_dropdown_values_set(category):
    return {
        (option.value or "").strip().lower()
        for option in get_service_dropdown_options(category, active_only=True)
        if (option.value or "").strip()
    }


def service_dropdown_custom_value(category, current_value):
    value = clean_str(current_value)
    if not value:
        return None
    active_values = service_dropdown_values_set(category)
    if value.lower() in active_values:
        return None
    return value


def validate_service_dropdown_value(category, raw_value, label):
    cleaned_value = clean_str(raw_value)
    if not cleaned_value:
        return None, None
    active_values = service_dropdown_values_set(category)
    if cleaned_value.lower() not in active_values:
        return None, f"Select a valid {label} option from Service Settings."
    return cleaned_value, None
DEFAULT_TASK_FORM_NAME = "Generic Task Tracker"
TASK_TYPE_LABELS = {
    "general": "General Task",
    "qc": "QC Task",
    "design": "Design Task",
    "srt": "SRT Task",
    "milestone": "Milestone",
    "sales": "Sales Task",
    "custom": "Custom Task",
}
PROJECT_TEMPLATE_TASK_TYPES = [
    ("general", TASK_TYPE_LABELS["general"]),
    ("qc", TASK_TYPE_LABELS["qc"]),
    ("design", TASK_TYPE_LABELS["design"]),
    ("srt", TASK_TYPE_LABELS["srt"]),
    ("milestone", TASK_TYPE_LABELS["milestone"]),
    ("sales", TASK_TYPE_LABELS["sales"]),
]
PROJECT_TEMPLATE_TASK_TYPE_KEYS = set(TASK_TYPE_LABELS.keys())
PROJECT_TEMPLATE_TASK_MODULES = [
    ("general", "General"),
    ("qc", "QC"),
    ("design", "Design"),
    ("srt", "SRT"),
]
PROJECT_TEMPLATE_TASK_SUBTYPES = {
    "general": [("general", "General Task")],
    "qc": [("qc", "QC Task")],
    "design": [("drawing", "Drawing"), ("bom", "BOM")],
    "srt": [("srt", "SRT Task")],
}
PROJECT_TEMPLATE_BADGES = {
    ("general", "general"): "GENERAL TASK",
    ("qc", "qc"): "QC TASK",
    ("design", "drawing"): "DESIGN \u2013 DRAWING",
    ("design", "bom"): "DESIGN \u2013 BOM",
    ("srt", "srt"): "SRT TASK",
}
TASK_MILESTONES = [
    "Order Milestone",
    "Design Milestone",
    "Production Milestone",
    "Installation Stage 1",
    "Installation Stage 2",
    "Commissioning",
]

PROJECT_PRIORITIES = ["Immediate", "Urgent", "Normal"]
PROJECT_OPENING_TYPES = ["Single", "Adjacent", "Opposite Opening"]
PROJECT_LOCATIONS = ["Internal", "External"]
PROJECT_STRUCTURE_TYPES = ["NA", "RCC", "MS", "GI"]
PROJECT_CLADDING_TYPES = ["ACP", "Glass", "Hybrid", "Clients Scope", "Other"]
PROJECT_CABIN_FINISHES = ["SS", "MS", "Glass", "SS+Glass", "Designer", "Cage", "Half Cabin", "Other"]
PROJECT_DOOR_OPERATION_TYPES = ["Manual", "Auto"]
PROJECT_DOOR_FINISHES = ["SS", "MS", "Collapsible", "BiParting", "Gate"]
DEPARTMENT_BRANCHES = ["Goa", "Maharashtra"]

QC_STATUS_OPTIONS = [
    "Pending Inspection",
    "Inspection Done",
    "Rectification Pending",
    "Closed",
]
DESIGN_GENERAL_STATUS_OPTIONS = [
    "In progress",
    "Hold",
    "Complete",
    "Cancelled",
]
DESIGN_TASK_STATUS_OPTIONS = [
    "Drawing pending",
    "SRT input",
    "Sales input",
    "Sent for approval",
    "BOM pending",
    "BOM approved",
    "Finalized",
]
DESIGN_SITE_VISIT_STATUS_OPTIONS = [
    "In progress",
    "Complete",
    "Delayed",
]
SRT_STATUS_OPTIONS = [
    "Scheduled",
    "Site Visited",
    "Pending Civil Work",
    "Ready for Installation",
    "Closed",
]


WORKSPACE_MODULES = [
    {
        "key": "customer_support",
        "label": "Customer Support",
        "description": "Support overview, ticket triage and linked tasks.",
        "visibility_label": "Show Customer Support workspace",
        "assignment_label": "Allow Customer Support ownership",
    },
    {
        "key": "service",
        "label": "Service",
        "description": "Post-installation service delivery, tasks and maintenance orchestration.",
        "visibility_label": "Show Service workspace",
        "assignment_label": "Allow Service task assignment",
    },
    {
        "key": "sales",
        "label": "Sales",
        "description": "Pipeline, clients and revenue forecasting dashboards.",
        "visibility_label": "Show Sales workspace",
        "assignment_label": "Allow Sales ownership",
    },
    {
        "key": "operations",
        "label": "Operations",
        "description": "Project delivery tools inside the New Installation area.",
        "visibility_label": "Show Operations workspace",
        "assignment_label": "Allow Operations task assignment",
    },
    {
        "key": "srt",
        "label": "SRT",
        "description": "Service Response Team dashboards and templates.",
        "visibility_label": "Show SRT workspace",
        "assignment_label": "Allow SRT ownership",
    },
    {
        "key": "qc",
        "label": "Quality Control",
        "description": "QC boards, task tracking and submission reviews.",
        "visibility_label": "Show QC workspace",
        "assignment_label": "Allow QC task assignment",
    },
]

WORKSPACE_MODULE_MAP = {module["key"]: module for module in WORKSPACE_MODULES}


def slugify(value):
    value = (value or "").lower()
    value = re.sub(r"[^a-z0-9]+", "-", value)
    value = re.sub(r"-+", "-", value).strip("-")
    return value or _random_digits(6)


def _slugify_ref_key(value, fallback="item"):
    value = (value or "").lower()
    value = re.sub(r"\s+", "_", value)
    value = re.sub(r"[^a-z0-9_]", "", value)
    value = re.sub(r"_+", "_", value).strip("_")
    return value or fallback


def _generate_unique_ref_key(base_value, existing_keys):
    base = _slugify_ref_key(base_value)
    while True:
        suffix = uuid.uuid4().hex[:4]
        candidate = f"{base}_{suffix}"
        if candidate not in existing_keys:
            return candidate


SRT_SAMPLE_TASKS = []


SRT_TASK_ACTIVITY = {}



SERVICE_COMPLAINTS = []


SERVICE_CONTRACTS = []


SERVICE_PARTS_LEDGER = {
    "stock_alerts": [],
    "consumption": [],
    "returns": [],
}


SERVICE_AUTOMATIONS = {
    "flows": [
        {
            "from": "Sarv",
            "to": "Customer Support",
            "summary": "Incoming calls auto-create tickets with recording",
        },
        {
            "from": "Customer Support",
            "to": "Service (AMC)",
            "summary": "Marking as AMC support converts to AMC service task",
        },
        {
            "from": "Customer Support",
            "to": "Service (Non-AMC)",
            "summary": "Creates chargeable task + optional Sales alert",
        },
        {
            "from": "Service Task",
            "to": "Inventory",
            "summary": "Parts usage deducts stock / raises PR",
        },
        {
            "from": "Service Task",
            "to": "Overview",
            "summary": "Live metrics refresh once task updates",
        },
    ],
    "roles": {
        "Admin": ["Full access", "Configure automations"],
        "Service Manager": ["Planner, contracts, reports", "Approve conversions"],
        "Technician": ["My tasks", "Upload media", "View assigned lifts"],
    },
    "config": [
        "Complaint categories & priorities",
        "SLA presets and escalation timers",
        "PM checklist templates per lift type",
        "Task statuses and close codes",
        "Dashboard widget toggles + alert thresholds",
    ],
}


DEFAULT_LIFT_INSIGHT = {
    "lifetime_value": {
        "total_breakdowns_this_year": 0,
        "breakdowns_completed_this_year": 0,
        "breakdowns_pending_this_year": 0,
        "total_amc_value": 0,
        "total_repair_revenue": 0,
        "repair_revenue_this_year": 0,
        "total_cost": 0,
        "total_cost_this_year": 0,
        "total_revenue_till_date": 0,
        "net_lifetime_profitability": 0,
    },
    "amc": {
        "status": "Not captured",
        "type": "Not captured",
        "start": None,
        "end": None,
        "contract_value": 0,
        "payment_terms": "—",
        "services_per_year": 0,
        "pending_services_count": 0,
        "service_owner": "—",
        "service_contact": "—",
        "renewal_history": [],
        "attachments": [],
        "service_schedule": [],
    },
    "machine": {
        "make": "—",
        "model": "—",
        "serial": "—",
    },
    "drive_type": "—",
    "controller_type": "—",
    "door_configuration": None,
    "commissioned_date": None,
    "floors_served": None,
    "breakdowns": [],
    "breakdown_summary": [],
    "uploads": {
        "documents": [],
        "media": [],
        "other": [],
    },
    "timeline": [],
    "site_name": None,
}


LIFT_INSIGHT_LIBRARY = {}


CUSTOMER_SUPPORT_CATEGORIES = [
    {
        "id": "sales-ni",
        "label": "Sales – NI",
        "description": "Pre-sales and new installation related follow-ups.",
        "default_first_response_hours": 4,
        "default_resolution_hours": 24,
    },
    {
        "id": "support-ni",
        "label": "Support – NI",
        "description": "Post-sale NI support tasks and follow-ups.",
        "default_first_response_hours": 4,
        "default_resolution_hours": 24,
    },
    {
        "id": "sales-amc",
        "label": "Sales – AMC",
        "description": "Annual maintenance contract conversations and renewals.",
        "default_first_response_hours": 6,
        "default_resolution_hours": 48,
    },
    {
        "id": "support-amc",
        "label": "Support – AMC",
        "description": "Breakdown, callbacks and reactive maintenance tickets.",
        "default_first_response_hours": 2,
        "default_resolution_hours": 18,
    },
    {
        "id": "other-dept",
        "label": "Other Department",
        "description": "Requests that need to be routed to internal departments.",
        "default_first_response_hours": 8,
        "default_resolution_hours": 72,
    },
    {
        "id": "other-query",
        "label": "Other Query",
        "description": "General enquiries that do not fit the above categories.",
        "default_first_response_hours": 12,
        "default_resolution_hours": 120,
    },
]

CUSTOMER_SUPPORT_CHANNELS = [
    {"id": "phone", "label": "Phone", "icon": "📞"},
    {"id": "email", "label": "Email", "icon": "✉️"},
    {"id": "web", "label": "Web", "icon": "🌐"},
    {"id": "walk-in", "label": "Walk-in", "icon": "🚪"},
    {"id": "whatsapp", "label": "WhatsApp", "icon": "💬"},
]


CUSTOMER_SUPPORT_SETTINGS_PATH = os.path.join(
    BASE_DIR, "instance", "customer_support_settings.json"
)


def _ticket_category_key(ticket_or_value):
    if isinstance(ticket_or_value, dict):
        return (
            (ticket_or_value.get("category_key") or ticket_or_value.get("category") or "")
            .strip()
            .lower()
        )
    return (ticket_or_value or "").strip().lower()


def _ticket_is_other_department(ticket_or_value):
    key = _ticket_category_key(ticket_or_value)
    return key in {"other-dept", "other department"}


def _filter_other_department_records(records, *, include_other_department=False):
    if include_other_department:
        return list(records)
    return [record for record in records if not _ticket_is_other_department(record)]


def _default_customer_support_settings():
    return {
        "category_position_assignments": {},
    }


def _normalise_category_position_assignments(data):
    assignments = {}
    if not isinstance(data, dict):
        return assignments

    for key, value in data.items():
        category_id = (key or "").strip()
        if not category_id:
            continue
        positions = []
        for item in value or []:
            try:
                position_id = int(item)
            except (TypeError, ValueError):
                continue
            positions.append(position_id)

        if positions:
            assignments[category_id] = sorted(set(positions))

    return assignments


def _load_customer_support_settings():
    settings = _default_customer_support_settings()
    if not os.path.exists(CUSTOMER_SUPPORT_SETTINGS_PATH):
        return settings

    try:
        with open(CUSTOMER_SUPPORT_SETTINGS_PATH, "r", encoding="utf-8") as fp:
            payload = json.load(fp)
        if isinstance(payload, dict):
            settings.update(
                {
                    "category_position_assignments": _normalise_category_position_assignments(
                        payload.get("category_position_assignments", {})
                    ),
                }
            )
    except (OSError, json.JSONDecodeError):
        pass

    return settings


def _save_customer_support_settings(settings):
    os.makedirs(os.path.dirname(CUSTOMER_SUPPORT_SETTINGS_PATH), exist_ok=True)
    to_store = {
        **_default_customer_support_settings(),
        **(settings or {}),
    }
    to_store["category_position_assignments"] = _normalise_category_position_assignments(
        to_store.get("category_position_assignments", {})
    )

    with open(CUSTOMER_SUPPORT_SETTINGS_PATH, "w", encoding="utf-8") as fp:
        json.dump(to_store, fp, ensure_ascii=False, indent=2)


def _category_allows_user_assignment(category_id, user, settings=None):
    if not category_id or not user:
        return True

    settings = settings or _load_customer_support_settings()
    mapping = settings.get("category_position_assignments") or {}
    if not isinstance(mapping, dict):
        return True

    allowed_positions = mapping.get(category_id) or []
    if not allowed_positions:
        return True

    return user.position_id in allowed_positions

CUSTOMER_SUPPORT_AMC_SITES = []

CUSTOMER_SUPPORT_SLA_PRESETS = [
    {
        "id": "standard",
        "label": "Standard",
        "first_response_hours": 6,
        "resolution_hours": 48,
    },
    {
        "id": "priority",
        "label": "Priority",
        "first_response_hours": 2,
        "resolution_hours": 18,
    },
    {
        "id": "critical",
        "label": "Critical",
        "first_response_hours": 1,
        "resolution_hours": 8,
    },
]


CUSTOMER_SUPPORT_DEFAULT_TEAM = {
    "Service Desk",
    "Field Team 3",
    "Customer Care Desk",
}

CUSTOMER_SUPPORT_TICKETS = []

CUSTOMER_SUPPORT_CALL_LOGS = []


def _load_customer_support_state():
    if not os.path.exists(CUSTOMER_SUPPORT_DATA_PATH):
        return

    try:
        with open(CUSTOMER_SUPPORT_DATA_PATH, "r", encoding="utf-8") as fp:
            payload = json.load(fp)
    except (OSError, json.JSONDecodeError):
        app.logger.warning("Could not load customer support state; starting fresh.")
        return

    tickets = payload.get("tickets")
    if isinstance(tickets, list):
        CUSTOMER_SUPPORT_TICKETS[:] = [
            _decode_special_types(ticket) for ticket in tickets if isinstance(ticket, dict)
        ]

    call_logs = payload.get("call_logs")
    if isinstance(call_logs, list):
        CUSTOMER_SUPPORT_CALL_LOGS[:] = [
            _decode_special_types(call) for call in call_logs if isinstance(call, dict)
        ]


def _save_customer_support_state():
    os.makedirs(os.path.dirname(CUSTOMER_SUPPORT_DATA_PATH), exist_ok=True)
    payload = {
        "tickets": [_encode_special_types(ticket) for ticket in CUSTOMER_SUPPORT_TICKETS],
        "call_logs": [_encode_special_types(call) for call in CUSTOMER_SUPPORT_CALL_LOGS],
    }
    try:
        with open(CUSTOMER_SUPPORT_DATA_PATH, "w", encoding="utf-8") as fp:
            json.dump(payload, fp, ensure_ascii=False, indent=2)
    except OSError as exc:
        app.logger.error("Failed to save customer support state: %s", exc)


_load_customer_support_state()


def _get_srt_task(task_id):
    return next((task for task in SRT_SAMPLE_TASKS if task["id"] == task_id), None)


def _log_srt_activity(task_id, **payload):
    if not task_id:
        return

    event = apply_actor_context(payload)
    event.setdefault("timestamp", datetime.datetime.utcnow())
    SRT_TASK_ACTIVITY.setdefault(task_id, []).append(event)


def _default_srt_item():
    return {
        "label": "New Checklist Item",
        "type": "select",
        "options": ["OK", "Not OK", "Need Client Input"],
        "required": True,
        "allow_photo": True,
        "allow_remark": True,
        "photo_required_if_ng": False,
        "display_image": "",
    }


def _default_srt_schema():
    return [
        {
            "section": "General",
            "display_image": "",
            "items": [_default_srt_item()],
        }
    ]


def _get_customer_support_ticket(ticket_id):
    if not ticket_id:
        return None

    return next((ticket for ticket in CUSTOMER_SUPPORT_TICKETS if ticket["id"] == ticket_id), None)


def _get_linked_ticket_for_opportunity(opportunity_id: int):
    """
    Return the first linked Customer Support ticket for a Sales opportunity.
    """
    if not opportunity_id:
        return None
    for ticket in CUSTOMER_SUPPORT_TICKETS:
        linked = ticket.get("linked_sales_opportunity") or {}
        try:
            linked_id = int(linked.get("id"))
        except (TypeError, ValueError):
            continue
        if linked_id == int(opportunity_id):
            return ticket
    return None


def _ticket_has_open_linked_tasks(ticket):
    if not ticket:
        return False

    category_key = _ticket_category_key(ticket)
    skip_opportunity_tasks = category_key == "sales-ni"
    closing_statuses = {"closed", "resolved", "completed", "done", "cancelled"}
    for task in ticket.get("linked_tasks", []) or []:
        if skip_opportunity_tasks:
            related_type = (task.get("related_type") or "").strip().lower()
            if related_type == "opportunity":
                continue

        status = (task.get("status") or "").strip().lower()
        if status and status in closing_statuses:
            continue
        if status:
            return True
        if not status:
            return True
    return False


def _resolve_customer_support_channel_label(channel_value):
    if not channel_value:
        return None

    lowered = channel_value.lower()
    for channel in CUSTOMER_SUPPORT_CHANNELS:
        channel_id = (channel.get("id") or "").lower()
        channel_label = (channel.get("label") or "").lower()
        if lowered in {channel_id, channel_label}:
            return channel.get("label")
    return None


def _create_enquiry_from_sales_ni_task(*, ticket, title, details, assignee_user, owner_user):
    enquiry_title = title or ticket.get("subject") or ticket.get("id") or "Sales enquiry"
    pipeline_config = get_pipeline_config("lift")
    stages = pipeline_config.get("stages", []) if isinstance(pipeline_config, dict) else []
    default_stage = stages[0] if stages else "New Enquiry"

    description_parts = []
    if ticket.get("id"):
        description_parts.append(f"Linked ticket: {ticket.get('id')}")
    if ticket.get("customer"):
        description_parts.append(f"Customer/site: {ticket.get('customer')}")
    if ticket.get("location"):
        description_parts.append(f"Location: {ticket.get('location')}")
    if details:
        description_parts.append(details)
    description = "\n".join(part for part in description_parts if part)

    enquiry_owner = assignee_user or owner_user
    if not enquiry_owner and current_user.is_authenticated:
        enquiry_owner = current_user

    linked_client = None
    if ticket.get("linked_sales_client") and ticket["linked_sales_client"].get("id"):
        linked_client = db.session.get(SalesClient, ticket["linked_sales_client"]["id"])

    linked_project = None
    if ticket.get("linked_installation_project") and ticket["linked_installation_project"].get("id"):
        linked_project = db.session.get(Project, ticket["linked_installation_project"]["id"])

    enquiry = SalesOpportunity(
        title=enquiry_title,
        pipeline="lift",
        stage=default_stage,
        description=description or None,
        owner=enquiry_owner,
        client=linked_client,
        project=linked_project,
    )
    db.session.add(enquiry)
    db.session.flush()

    return enquiry


def _format_customer_support_amc_site_from_lift(lift):
    if not lift:
        return None

    location_parts = [
        lift.site_address_line1,
        lift.site_address_line2,
        lift.city,
        lift.state,
    ]
    location = ", ".join(part for part in location_parts if part)

    base_label = lift.lift_code or f"Lift {lift.id}"
    label = f"{base_label} · {location}" if location else base_label

    customer_name = None
    customer_code = None
    if lift.customer:
        customer_name = lift.customer.company_name or None
        customer_code = lift.customer.customer_code or None
    else:
        customer_code = lift.customer_code or None

    return {
        "id": str(lift.id),
        "label": label,
        "client": customer_name or customer_code,
        "customer_name": customer_name,
        "customer_code": customer_code,
        "amc_status": lift.amc_status or None,
    }


def _customer_support_amc_site_options():
    lifts = (
        Lift.query.options(joinedload(Lift.customer))
        .order_by(func.lower(Lift.lift_code))
        .all()
    )

    options = []
    for lift in lifts:
        formatted = _format_customer_support_amc_site_from_lift(lift)
        if formatted:
            options.append(formatted)

    return sorted(options, key=lambda item: (item.get("label") or "").lower())


def _resolve_customer_support_amc_site(site_id):
    if not site_id:
        return None

    try:
        lift_id = int(site_id)
    except (TypeError, ValueError):
        lift_id = None

    if lift_id is not None:
        lift = db.session.get(Lift, lift_id)
        formatted = _format_customer_support_amc_site_from_lift(lift)
        if formatted:
            return formatted

    lowered = site_id.lower()
    for site in CUSTOMER_SUPPORT_AMC_SITES:
        if lowered == (site.get("id") or "").lower():
            return site
    return None


def _generate_customer_support_ticket_id():
    existing_numbers = []
    for ticket in CUSTOMER_SUPPORT_TICKETS:
        match = re.match(r"CS-(\d+)$", str(ticket.get("id") or ""))
        if match:
            try:
                existing_numbers.append(int(match.group(1)))
            except ValueError:
                continue

    next_number = (max(existing_numbers) + 1) if existing_numbers else 1001
    while any(ticket.get("id") == f"CS-{next_number}" for ticket in CUSTOMER_SUPPORT_TICKETS):
        next_number += 1
    return f"CS-{next_number}"


def _customer_support_summary():
    summary = {
        "Open": 0,
        "In Progress": 0,
        "Resolved": 0,
        "Closed": 0,
    }

    for ticket in _filter_other_department_records(CUSTOMER_SUPPORT_TICKETS):
        summary.setdefault(ticket["status"], 0)
        summary[ticket["status"]] += 1

    total = sum(summary.values())
    return {
        "counts": summary,
        "total": total,
        "recent": sorted(
            CUSTOMER_SUPPORT_TICKETS,
            key=lambda item: item.get("updated_at") or item.get("created_at"),
            reverse=True,
        ),
    }


def _calculate_ticket_sla_due(ticket):
    if not isinstance(ticket, dict):
        return None

    if ticket.get("due_at"):
        return ticket.get("due_at")

    sla = ticket.get("sla") or {}
    created_at = ticket.get("created_at")
    resolution_hours = sla.get("resolution_hours")
    if created_at and resolution_hours:
        try:
            hours = float(resolution_hours)
        except (TypeError, ValueError):
            return None
        return created_at + datetime.timedelta(hours=hours)
    return None


def _customer_support_team_members():
    members = set(CUSTOMER_SUPPORT_DEFAULT_TEAM)
    for user in get_assignable_users_for_module("customer_support"):
        if user.is_active:
            members.add(user.display_name)
    for ticket in CUSTOMER_SUPPORT_TICKETS:
        assignee = ticket.get("assignee")
        if assignee:
            members.add(assignee)
        for event in ticket.get("timeline", []):
            actor = event.get("actor")
            if actor:
                members.add(actor)
    if current_user.is_authenticated:
        members.add(current_user.display_name)
    members.add("Unassigned")
    return sorted(member for member in members if member)


def _resolve_ticket_assignee_user(ticket, module_key="customer_support"):
    if not isinstance(ticket, dict):
        return None

    assignee_user_id = ticket.get("assignee_user_id")
    if assignee_user_id:
        try:
            user_id = int(assignee_user_id)
        except (TypeError, ValueError):
            user_id = None
        if user_id is not None:
            user = User.query.get(user_id)
            if user and user.is_active:
                if not module_key or user.can_be_assigned_module(module_key):
                    return user

    assignee_name = (ticket.get("assignee") or "").strip()
    if not assignee_name or assignee_name.lower() == "unassigned":
        return None

    lowered_name = assignee_name.lower()
    potential_users = get_assignable_users_for_module(module_key) if module_key else User.query.all()
    for user in potential_users:
        if not user.is_active:
            continue
        if user.display_name.strip().lower() == lowered_name or user.username.strip().lower() == lowered_name:
            ticket["assignee_user_id"] = user.id
            ticket["assignee"] = user.display_name
            return user

    user = User.query.filter(func.lower(User.username) == lowered_name).first()
    if user and user.is_active:
        if not module_key or user.can_be_assigned_module(module_key):
            ticket["assignee_user_id"] = user.id
            ticket["assignee"] = user.display_name
            return user

    return None


def _resolve_ticket_owner_user(ticket, module_key="customer_support"):
    if not isinstance(ticket, dict):
        return None

    owner_user_id = ticket.get("owner_user_id")
    if owner_user_id:
        try:
            user_id = int(owner_user_id)
        except (TypeError, ValueError):
            user_id = None
        if user_id is not None:
            user = User.query.get(user_id)
            if user and user.is_active:
                if not module_key or user.can_be_assigned_module(module_key):
                    return user

    owner_name = (ticket.get("owner") or "").strip()
    if not owner_name or owner_name.lower() == "unassigned":
        return None

    lowered_name = owner_name.lower()
    potential_users = get_assignable_users_for_module(module_key) if module_key else User.query.all()
    for user in potential_users:
        if not user.is_active:
            continue
        if user.display_name.strip().lower() == lowered_name or user.username.strip().lower() == lowered_name:
            ticket["owner_user_id"] = user.id
            ticket["owner"] = user.display_name
            return user

    user = User.query.filter(func.lower(User.username) == lowered_name).first()
    if user and user.is_active:
        if not module_key or user.can_be_assigned_module(module_key):
            ticket["owner_user_id"] = user.id
            ticket["owner"] = user.display_name
            return user

    return None


def _user_is_service_team_member(user, service_user_ids):
    if not user or not user.is_active:
        return False
    if user.id in service_user_ids:
        return True
    department = (getattr(user, "department", "") or "").strip().lower()
    return department == "service"


def _user_is_service_manager(user: "User") -> bool:
    """
    Identify Service I/C (service incharge).

    Rules:
    - Must be active.
    - Must be able to view Service module.
    - Either:
      - Has Position title 'Service I/C' / variants (legacy mode), OR
      - Has the is_service_manager flag set.
    """
    if not user or not getattr(user, "is_active", False):
        return False

    # Must at least have access to the Service module
    if not user.can_view_module("service"):
        return False

    # Flag-based configuration (preferred)
    if getattr(user, "is_service_manager", False):
        return True

    # Backward-compatible: Position title (org structure table)
    position = getattr(user, "position", None)
    title = ""
    if position and position.title:
        title = position.title.strip().lower()

    if title in {"service i/c", "service incharge", "service in-charge"}:
        return True

    return False


def _service_complaint_tasks_from_support():
    service_users = get_assignable_users_for_module("service")
    service_user_ids = {user.id for user in service_users if user.is_active}

    complaint_tasks = []
    for ticket in _filter_other_department_records(CUSTOMER_SUPPORT_TICKETS):
        status_value = (ticket.get("status") or "").strip().lower()
        if status_value in {"resolved", "closed"}:
            continue

        assigned_user = _resolve_ticket_assignee_user(ticket)
        owner_user = _resolve_ticket_owner_user(ticket)
        if not _user_is_service_team_member(assigned_user, service_user_ids):
            continue

        site_label = ticket.get("location") or ticket.get("customer") or "Site not specified"
        client_label = ticket.get("customer") or ticket.get("contact_name") or "Customer pending"
        lift_label = (ticket.get("amc_site") or {}).get("label") or "—"

        due_at = ticket.get("due_at") or _calculate_ticket_sla_due(ticket)
        if isinstance(due_at, datetime.datetime):
            schedule_window = due_at.strftime("%d %b · %H:%M")
        else:
            schedule_window = "Awaiting scheduling"

        sla_info = ticket.get("sla") or {}
        resolution_hours = sla_info.get("resolution_hours")
        if resolution_hours:
            sla_label = f"Resolve within {resolution_hours}h"
        else:
            sla_label = "No SLA defined"

        worklog_entries = []
        created_at = ticket.get("created_at")
        if isinstance(created_at, datetime.datetime):
            worklog_entries.append(
                {
                    "label": ticket.get("subject") or "Ticket logged",
                    "time": created_at.strftime("%d %b %H:%M"),
                }
            )
        updated_at = ticket.get("updated_at")
        if (
            isinstance(updated_at, datetime.datetime)
            and updated_at != created_at
            and ticket.get("status")
        ):
            worklog_entries.append(
                {
                    "label": f"Status: {ticket.get('status')}",
                    "time": updated_at.strftime("%d %b %H:%M"),
                }
            )

        complaint_tasks.append(
            {
                "id": ticket.get("id"),
                "owner": owner_user.display_name if owner_user else ticket.get("owner") or "Unassigned",
                "site": site_label,
                "client": client_label,
                "lift_id": lift_label,
                "call_type": f"Complaint · {ticket.get('category')}" if ticket.get("category") else "Complaint",
                "priority": ticket.get("priority") or "Medium",
                "technicians": [assigned_user.display_name] if assigned_user else [],
                "assignee": assigned_user.display_name if assigned_user else ticket.get("assignee") or "Unassigned",
                "schedule_window": schedule_window,
                "sla": sla_label,
                "status": ticket.get("status") or "Open",
                "worklog": worklog_entries,
                "requires_media": False,
                "parts_used": [],
                "origin_ticket_id": ticket.get("id"),
            }
        )

    return complaint_tasks


def _infer_attachment_type(filename, mimetype=None):
    ext = (os.path.splitext(filename)[1] or "").lower()
    if mimetype:
        major = mimetype.split("/", 1)[0].lower()
        if major == "image":
            return "image"
        if major == "video":
            return "video"
    if ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp"}:
        return "image"
    if ext in {".mp4", ".mov", ".avi", ".mkv", ".webm"}:
        return "video"
    return "file"


def _save_customer_support_attachments(files):
    upload_root = app.config["UPLOAD_FOLDER"]
    os.makedirs(upload_root, exist_ok=True)

    saved = []
    timestamp_prefix = datetime.datetime.utcnow().strftime("%Y%m%d%H%M%S")

    for index, file in enumerate(files or []):
        if not file or not file.filename:
            continue

        original_name = secure_filename(file.filename)
        if not original_name:
            continue

        dest_name = f"{timestamp_prefix}_{index}_{original_name}"
        dest_path = os.path.join(upload_root, dest_name)

        try:
            file.save(dest_path)
        except Exception:
            flash(f"Could not save attachment '{original_name}'.", "error")
            continue

        attachment_type = _infer_attachment_type(original_name, getattr(file, "mimetype", None))
        saved.append(
            {
                "label": original_name,
                "type": attachment_type,
                "url": url_for("static", filename=f"uploads/{dest_name}"),
            }
        )

    return saved


def _derive_customer_support_call_from_ticket(ticket):
    if not isinstance(ticket, dict):
        return None

    ticket_id = ticket.get("id")
    if not ticket_id:
        return None

    logged_at = (
        ticket.get("created_at")
        or ticket.get("updated_at")
        or datetime.datetime.utcnow()
    )

    return {
        "call_id": f"{ticket_id}-call",
        "ticket_id": ticket_id,
        "subject": ticket.get("subject") or "Support ticket",
        "category": ticket.get("category") or "Uncategorised",
        "status": ticket.get("status") or "Open",
        "channel": ticket.get("channel") or "Phone",
        "caller": ticket.get("contact_name")
        or ticket.get("customer")
        or "Unknown caller",
        "handled_by": ticket.get("assignee") or "Unassigned",
        "duration_minutes": ticket.get("call_duration_minutes") or 8,
        "logged_at": logged_at,
    }


def _customer_support_call_records():
    combined = []
    seen_ids = set()

    for call in CUSTOMER_SUPPORT_CALL_LOGS:
        if not isinstance(call, dict):
            continue

        call_id = call.get("call_id") or call.get("ticket_id")
        if not call_id:
            continue

        if call_id in seen_ids:
            continue

        seen_ids.add(call_id)
        combined.append(call)

    for ticket in CUSTOMER_SUPPORT_TICKETS:
        call_entry = _derive_customer_support_call_from_ticket(ticket)
        if not call_entry or call_entry.get("call_id") in seen_ids:
            continue

        seen_ids.add(call_entry.get("call_id"))
        combined.append(call_entry)

    return combined


def _customer_support_filter_calls(category=None, status=None, search=None):
    records = _customer_support_call_records()

    if category:
        category = category.lower()
        records = [
            record
            for record in records
            if (record.get("category") or "").lower() == category
        ]

    if status:
        status = status.lower()
        records = [
            record
            for record in records
            if (record.get("status") or "").lower() == status
        ]

    if search:
        term = search.lower()
        records = [
            record
            for record in records
            if term in (record.get("subject") or "").lower()
            or term in (record.get("caller") or "").lower()
            or term in (record.get("ticket_id") or "").lower()
        ]

    return sorted(
        records,
        key=lambda item: item.get("logged_at") or datetime.datetime.min,
        reverse=True,
    )


def _handle_customer_support_ticket_creation():
    form_name = (request.form.get("form_name") or "").strip().lower()
    if form_name != "create_ticket":
        return None

    support_settings = _load_customer_support_settings()
    customer = (request.form.get("customer") or "").strip()
    contact_name = (request.form.get("contact_name") or "").strip()
    contact_phone = (request.form.get("contact_phone") or "").strip()
    contact_email = (request.form.get("contact_email") or "").strip()
    location = (request.form.get("location") or "").strip()
    subject = (request.form.get("subject") or "").strip()
    category_id = (request.form.get("category") or "").strip()
    amc_site_id = (request.form.get("amc_site") or "").strip()
    channel_value = (request.form.get("channel") or "").strip()
    sla_priority_id = (request.form.get("sla_priority") or "").strip()
    owner_value = (request.form.get("owner") or "").strip()
    assignee_value = (request.form.get("assignee") or "").strip()
    due_raw = (request.form.get("due_datetime") or "").strip()
    remarks = (request.form.get("remarks") or "").strip()
    uploaded_files = request.files.getlist("attachments") or []
    linked_sales_client_id_raw = (request.form.get("linked_sales_client_id") or "").strip()
    linked_project_id_raw = (request.form.get("linked_project_id") or "").strip()
    linked_customer_id_raw = (request.form.get("linked_customer_id") or "").strip()
    linked_lift_id_raw = (request.form.get("linked_lift_id") or "").strip()
    create_sales_lead = _form_truthy(request.form.get("create_sales_lead"))
    sales_lead_owner_id_raw = (request.form.get("sales_lead_owner_id") or "").strip()

    errors = []
    form_values = request.form.to_dict(flat=True)
    owner_user = None
    assignee_user = None
    assignee_user_id = None
    sales_lead_owner = None
    if not subject:
        errors.append("Provide a summary of the customer issue.")
    if not category_id:
        errors.append("Select a ticket category.")
    if not channel_value:
        errors.append("Select the intake channel for the ticket.")

    category_label = None
    category_requires_customer = True
    if category_id:
        category_label = next(
            (item.get("label") for item in CUSTOMER_SUPPORT_CATEGORIES if item.get("id") == category_id),
            None,
        )
        if not category_label:
            errors.append("Choose a valid ticket category.")
        lowered_category = category_id.lower()
        if lowered_category in {"other-dept", "other-query"}:
            category_requires_customer = False

    amc_site_record = None
    if category_id.lower() == "support-amc".lower():
        if not amc_site_id:
            errors.append("Select the AMC site for support AMC tickets.")
        else:
            amc_site_record = _resolve_customer_support_amc_site(amc_site_id)
            if not amc_site_record:
                errors.append("Choose a valid AMC site from the list.")

    if amc_site_record:
        linked_customer_name = (
            amc_site_record.get("customer_name")
            or amc_site_record.get("client")
            or amc_site_record.get("customer")
        )
        if linked_customer_name and not customer:
            customer = linked_customer_name

    linked_sales_client = None
    if linked_sales_client_id_raw:
        try:
            linked_sales_client_id = int(linked_sales_client_id_raw)
        except (TypeError, ValueError):
            errors.append("Select a valid sales client to link.")
        else:
            linked_sales_client = db.session.get(SalesClient, linked_sales_client_id)
            if not linked_sales_client:
                errors.append("Select a valid sales client to link.")
            elif not customer:
                customer = (
                    linked_sales_client.display_name
                    or linked_sales_client.company_name
                    or linked_sales_client.description
                    or f"Client {linked_sales_client.id}"
                )

    linked_project = None
    if linked_project_id_raw:
        try:
            linked_project_id = int(linked_project_id_raw)
        except (TypeError, ValueError):
            errors.append("Select a valid installation project to link.")
        else:
            linked_project = db.session.get(Project, linked_project_id)
            if not linked_project:
                errors.append("Select a valid installation project to link.")
            elif not customer:
                customer = linked_project.customer_name or linked_project.name

    linked_customer = None
    if linked_customer_id_raw:
        try:
            linked_customer_id = int(linked_customer_id_raw)
        except (TypeError, ValueError):
            errors.append("Select a valid AMC customer to link.")
        else:
            linked_customer = db.session.get(Customer, linked_customer_id)
            if not linked_customer:
                errors.append("Select a valid AMC customer to link.")
            elif not customer:
                customer = linked_customer.company_name or linked_customer.customer_code

    linked_lift = None
    if linked_lift_id_raw:
        try:
            linked_lift_id = int(linked_lift_id_raw)
        except (TypeError, ValueError):
            errors.append("Select a valid lift to link.")
        else:
            linked_lift = db.session.get(Lift, linked_lift_id)
            if not linked_lift:
                errors.append("Select a valid lift to link.")
            elif not customer:
                if linked_lift.customer and linked_lift.customer.company_name:
                    customer = linked_lift.customer.company_name
                elif linked_lift.customer_code:
                    customer = linked_lift.customer_code

    if category_requires_customer and not customer:
        errors.append("Enter the customer name for the ticket.")

    channel_label = _resolve_customer_support_channel_label(channel_value)
    if channel_value and not channel_label:
        errors.append("Choose a valid ticket channel.")

    critical_sla_categories = {"sales-ni", "support-ni", "sales-amc", "support-amc"}
    default_sla_priority_id = (
        "critical" if category_id.lower() in critical_sla_categories else "standard"
    )

    if not sla_priority_id:
        sla_priority_id = default_sla_priority_id

    sla_preset = next(
        (preset for preset in CUSTOMER_SUPPORT_SLA_PRESETS if preset.get("id") == sla_priority_id),
        None,
    )

    if not sla_preset:
        sla_priority_id = default_sla_priority_id
        sla_preset = next(
            (preset for preset in CUSTOMER_SUPPORT_SLA_PRESETS if preset.get("id") == sla_priority_id),
            None,
        )

    if not sla_preset and CUSTOMER_SUPPORT_SLA_PRESETS:
        sla_preset = CUSTOMER_SUPPORT_SLA_PRESETS[0]

    due_at = None
    if due_raw:
        try:
            due_at = datetime.datetime.strptime(due_raw, "%Y-%m-%dT%H:%M")
        except ValueError:
            errors.append("Enter the due date in YYYY-MM-DD HH:MM format.")

    if owner_value:
        try:
            owner_user_id = int(owner_value)
        except (TypeError, ValueError):
            owner_user_id = None
        if owner_user_id is None:
            errors.append("Select a valid owner from the ERP user list.")
        else:
            owner_user = User.query.get(owner_user_id)
            if (
                not owner_user
                or not owner_user.is_active
                or not owner_user.can_be_assigned_module("customer_support")
            ):
                errors.append("Select a valid owner from the ERP user list.")

    if assignee_value:
        try:
            assignee_user_id = int(assignee_value)
        except (TypeError, ValueError):
            assignee_user_id = None
        if assignee_user_id is None:
            errors.append("Select a valid assignee from the ERP user list.")
        else:
            assignee_user = User.query.get(assignee_user_id)
            if (
                not assignee_user
                or not assignee_user.is_active
                or not assignee_user.can_be_assigned_module("customer_support")
            ):
                errors.append("Select a valid assignee from the ERP user list.")
            elif not _category_allows_user_assignment(
                category_id, assignee_user, settings=support_settings
            ):
                errors.append(
                    f"{assignee_user.display_name} cannot be assigned to this category based on CS settings."
                )

    if create_sales_lead and sales_lead_owner_id_raw:
        try:
            sales_lead_owner = db.session.get(User, int(sales_lead_owner_id_raw))
        except (TypeError, ValueError):
            sales_lead_owner = None
        if (
            not sales_lead_owner
            or not sales_lead_owner.is_active
            or not sales_lead_owner.can_view_module("sales")
        ):
            errors.append("Select a valid sales owner for the new enquiry.")

    if errors:
        form_values.update(
            {
                "customer": customer,
                "subject": subject,
                "category": category_id,
                "amc_site": amc_site_id,
                "channel": channel_value,
                "sla_priority": sla_priority_id,
                "assignee": assignee_value,
                "owner": owner_value,
                "remarks": remarks,
                "due_datetime": due_raw,
                "contact_name": contact_name,
                "contact_phone": contact_phone,
                "contact_email": contact_email,
                "location": location,
                "linked_project_id": linked_project_id_raw,
                "linked_customer_id": linked_customer_id_raw,
                "linked_sales_client_id": linked_sales_client_id_raw,
                "linked_lift_id": linked_lift_id_raw,
                "create_sales_lead": "1" if create_sales_lead else "",
                "sales_lead_owner_id": sales_lead_owner_id_raw,
            }
        )
        return {
            "errors": errors,
            "form_values": form_values,
        }

    ticket_id = _generate_customer_support_ticket_id()
    created_at = datetime.datetime.utcnow()
    actor_info = timeline_actor_context()

    timeline_detail_parts = []
    if channel_label:
        timeline_detail_parts.append(f"Channel: {channel_label}")
    if location:
        timeline_detail_parts.append(f"Location: {location}")
    if amc_site_record:
        timeline_detail_parts.append(f"AMC site: {amc_site_record.get('label')}")
    if subject:
        timeline_detail_parts.append(subject)
    if remarks:
        timeline_detail_parts.append(remarks)
    timeline_detail = " · ".join(part for part in timeline_detail_parts if part)

    attachments_added = _save_customer_support_attachments(uploaded_files)

    ticket_url = url_for("customer_support_tasks", ticket=ticket_id, _external=True)
    comment_message = f"[{ticket_id}]({ticket_url})"

    linked_entities = []
    if linked_sales_client:
        name = (
            linked_sales_client.display_name
            or linked_sales_client.company_name
            or linked_sales_client.description
            or f"Client {linked_sales_client.id}"
        )
        entity = {
            "type": "sales_client",
            "label": "Sales client",
            "name": name,
            "url": url_for("sales_client_detail", client_id=linked_sales_client.id),
        }
        if linked_sales_client.company_name and linked_sales_client.company_name != name:
            entity["description"] = linked_sales_client.company_name
        linked_entities.append(entity)

    if linked_project:
        project_name = linked_project.name or f"Project {linked_project.id}"
        entity = {
            "type": "installation_project",
            "label": "Installation project",
            "name": project_name,
            "url": url_for("project_detail", project_id=linked_project.id),
        }
        if linked_project.customer_name:
            entity["description"] = linked_project.customer_name
        linked_entities.append(entity)

    if linked_customer:
        customer_name = (
            linked_customer.company_name
            or linked_customer.customer_code
            or f"Customer {linked_customer.id}"
        )
        entity = {
            "type": "amc_customer",
            "label": "AMC customer",
            "name": customer_name,
            "url": url_for("service_customer_detail", customer_id=linked_customer.id),
        }
        if linked_customer.customer_code:
            entity["description"] = linked_customer.customer_code
        linked_entities.append(entity)

    if linked_lift:
        lift_name = linked_lift.lift_code or f"Lift {linked_lift.id}"
        entity = {
            "type": "lift",
            "label": "Lift",
            "name": lift_name,
            "url": url_for("service_lift_detail", lift_id=linked_lift.id),
        }
        lift_details = []
        if linked_lift.customer and linked_lift.customer.company_name:
            lift_details.append(linked_lift.customer.company_name)
        elif linked_lift.customer_code:
            lift_details.append(linked_lift.customer_code)
        if linked_lift.city:
            lift_details.append(linked_lift.city)
        if lift_details:
            entity["description"] = " · ".join(lift_details)
        linked_entities.append(entity)

    created_opportunity = None
    created_call_activity = None
    created_sales_task = None
    resolved_sales_client = None
    if create_sales_lead and category_id.lower() == "sales-ni":
        resolved_sales_client, _ = _get_or_create_sales_client_for_ticket(
            ticket_id=ticket_id,
            customer_name=customer,
            phone=contact_phone,
            email=contact_email,
            location=location,
            owner_user=sales_lead_owner,
        )
        if not customer and resolved_sales_client:
            customer = resolved_sales_client.display_name
        if resolved_sales_client and not linked_sales_client:
            linked_sales_client = resolved_sales_client
        if resolved_sales_client and not any(
            entity.get("type") == "sales_client" for entity in linked_entities
        ):
            linked_entities.append(
                {
                    "type": "sales_client",
                    "label": "Sales client",
                    "name": resolved_sales_client.display_name,
                    "url": url_for(
                        "sales_client_detail", client_id=resolved_sales_client.id
                    ),
                }
            )
    sales_lead_pipeline_map = {"sales-ni": "lift", "sales-amc": "amc"}
    if create_sales_lead and category_id.lower() in sales_lead_pipeline_map:
        pipeline_key = sales_lead_pipeline_map[category_id.lower()]
        pipeline_config = get_pipeline_config(pipeline_key)
        stages = pipeline_config.get("stages", []) if isinstance(pipeline_config, dict) else []
        lead_stage = stages[0] if stages else "New Enquiry"

        lead_title = subject or customer or f"Ticket {ticket_id}"
        created_opportunity = SalesOpportunity(
            title=lead_title,
            pipeline=pipeline_key,
            stage=lead_stage,
            description=remarks or None,
        )
        created_opportunity.owner = sales_lead_owner or (current_user if current_user.is_authenticated else None)
        if linked_sales_client:
            created_opportunity.client = linked_sales_client
        elif resolved_sales_client:
            created_opportunity.client = resolved_sales_client

        db.session.add(created_opportunity)
        db.session.flush()
        log_sales_activity(
            "opportunity",
            created_opportunity.id,
            f"Sales enquiry created from support ticket {ticket_id}",
        )
        today = datetime.datetime.utcnow().date()
        created_call_activity = SalesOpportunityEngagement(
            opportunity=created_opportunity,
            activity_type="call",
            subject=f"New Enquiry Call: {lead_title}",
            scheduled_for=datetime.datetime.combine(today, datetime.time()),
            created_by=current_user if current_user.is_authenticated else None,
        )
        db.session.add(created_call_activity)
        creator_user = current_user if current_user.is_authenticated else None
        task_assignees = []
        if sales_lead_owner:
            task_assignees.append(sales_lead_owner)
        if creator_user and creator_user not in task_assignees:
            task_assignees.append(creator_user)

        created_sales_task = SalesTask(
            title=created_call_activity.subject,
            category="call",
            due_date=created_call_activity.scheduled_for.date()
            if created_call_activity.scheduled_for
            else today,
            description=f"New enquiry call created from support ticket {ticket_id}.",
            related_type="opportunity",
            opportunity=created_opportunity,
            owner=creator_user or sales_lead_owner,
            assignee=task_assignees[0] if task_assignees else None,
            assignees=task_assignees,
            creator=creator_user,
        )
        db.session.add(created_sales_task)
        db.session.flush()
        log_sales_activity(
            "opportunity",
            created_opportunity.id,
            "Call scheduled for today",
            notes=f"New enquiry call created from support ticket {ticket_id}.",
        )
        linked_entities.append(
            {
                "type": "sales_opportunity",
                "label": "Sales enquiry",
                "name": lead_title,
                "url": url_for(
                    "sales_opportunity_detail", opportunity_id=created_opportunity.id
                ),
            }
        )

    ticket_record = {
        "id": ticket_id,
        "subject": subject,
        "customer": customer,
        "contact_name": contact_name or "",
        "contact_phone": contact_phone or "",
        "contact_email": contact_email or "",
        "category": category_label or category_id,
        "category_key": category_id.lower(),
        "channel": channel_label or channel_value,
        "priority": "Medium",
        "status": "Open",
        "owner": owner_user.display_name
        if owner_user
        else (current_user.display_name if current_user.is_authenticated else "Unassigned"),
        "owner_user_id": owner_user.id
        if owner_user
        else (current_user.id if current_user.is_authenticated else None),
        "assignee": assignee_user.display_name if assignee_user else "Unassigned",
        "assignee_user_id": assignee_user.id if assignee_user else None,
        "created_at": created_at,
        "updated_at": created_at,
        "sla": {
            "first_response_hours": sla_preset.get("first_response_hours", 0) if sla_preset else 0,
            "resolution_hours": sla_preset.get("resolution_hours", 0) if sla_preset else 0,
        },
        "attachments": attachments_added,
        "timeline": [
            {
                "timestamp": created_at,
                "type": "status",
                "label": "Ticket logged",
                "visibility": "external",
                "detail": timeline_detail or "Ticket created manually.",
                **actor_info,
            }
        ],
        "linked_tasks": [],
    }

    if location:
        ticket_record["location"] = location
    if due_at:
        ticket_record["due_at"] = due_at
    if remarks:
        ticket_record["remarks"] = remarks
    if amc_site_record:
        ticket_record["amc_site"] = {
            "id": amc_site_record.get("id"),
            "label": amc_site_record.get("label"),
            "client": amc_site_record.get("client"),
        }
        if amc_site_record.get("customer_name"):
            ticket_record["amc_site"]["customer_name"] = amc_site_record.get("customer_name")
        if amc_site_record.get("customer_code"):
            ticket_record["amc_site"]["customer_code"] = amc_site_record.get("customer_code")
        if amc_site_record.get("amc_status"):
            ticket_record["amc_site"]["amc_status"] = amc_site_record.get("amc_status")

    if linked_entities:
        ticket_record["linked_entities"] = linked_entities
        for entity in linked_entities:
            ticket_record[f"linked_{entity['type']}"] = entity

    if created_opportunity:
        ticket_record["linked_sales_opportunity"] = {
            "id": created_opportunity.id,
            "title": created_opportunity.title,
            "url": url_for(
                "sales_opportunity_detail", opportunity_id=created_opportunity.id
            ),
        }
    if created_sales_task:
        ticket_record["linked_tasks"].append(
            {
                "id": created_sales_task.id,
                "title": created_sales_task.title,
                "owner": created_sales_task.owner_display,
                "owner_id": created_sales_task.owner_id,
                "assignee": created_sales_task.assignee_display,
                "assignee_id": created_sales_task.assignees[0].id
                if created_sales_task.assignees
                else created_sales_task.assignee_id,
                "assignees": created_sales_task.assignee_display_list,
                "assignee_ids": [
                    user.id for user in created_sales_task.assignees if getattr(user, "id", None)
                ],
                "related_type": created_sales_task.related_type,
                "status": created_sales_task.status or "Pending",
                "due_date": created_sales_task.due_date,
                "details": created_sales_task.description,
                "category": "Sales follow-up",
                "priority": "Medium",
                "created_at": created_sales_task.created_at,
                "url": url_for(
                    "sales_opportunity_detail", opportunity_id=created_opportunity.id
                ),
            }
        )

    comments_added = False
    if linked_sales_client:
        log_sales_activity(
            "client",
            linked_sales_client.id,
            f"Support ticket {ticket_id} linked",
            notes=comment_message,
            actor=current_user if current_user.is_authenticated else None,
        )
        comments_added = True

    if linked_project:
        db.session.add(
            ProjectComment(
                project=linked_project,
                body=comment_message,
                author=current_user if current_user.is_authenticated else None,
            )
        )
        comments_added = True

    if linked_customer:
        db.session.add(
            CustomerComment(
                customer=linked_customer,
                body=comment_message,
                author=current_user if current_user.is_authenticated else None,
            )
        )
        comments_added = True

    if linked_lift:
        db.session.add(
            LiftComment(
                lift=linked_lift,
                body=comment_message,
                author=current_user if current_user.is_authenticated else None,
            )
        )
        comments_added = True

    if created_opportunity or comments_added:
        db.session.commit()

    CUSTOMER_SUPPORT_TICKETS.append(ticket_record)
    try:
        _create_service_visit_from_support_ticket(ticket_record)
    except Exception as exc:
        app.logger.exception("Error creating service visit from support ticket: %s", exc)

    if any(isinstance(obj, Lift) for obj in db.session.dirty):
        db.session.commit()
    _save_customer_support_state()
    if created_opportunity:
        flash("Sales enquiry created in the sales pipeline.", "success")
    flash(f"Ticket {ticket_id} created successfully.", "success")
    return redirect(url_for("customer_support_tasks", ticket=ticket_id))


def _normalise_srt_schema(raw_schema):
    if not isinstance(raw_schema, list):
        return _default_srt_schema()

    normalised_sections = []
    for raw_section in raw_schema:
        if not isinstance(raw_section, dict):
            continue

        section_name = str(raw_section.get("section", "") or "")
        section_image = str(raw_section.get("display_image", "") or "")
        raw_items = raw_section.get("items")
        normalised_items = []

        if isinstance(raw_items, list):
            for raw_item in raw_items:
                if not isinstance(raw_item, dict):
                    continue

                item_type = str(raw_item.get("type", "select") or "select").lower()
                if item_type == "table":
                    rows = [
                        str(value).strip()
                        for value in raw_item.get("rows", [])
                        if str(value).strip()
                    ]
                    columns = [
                        str(value).strip()
                        for value in raw_item.get("columns", [])
                        if str(value).strip()
                    ]
                    normalised_items.append(
                        {
                            "label": str(raw_item.get("label", "") or ""),
                            "type": "table",
                            "required": bool(raw_item.get("required", False)),
                            "rows": rows or ["Row 1", "Row 2"],
                            "columns": columns or ["Column 1", "Column 2"],
                            "display_image": str(raw_item.get("display_image", "") or ""),
                        }
                    )
                    continue

                allowed_types = {"select", "text", "textarea"}
                if item_type not in allowed_types:
                    item_type = "select"

                if item_type == "select":
                    options = [
                        str(value).strip()
                        for value in raw_item.get("options", [])
                        if str(value).strip()
                    ] or ["OK", "Not OK", "Need Client Input"]
                else:
                    options = []

                allow_photo = bool(raw_item.get("allow_photo", item_type == "select"))
                photo_required = bool(raw_item.get("photo_required_if_ng", False))
                if not allow_photo or item_type != "select":
                    photo_required = False

                normalised_items.append(
                    {
                        "label": str(raw_item.get("label", "") or ""),
                        "type": item_type,
                        "options": options,
                        "required": bool(raw_item.get("required", item_type == "select")),
                        "allow_photo": allow_photo,
                        "allow_remark": bool(raw_item.get("allow_remark", item_type != "text")),
                        "photo_required_if_ng": photo_required,
                        "display_image": str(raw_item.get("display_image", "") or ""),
                    }
                )

        if not normalised_items:
            normalised_items = [_default_srt_item()]

        normalised_sections.append(
            {
                "section": section_name,
                "display_image": section_image,
                "items": normalised_items,
            }
        )

    if not normalised_sections:
        return _default_srt_schema()

    return normalised_sections


_SRT_FORM_TEMPLATES_SEED = [
    {
        "id": "srt-emergency-brake-audit",
        "name": "SRT - Emergency Brake Audit",
        "category": "Safety",
        "last_updated": datetime.date(2024, 4, 28),
        "usage_count": 14,
        "description": "Checklist capturing emergency brake checks, load test confirmation and evidence uploads.",
        "schema": [
            {
                "section": "Emergency Brake Assembly",
                "display_image": "/static/uploads/1761394043.501005_SAVE_20230822_183825.jpg",
                "items": [
                    {
                        "label": "Brake calipers inspected for wear",
                        "type": "select",
                        "options": ["OK", "Not OK", "Need Client Input"],
                        "required": True,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": True,
                        "display_image": "/static/uploads/1761394043.510924_SAVE_20230822_1837491.jpg",
                    },
                    {
                        "label": "Counterweight gap measurement (mm)",
                        "type": "text",
                        "options": [],
                        "required": True,
                        "allow_photo": False,
                        "allow_remark": False,
                        "photo_required_if_ng": False,
                        "display_image": "",
                    },
                    {
                        "label": "Load test observation notes",
                        "type": "textarea",
                        "options": [],
                        "required": False,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": False,
                        "display_image": "",
                    },
                ],
            },
            {
                "section": "Test Documentation",
                "display_image": "",
                "items": [
                    {
                        "label": "Brake torque verification table",
                        "type": "table",
                        "required": True,
                        "rows": ["Test 1", "Test 2", "Test 3"],
                        "columns": ["Recorded", "Expected", "Variance"],
                        "display_image": "/static/uploads/1761394043.506364_SAVE_20230822_183832.jpg",
                    }
                ],
            },
        ],
    },
    {
        "id": "srt-door-operation-review",
        "name": "SRT - Door Operation Review",
        "category": "Doors",
        "last_updated": datetime.date(2024, 5, 9),
        "usage_count": 9,
        "description": "Structured walk-through for door alignment, interlocks and threshold compliance.",
        "schema": [
            {
                "section": "Door Movement",
                "display_image": "",
                "items": [
                    {
                        "label": "Door closing speed within spec",
                        "type": "select",
                        "options": ["OK", "Not OK", "Need Client Input"],
                        "required": True,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": True,
                        "display_image": "",
                    },
                    {
                        "label": "Sill alignment reference",
                        "type": "textarea",
                        "options": [],
                        "required": False,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": False,
                        "display_image": "/static/uploads/1761394043.501005_SAVE_20230822_183825.jpg",
                    },
                ],
            },
            {
                "section": "Interlock Compliance",
                "display_image": "",
                "items": [
                    {
                        "label": "Landing door interlocks",
                        "type": "select",
                        "options": ["OK", "Not OK", "Need Client Input"],
                        "required": True,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": True,
                        "display_image": "",
                    },
                    {
                        "label": "Interlock wiring continuity",
                        "type": "text",
                        "options": [],
                        "required": False,
                        "allow_photo": False,
                        "allow_remark": False,
                        "photo_required_if_ng": False,
                        "display_image": "",
                    },
                ],
            },
        ],
    },
    {
        "id": "srt-post-service-summary",
        "name": "SRT - Post Service Summary",
        "category": "Reporting",
        "last_updated": datetime.date(2024, 3, 19),
        "usage_count": 22,
        "description": "Captures punch-list closure status, photos and pending parts for handover.",
        "schema": [
            {
                "section": "Punch List",
                "display_image": "",
                "items": [
                    {
                        "label": "Outstanding issues",
                        "type": "textarea",
                        "options": [],
                        "required": False,
                        "allow_photo": True,
                        "allow_remark": True,
                        "photo_required_if_ng": False,
                        "display_image": "",
                    },
                    {
                        "label": "Pending parts arrival date",
                        "type": "text",
                        "options": [],
                        "required": False,
                        "allow_photo": False,
                        "allow_remark": False,
                        "photo_required_if_ng": False,
                        "display_image": "",
                    },
                ],
            },
            {
                "section": "Hand-over Evidence",
                "display_image": "/static/uploads/1761394043.506364_SAVE_20230822_183832.jpg",
                "items": [
                    {
                        "label": "Client sign-off table",
                        "type": "table",
                        "required": True,
                        "rows": ["Client", "Technician", "Supervisor"],
                        "columns": ["Name", "Signature", "Date"],
                        "display_image": "",
                    }
                ],
            },
        ],
    },
]


SRT_FORM_TEMPLATES_FILE = os.path.join(BASE_DIR, "instance", "srt_form_templates.json")


def _seed_default_srt_form_templates():
    return copy.deepcopy(_SRT_FORM_TEMPLATES_SEED)


def _coerce_positive_int(value, default=0):
    try:
        parsed = int(value)
    except (TypeError, ValueError):
        return default
    return parsed if parsed >= 0 else default


def _parse_srt_template_date(value, default=None):
    if isinstance(value, datetime.date):
        return value

    if isinstance(value, str):
        value = value.strip()
        if not value:
            return default
        for fmt in ("%Y-%m-%d", "%d %b %Y", "%d %B %Y"):
            try:
                return datetime.datetime.strptime(value, fmt).date()
            except ValueError:
                continue

    return default


def _load_srt_form_templates():
    if os.path.exists(SRT_FORM_TEMPLATES_FILE):
        try:
            with open(SRT_FORM_TEMPLATES_FILE, "r", encoding="utf-8") as handle:
                raw_templates = json.load(handle)
        except (OSError, json.JSONDecodeError, TypeError) as exc:
            app.logger.warning("Failed to load SRT templates from disk: %s", exc)
            raw_templates = []
        templates_loaded = []
        for raw in raw_templates:
            if not isinstance(raw, dict):
                continue

            name = str(raw.get("name", "") or "").strip()
            template_id = str(raw.get("id", "") or "").strip()
            if not template_id:
                template_id = slugify(name or f"srt-template-{_random_digits(4)}")

            last_updated = _parse_srt_template_date(
                raw.get("last_updated"), default=datetime.date.today()
            )

            schema_payload = raw.get("schema")
            schema = copy.deepcopy(_normalise_srt_schema(schema_payload))

            templates_loaded.append(
                {
                    "id": template_id,
                    "name": name or "Untitled template",
                    "category": str(raw.get("category", "") or "General").strip() or "General",
                    "description": str(raw.get("description", "") or ""),
                    "usage_count": _coerce_positive_int(raw.get("usage_count"), 0),
                    "last_updated": last_updated or datetime.date.today(),
                    "schema": schema,
                }
            )

        if templates_loaded:
            templates_loaded.sort(key=lambda item: item["name"].lower())
            return templates_loaded

    return _seed_default_srt_form_templates()


def _persist_srt_form_templates():
    payload = []
    for template in SRT_FORM_TEMPLATES:
        record = {
            "id": template.get("id") or slugify(template.get("name") or "srt-template"),
            "name": template.get("name", ""),
            "category": template.get("category", "General"),
            "description": template.get("description", ""),
            "usage_count": _coerce_positive_int(template.get("usage_count"), 0),
            "last_updated": "",
            "schema": copy.deepcopy(template.get("schema") or _default_srt_schema()),
        }

        last_updated = template.get("last_updated")
        if isinstance(last_updated, datetime.date):
            record["last_updated"] = last_updated.isoformat()
        elif isinstance(last_updated, str):
            record["last_updated"] = last_updated
        else:
            record["last_updated"] = datetime.date.today().isoformat()

        payload.append(record)

    try:
        with open(SRT_FORM_TEMPLATES_FILE, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, ensure_ascii=False, indent=2)
    except OSError as exc:
        app.logger.error("Failed to persist SRT templates: %s", exc)


SRT_FORM_TEMPLATES = _load_srt_form_templates()

SRT_TEAM_MEMBERS = [
    "Ravi Kumar",
    "Priya Nair",
    "Amol Patil",
    "Sneha Kulkarni",
    "Anita D'silva",
    "Rahul Menezes",
]


SRT_SITES = []

SALES_PIPELINES = {
    "lift": {
        "label": "Lift",
        "stages": [
            "New Enquiry",
            "Site Visit",
            "Quote Submission",
            "Negotiation",
            "Closed Won",
            "Closed Lost",
        ],
    },
    "amc": {
        "label": "AMC",
        "stages": [
            "New AMC Enquiry",
            "Technician Visit",
            "Quote Submission",
            "Negotiation",
            "Closed Won",
            "Closed Lost",
        ],
    },
    "parking": {
        "label": "Parking System",
        "stages": [
            "New Parking Enquiry",
            "Site Assessment",
            "Proposal Shared",
            "Negotiation",
            "Closed Won",
            "Closed Lost",
        ],
    },
}

SALES_TEMPERATURES = [
    ("cold", "Cold"),
    ("warm", "Warm"),
    ("hot", "Hot"),
]

SALES_CLIENT_LIFECYCLE_STAGES = [
    "Prospect",
    "Qualification",
    "Negotiation",
    "Customer",
    "Post-Sales",
]

SALES_CLIENT_TEMPLATE_SHEET_NAME = "Clients"
SALES_CLIENT_UPLOAD_HEADERS = [
    "Display Name",
    "Company Name",
    "Email",
    "Phone",
    "Email Opt Out",
    "Tag",
    "Category",
    "Owner Email",
    "Lifecycle Stage",
    "Description",
]

SALES_TASK_CATEGORIES = [
    ("task", "Task"),
    ("activity", "Activity"),
    ("reminder", "Reminder"),
    ("call", "Call"),
    ("event", "Event"),
]

SALES_TASK_CATEGORY_LABELS = {value: label for value, label in SALES_TASK_CATEGORIES}

SALES_OPPORTUNITY_TEMPLATE_SHEET_NAME = "Opportunities"
SALES_OPPORTUNITY_UPLOAD_HEADERS = [
    "Title",
    "Pipeline",
    "Stage",
    "Status",
    "Temperature",
    "Amount",
    "Currency",
    "Expected Close Date",
    "Probability",
    "Owner Email",
    "Client Name",
    "Related Project",
    "Description",
]

OPPORTUNITY_REMINDER_OPTIONS = [
    ("", "No reminder"),
    ("1h", "1 Hr before due"),
    ("2h", "2 Hr before due"),
    ("3h", "3 Hr before due"),
    ("1d", "1 Day before due"),
]

REMINDER_OPTION_LABELS = {value: label for value, label in OPPORTUNITY_REMINDER_OPTIONS}
OPPORTUNITY_REMINDER_VALUES = {value for value, _ in OPPORTUNITY_REMINDER_OPTIONS}

OPPORTUNITY_ACTIVITY_LABELS = {
    "meeting": "Meeting",
    "call": "Call",
    "email": "Email",
    "whatsapp": "WhatsApp",
    "site_visit": "Site Visit",
    "callback": "Callback",
}
OPPORTUNITY_ACTIVITY_TYPES = set(OPPORTUNITY_ACTIVITY_LABELS.keys())

OPPORTUNITY_ACTIVITY_OUTCOMES = [
    ("connected", "Connected"),
    ("not_reachable", "Not reachable"),
    ("callback_scheduled", "Callback scheduled"),
    ("meeting_fixed", "Meeting fixed"),
    ("site_visit_fixed", "Site visit fixed"),
    ("quotation_discussed", "Quotation discussed"),
    ("not_interested", "Not interested"),
    ("other", "Other"),
]


def format_file_size(num_bytes):
    if num_bytes is None:
        return "0 B"

    step = 1024.0
    units = ["B", "KB", "MB", "GB", "TB"]
    size = float(max(num_bytes, 0))
    for unit in units:
        if size < step or unit == units[-1]:
            return f"{size:.1f} {unit}" if unit != "B" else f"{int(size)} {unit}"
        size /= step


def get_pipeline_config(pipeline_key):
    key = (pipeline_key or "lift").lower()
    return SALES_PIPELINES.get(key, SALES_PIPELINES["lift"])


def get_pipeline_stages(pipeline_key):
    return get_pipeline_config(pipeline_key)["stages"]


def format_currency(amount, currency="₹"):
    if amount is None:
        return "—"
    return f"{currency or '₹'}{amount:,.2f}"


def _cleanup_empty_directories(start_path, stop_path):
    current = os.path.dirname(start_path)
    stop_path = os.path.abspath(stop_path)
    while True:
        current = os.path.abspath(current)
        if not current.startswith(stop_path) or current == stop_path:
            break
        try:
            os.rmdir(current)
        except OSError:
            break
        current = os.path.dirname(current)


def remove_static_file(relative_path):
    if not relative_path:
        return False

    static_root = os.path.join(BASE_DIR, "static")
    target_path = os.path.normpath(os.path.join(static_root, relative_path))
    if not target_path.startswith(os.path.abspath(static_root)):
        return False

    if not os.path.isfile(target_path):
        return False

    try:
        os.remove(target_path)
    except OSError:
        return False

    _cleanup_empty_directories(target_path, static_root)
    return True


def remove_static_directory(path):
    if not path:
        return False

    static_root = os.path.join(BASE_DIR, "static")
    target_path = os.path.abspath(path)
    if not target_path.startswith(os.path.abspath(static_root)):
        return False

    if not os.path.isdir(target_path):
        return False

    try:
        shutil.rmtree(target_path)
    except OSError:
        return False

    _cleanup_empty_directories(target_path, static_root)
    return True


def normalize_lifecycle_stage(value):
    value = (value or "").strip()
    if not value:
        return None
    if value not in SALES_CLIENT_LIFECYCLE_STAGES:
        return SALES_CLIENT_LIFECYCLE_STAGES[0]
    return value


def _normalize_client_name_key(value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    return " ".join(str(value).strip().split()).lower()


def _select_latest_match(matches, *, warn_label: str = ""):
    if not matches:
        return None
    matches = sorted(
        matches,
        key=lambda client: client.created_at or datetime.datetime.min,
        reverse=True,
    )
    if len(matches) > 1:
        app.logger.warning(
            "Multiple SalesClient matches found for %s; using the most recent entry.",
            warn_label or "criteria",
        )
    return matches[0]


def _match_sales_client(phone: str, email: str, name_key: Optional[str]):
    if phone:
        matches = (
            SalesClient.query.filter(func.lower(SalesClient.phone) == phone.lower())
            .order_by(SalesClient.created_at.desc())
            .all()
        )
        client = _select_latest_match(matches, warn_label=f"phone {phone}")
        if client:
            return client

    if email:
        matches = (
            SalesClient.query.filter(func.lower(SalesClient.email) == email.lower())
            .order_by(SalesClient.created_at.desc())
            .all()
        )
        client = _select_latest_match(matches, warn_label=f"email {email}")
        if client:
            return client

    if name_key:
        name_matches = []
        for candidate in SalesClient.query.options(
            load_only(
                SalesClient.id,
                SalesClient.display_name,
                SalesClient.email,
                SalesClient.phone,
                SalesClient.created_at,
            )
        ):
            candidate_name_key = _normalize_client_name_key(candidate.display_name)
            if candidate_name_key and candidate_name_key == name_key:
                name_matches.append(candidate)
        return _select_latest_match(name_matches, warn_label=f"name {name_key}")

    return None


def _get_or_create_sales_client_for_ticket(
    *,
    ticket_id: str,
    customer_name: Optional[str],
    phone: Optional[str],
    email: Optional[str],
    location: Optional[str],
    owner_user,
):
    name_key = _normalize_client_name_key(customer_name)
    phone_value = (phone or "").strip()
    email_value = (email or "").strip()

    matched_client = _match_sales_client(phone_value, email_value, name_key)
    if matched_client:
        return matched_client, False

    client_name = customer_name or f"Ticket {ticket_id} client"
    description_parts = [f"Auto-created from Sales - NI ticket #{ticket_id}"]
    if location:
        description_parts.append(f"Site: {location}")

    client = SalesClient(
        display_name=client_name.strip(),
        phone=phone_value or None,
        email=email_value or None,
        description="\n".join(description_parts),
        category="Individual",
    )
    client.owner = owner_user or (current_user if current_user.is_authenticated else None)
    db.session.add(client)
    db.session.flush()
    log_sales_activity(
        "client",
        client.id,
        f"Client auto-created from Sales - NI ticket {ticket_id}",
        actor=current_user if current_user.is_authenticated else None,
    )
    return client, True


def normalize_email_opt_out(value):
    if value is None:
        return None
    lowered = str(value).strip().lower()
    if not lowered:
        return None
    if lowered in {"yes", "true", "1", "y"}:
        return "Yes"
    if lowered in {"no", "false", "0", "n"}:
        return "No"
    return None


def parse_optional_int(value):
    try:
        if value is None:
            return None
        text_value = str(value).strip()
        if text_value == "":
            return None
        return int(text_value)
    except (TypeError, ValueError):
        return None


def delete_lift_record(lift, *, remove_from_session=True):
    if not lift:
        return

    for attachment in list(getattr(lift, "attachments", [])):
        remove_static_file(attachment.stored_path)

    remove_static_directory(
        os.path.join(BASE_DIR, app.config["UPLOAD_FOLDER"], "lifts", str(lift.id))
    )
    remove_static_directory(
        os.path.join(BASE_DIR, app.config["UPLOAD_FOLDER"], "service_slips", str(lift.id))
    )

    if remove_from_session:
        db.session.delete(lift)


def delete_sales_opportunity_record(opportunity, *, remove_from_session=True):
    if not opportunity:
        return

    for file_record in list(getattr(opportunity, "files", [])):
        remove_static_file(file_record.stored_path)

    remove_static_directory(
        os.path.join(BASE_DIR, app.config["UPLOAD_FOLDER"], "opportunities", str(opportunity.id))
    )

    if remove_from_session:
        db.session.delete(opportunity)


def format_service_date(value):
    if not value:
        return "—"
    if isinstance(value, datetime.datetime):
        value = value.date()
    return value.strftime("%d %b %Y")


def reset_workspace_data():
    summary = {}
    static_root = os.path.join(BASE_DIR, "static")

    def _cleanup_submission_files(raw_json):
        if not raw_json:
            return
        try:
            entries = json.loads(raw_json)
        except (TypeError, ValueError):
            entries = []
        if not isinstance(entries, list):
            return
        for stored_path in entries:
            if not stored_path or not isinstance(stored_path, str):
                continue
            normalized = stored_path.replace("\\", "/")
            if normalized.startswith("static/"):
                normalized = normalized[len("static/"):]
            removed = remove_static_file(normalized)
            if removed:
                continue
            candidate = normalized
            if not os.path.isabs(candidate):
                candidate = os.path.join(BASE_DIR, candidate)
            candidate = os.path.abspath(candidate)
            if not candidate.startswith(static_root):
                continue
            if not os.path.isfile(candidate):
                continue
            try:
                os.remove(candidate)
            except OSError:
                continue
            _cleanup_empty_directories(candidate, static_root)

    def _cleanup_comment_attachments(raw_json):
        if not raw_json:
            return
        try:
            entries = json.loads(raw_json)
        except (TypeError, ValueError):
            entries = []
        if not isinstance(entries, list):
            return
        for entry in entries:
            if not isinstance(entry, dict):
                continue
            path = entry.get("path") or entry.get("stored_path") or entry.get("web_path")
            if not path:
                continue
            normalized = str(path).replace("\\", "/")
            if normalized.startswith("static/"):
                normalized = normalized[len("static/"):]
            removed = remove_static_file(normalized)
            if removed:
                continue
            candidate = normalized
            if not os.path.isabs(candidate):
                candidate = os.path.join(BASE_DIR, candidate)
            candidate = os.path.abspath(candidate)
            if not candidate.startswith(static_root):
                continue
            if not os.path.isfile(candidate):
                continue
            try:
                os.remove(candidate)
            except OSError:
                continue
            _cleanup_empty_directories(candidate, static_root)

    lifts = (
        Lift.query.options(subqueryload(Lift.attachments)).all()
        if "Lift" in globals()
        else []
    )
    summary["lifts"] = len(lifts)
    for lift in lifts:
        delete_lift_record(lift, remove_from_session=False)

    if "LiftFile" in globals():
        db.session.query(LiftFile).delete(synchronize_session=False)
    if "LiftComment" in globals():
        db.session.query(LiftComment).delete(synchronize_session=False)
    if "Lift" in globals():
        db.session.query(Lift).delete(synchronize_session=False)

    customer_count = Customer.query.count() if "Customer" in globals() else 0
    summary["customers"] = customer_count
    if "CustomerComment" in globals():
        db.session.query(CustomerComment).delete(synchronize_session=False)
    if "Customer" in globals():
        db.session.query(Customer).delete(synchronize_session=False)

    submissions = Submission.query.all() if "Submission" in globals() else []
    summary["submissions"] = len(submissions)
    for submission in submissions:
        _cleanup_submission_files(getattr(submission, "photos_json", "[]"))
        _cleanup_submission_files(getattr(submission, "videos_json", "[]"))
    if summary["submissions"]:
        db.session.query(Submission).delete(synchronize_session=False)

    qc_task_count = 0
    if "QCWork" in globals():
        qc_task_count = QCWork.query.count()
        if "QCWorkComment" in globals():
            comments = QCWorkComment.query.all()
            for comment in comments:
                _cleanup_comment_attachments(getattr(comment, "attachments_json", "[]"))
            db.session.query(QCWorkComment).delete(synchronize_session=False)
        if "QCWorkLog" in globals():
            db.session.query(QCWorkLog).delete(synchronize_session=False)
        if "QCWorkDependency" in globals():
            db.session.query(QCWorkDependency).delete(synchronize_session=False)
        db.session.query(QCWork).delete(synchronize_session=False)
    summary["qc_tasks"] = qc_task_count

    project_count = Project.query.count() if "Project" in globals() else 0
    summary["projects"] = project_count
    if "ProjectComment" in globals():
        db.session.query(ProjectComment).delete(synchronize_session=False)
    if "Project" in globals():
        db.session.query(Project).delete(synchronize_session=False)

    opportunities = (
        SalesOpportunity.query.options(subqueryload(SalesOpportunity.files)).all()
        if "SalesOpportunity" in globals()
        else []
    )
    summary["opportunities"] = len(opportunities)
    for opportunity in opportunities:
        delete_sales_opportunity_record(opportunity, remove_from_session=False)

    if summary["opportunities"]:
        if "SalesOpportunityItem" in globals():
            db.session.query(SalesOpportunityItem).delete(synchronize_session=False)
        if "SalesOpportunityEngagement" in globals():
            db.session.query(SalesOpportunityEngagement).delete(synchronize_session=False)
        if "SalesOpportunityFile" in globals():
            db.session.query(SalesOpportunityFile).delete(synchronize_session=False)
        if "SalesOpportunityComment" in globals():
            db.session.query(SalesOpportunityComment).delete(synchronize_session=False)
        db.session.query(SalesOpportunity).delete(synchronize_session=False)

    client_count = SalesClient.query.count() if "SalesClient" in globals() else 0
    summary["sales_clients"] = client_count
    if "SalesClient" in globals():
        db.session.query(SalesClient).delete(synchronize_session=False)

    activities_deleted = (
        db.session.query(SalesActivity).delete(synchronize_session=False)
        if "SalesActivity" in globals()
        else 0
    )
    summary["sales_activities"] = activities_deleted or 0

    global SERVICE_COMPLAINTS, SERVICE_CONTRACTS, SERVICE_PARTS_LEDGER, SRT_SITES

    summary["service_complaints"] = len(SERVICE_COMPLAINTS)
    SERVICE_COMPLAINTS = []

    summary["service_contracts"] = len(SERVICE_CONTRACTS)
    SERVICE_CONTRACTS = []

    parts_removed = sum(len(SERVICE_PARTS_LEDGER.get(key, [])) for key in ("stock_alerts", "consumption", "returns"))
    summary["service_parts_entries"] = parts_removed
    SERVICE_PARTS_LEDGER = {"stock_alerts": [], "consumption": [], "returns": []}

    summary["srt_sites"] = len(SRT_SITES)
    SRT_SITES = []

    return summary


def format_duration_hours(value):
    if value is None:
        return "—"
    try:
        hours = float(value)
    except (TypeError, ValueError):
        return str(value)
    if hours.is_integer():
        return f"{int(hours)} hrs"
    return f"{hours:.1f} hrs"


def timeline_actor_context(actor_name=None, actor_role=None):
    name = (actor_name or "").strip()
    role = (actor_role or "").strip().lower()

    if not name:
        if current_user.is_authenticated:
            name = (
                current_user.display_name
                or current_user.email
                or current_user.username
                or "User"
            )
            role = role or ("admin" if current_user.is_admin else "user")
        else:
            name = "System"

    if not role:
        role = "system" if name.strip().lower() == "system" else "user"

    if role not in {"system", "admin", "user"}:
        role = "user"

    if role == "system":
        label = "System"
        normalized_name = "System"
    else:
        normalized_name = name or ("Admin" if role == "admin" else "User")
        role_label = "Admin" if role == "admin" else "User"
        label = f"{role_label} · {normalized_name}" if normalized_name else role_label

    return {
        "actor": normalized_name,
        "actor_role": role,
        "actor_label": label,
    }


def apply_actor_context(entry, actor_name=None, actor_role=None):
    payload = dict(entry or {})
    actor_fields = timeline_actor_context(
        actor_name or payload.get("actor"),
        actor_role or payload.get("actor_role"),
    )
    payload.update(actor_fields)
    return payload


app = create_app()
login_manager.login_view = "login"

from integrations.sarv.routes import sarv_bp

app.register_blueprint(sarv_bp)


@app.errorhandler(RequestEntityTooLarge)
def handle_large_upload(exc):
    limit_mb = round(app.config.get("MAX_CONTENT_LENGTH", DEFAULT_MAX_UPLOAD_SIZE) / (1024 * 1024))
    flash(
        f"Uploads are limited to {int(limit_mb)} MB. Please compress or split the file and retry.",
        "error",
    )
    return redirect(request.referrer or url_for("index")), 413


def is_lift_open(lift):
    status = (lift.status or "").strip().lower()
    return not status or status not in {"inactive", "scrapped", "decommissioned"}


def build_lift_payload(lift):
    insight_config = copy.deepcopy(DEFAULT_LIFT_INSIGHT)

    customer = lift.customer
    route_display = "—"
    if lift.route:
        route_value = lift.route.strip()
        route_record = None
        if route_value:
            route_record = ServiceRoute.query.filter(
                func.lower(ServiceRoute.state) == route_value.lower()
            ).first()
        if route_record:
            route_display = route_record.display_name
        elif route_value:
            route_display = route_value
    site_lines = []
    if insight_config.get("site_name"):
        site_lines.append(insight_config["site_name"])
    elif lift.site_address_line1:
        site_lines.append(lift.site_address_line1)
    elif customer and customer.company_name:
        site_lines.append(customer.company_name)

    if lift.site_address_line2:
        site_lines.append(lift.site_address_line2)

    if lift.building_villa_number:
        site_lines.insert(0, lift.building_villa_number)

    location_parts = [part for part in [lift.city, lift.state, lift.pincode] if part]
    if location_parts:
        site_lines.append(", ".join(location_parts))
    if lift.country:
        if not location_parts:
            site_lines.append(lift.country)
        else:
            last_line = site_lines[-1] if site_lines else ""
            if lift.country not in last_line:
                site_lines.append(lift.country)

    customer_lines = []
    if customer and customer.company_name:
        customer_lines.append(customer.company_name)
    contact_bits = []
    if customer and customer.contact_person:
        contact_bits.append(customer.contact_person)
    if customer and customer.mobile:
        contact_bits.append(customer.mobile)
    elif customer and customer.phone:
        contact_bits.append(customer.phone)
    if contact_bits:
        customer_lines.append(" · ".join(contact_bits))
    if customer and customer.email:
        customer_lines.append(customer.email)

    machine_details = insight_config.get("machine", {}) or {}
    machine_make = machine_details.get("make") or (lift.machine_brand or "—")
    machine_model = machine_details.get("model") or "—"
    machine_serial = machine_details.get("serial") or "—"

    lifetime_value = insight_config.get("lifetime_value", {}) or {}
    amc_config = insight_config.get("amc", {}) or {}
    total_breakdowns = lifetime_value.get("total_breakdowns_this_year", 0)
    average_response_value = (
        lifetime_value.get("average_call_response_time_hours")
        or lifetime_value.get("avg_call_response_time_hours")
        or lifetime_value.get("avg_response_time_hours")
    )
    if average_response_value is not None:
        average_response_display = format_duration_hours(average_response_value)
    else:
        average_response_raw = (
            lifetime_value.get("average_call_response_time")
            or lifetime_value.get("avg_call_response_time")
            or lifetime_value.get("average_response_time")
        )
        average_response_display = (
            format_duration_hours(average_response_raw)
            if average_response_raw not in (None, "")
            else "—"
        )

    average_close_value = (
        lifetime_value.get("average_call_close_time_hours")
        or lifetime_value.get("avg_call_close_time_hours")
        or lifetime_value.get("avg_close_time_hours")
    )
    if average_close_value is not None:
        average_close_display = format_duration_hours(average_close_value)
    else:
        average_close_raw = (
            lifetime_value.get("average_call_close_time")
            or lifetime_value.get("avg_call_close_time")
            or lifetime_value.get("average_close_time")
        )
        average_close_display = (
            format_duration_hours(average_close_raw)
            if average_close_raw not in (None, "")
            else "—"
        )

    repair_revenue_this_year = lifetime_value.get("repair_revenue_this_year")
    if repair_revenue_this_year is None:
        repair_revenue_this_year = lifetime_value.get("total_repair_revenue", 0)
    total_cost_this_year = lifetime_value.get("total_cost_this_year")
    if total_cost_this_year is None:
        total_cost_this_year = lifetime_value.get("total_cost", 0)

    months_to_renewal_value = (
        lifetime_value.get("months_to_renewal")
        if lifetime_value.get("months_to_renewal") not in (None, "")
        else lifetime_value.get("months_until_renewal")
    )

    amc_end_source = amc_config.get("end") or lift.amc_end
    amc_end_date = None
    if isinstance(amc_end_source, datetime.datetime):
        amc_end_date = amc_end_source.date()
    elif isinstance(amc_end_source, datetime.date):
        amc_end_date = amc_end_source
    elif isinstance(amc_end_source, str):
        for fmt in ("%Y-%m-%d", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%dT%H:%M:%S.%f", "%d %b %Y", "%d %B %Y"):
            try:
                amc_end_date = datetime.datetime.strptime(amc_end_source, fmt).date()
                break
            except ValueError:
                continue

    if months_to_renewal_value in (None, "") and amc_end_date:
        today = datetime.date.today()
        delta_months = (amc_end_date.year - today.year) * 12 + (amc_end_date.month - today.month)
        if amc_end_date.day < today.day:
            delta_months -= 1
        months_to_renewal_value = max(0, delta_months)

    if months_to_renewal_value in (None, ""):
        months_to_renewal_display = "—"
    else:
        try:
            months_to_renewal_display = str(int(float(months_to_renewal_value)))
        except (TypeError, ValueError):
            months_to_renewal_display = str(months_to_renewal_value)

    lifetime_metrics = [
        {
            "label": "Total breakdowns this year",
            "display": str(total_breakdowns),
        },
        {
            "label": "Average call response time",
            "display": average_response_display,
        },
        {
            "label": "Average call close time",
            "display": average_close_display,
        },
        {
            "label": "Repair revenue this year",
            "display": format_currency(repair_revenue_this_year or 0),
        },
        {
            "label": "Total cost this year",
            "display": format_currency(total_cost_this_year or 0),
        },
        {
            "label": "Months to next renewal",
            "display": months_to_renewal_display,
        },
    ]

    stored_metrics = lift.lifetime_metrics
    if stored_metrics:
        lifetime_metrics = [
            {
                "label": item.get("label", "Metric"),
                "display": item.get("display", "—"),
            }
            for item in stored_metrics
        ]

    amc_start = amc_config.get("start") or lift.amc_start
    amc_end = amc_config.get("end") or lift.amc_end
    linked_contract = get_service_contract_by_id(lift.amc_contract_id)

    preferred_day_keys = lift.preferred_service_days
    preferred_day_labels = []
    for day_key in preferred_day_keys:
        label = SERVICE_PREFERRED_DAY_LABELS.get(day_key)
        if not label:
            label = day_key.title()
        preferred_day_labels.append(label)
    preferred_day_display = ", ".join(preferred_day_labels) if preferred_day_labels else None
    preferred_date_display = format_preferred_service_date(lift.preferred_service_date)
    preferred_time_display = (
        lift.preferred_service_time.strftime("%H:%M")
        if isinstance(lift.preferred_service_time, datetime.time)
        else "—"
    )
    preference_bits = []
    if preferred_day_display:
        preference_bits.append(preferred_day_display)
    if lift.preferred_service_date:
        preference_bits.append(format_preferred_service_date(lift.preferred_service_date))
    elif lift.preferred_service_time and not preferred_day_display:
        preference_bits.append("Any date")
    if lift.preferred_service_time:
        preference_bits.append(lift.preferred_service_time.strftime("%H:%M"))
    preferred_summary = " · ".join(preference_bits)

    amc_payload = {
        "status": (lift.amc_status or amc_config.get("status") or "—"),
        "type": amc_config.get("type") or "—",
        "start_display": format_service_date(amc_start),
        "end_display": format_service_date(amc_end),
        "duration_display": AMC_DURATION_LABELS.get(lift.amc_duration_key) or "—",
        "contract_value_display": format_currency(amc_config.get("contract_value", 0)),
        "payment_terms": amc_config.get("payment_terms") or "—",
        "services_per_year": amc_config.get("services_per_year", 0),
        "pending_services_count": amc_config.get("pending_services_count", 0),
        "service_owner": amc_config.get("service_owner") or "—",
        "service_contact": amc_config.get("service_contact") or "—",
        "renewal_history": [
            {
                "period": item.get("period", "—"),
                "value_display": format_currency(item.get("value", 0)),
                "renewed_on_display": format_service_date(item.get("renewed_on")),
            }
            for item in amc_config.get("renewal_history", [])
        ],
        "attachments": [
            {
                "label": item.get("label", "Document"),
                "filename": item.get("filename"),
                "url": item.get("url") or "#",
            }
            for item in amc_config.get("attachments", [])
        ],
    }

    route_technician_label = (
        route_display if route_display and route_display != "—" else "Route technician"
    )

    schedule_source = lift.service_schedule or []
    service_schedule = []
    for item in schedule_source:
        if not isinstance(item, dict):
            continue
        raw_date = item.get("date")
        visit_date = None
        if isinstance(raw_date, datetime.datetime):
            visit_date = raw_date.date()
        elif isinstance(raw_date, datetime.date):
            visit_date = raw_date
        elif isinstance(raw_date, str):
            try:
                visit_date = datetime.datetime.strptime(raw_date, "%Y-%m-%d").date()
            except ValueError:
                visit_date = None
        date_display = format_service_date(visit_date)
        date_iso = visit_date.isoformat() if isinstance(visit_date, datetime.date) else ""
        route_raw = clean_str(item.get("route")) or clean_str(lift.route)
        route_display = route_raw or route_technician_label
        status_raw = clean_str(item.get("status"))
        status_key = (
            status_raw.lower()
            if status_raw and status_raw.lower() in SERVICE_VISIT_STATUS_LABELS
            else "scheduled"
        )
        status_display = SERVICE_VISIT_STATUS_LABELS.get(status_key, "Scheduled")
        slip_raw = clean_str(
            item.get("slip_url") or item.get("slip") or item.get("url") or item.get("href")
        )
        slip_label = clean_str(item.get("slip_label") or item.get("label"))
        slip_href = None
        if slip_raw:
            if slip_raw.lower().startswith(("http://", "https://")):
                slip_href = slip_raw
            elif slip_raw.startswith("/"):
                slip_href = slip_raw
            else:
                normalized = slip_raw.lstrip("/")
                if normalized.startswith("static/"):
                    normalized = normalized.split("static/", 1)[1]
                if normalized:
                    slip_href = url_for("static", filename=normalized)
        slip_display_label = (
            slip_label
            or (os.path.basename(slip_raw) if slip_raw else None)
            or "Service slip"
        )
        service_schedule.append(
            {
                "date": visit_date,
                "date_display": date_display,
                "date_iso": date_iso,
                "route_display": route_display,
                "route_value": route_raw or "",
                "status_key": status_key,
                "service_type": clean_str(item.get("service_type")),
                "service_type_display": SERVICE_TYPE_LABELS.get(clean_str(item.get("service_type")), "—"),
                "details_json": clean_str(item.get("details_json") or item.get("service_details")),
                "status_display": status_display,
                "slip_url": slip_href,
                "slip_label": slip_label,
                "slip_display_label": slip_display_label,
                "slip_stored": slip_raw,
                "has_slip": bool(slip_href),
                "allow_overdue": True,
                "complaint_summary": clean_str(item.get("complaint_summary")),
                "support_ticket_ref": item.get("support_ticket_ref"),
            }
        )

    service_schedule.sort(
        key=lambda entry: entry["date"] or datetime.date.max
    )

    contacts_source = lift.amc_contacts or amc_config.get("contacts", []) or []
    amc_contacts = []
    for contact in contacts_source:
        if not isinstance(contact, dict):
            continue
        amc_contacts.append(
            {
                "name": contact.get("name") or "—",
                "designation": contact.get("designation") or "—",
                "phone": contact.get("phone") or "—",
                "email": contact.get("email") or "—",
            }
        )
    if not amc_contacts and amc_payload["service_owner"] != "—":
        amc_contacts.append(
            {
                "name": amc_payload["service_owner"],
                "designation": "Service Owner",
                "phone": amc_payload["service_contact"],
                "email": "—",
            }
        )
    amc_payload["contacts"] = amc_contacts

    if linked_contract and linked_contract.get("id"):
        amc_payload["contract"] = {
            "id": linked_contract.get("id"),
            "type": linked_contract.get("type"),
            "coverage": linked_contract.get("coverage"),
            "url": url_for(
                "service_contracts",
                _anchor=f"contract-{linked_contract.get('id')}"
            ),
        }
    else:
        amc_payload["contract"] = None

    uploads_config = insight_config.get("uploads", {}) or {}
    documents = [
        {
            "label": item.get("label", "Document"),
            "filename": item.get("filename"),
            "description": item.get("description"),
            "updated_display": format_service_date(item.get("updated")),
            "url": item.get("url") or "#",
        }
        for item in uploads_config.get("documents", [])
    ]

    additional_uploads = []
    for bucket in ("media", "other"):
        for item in uploads_config.get(bucket, []) or []:
            additional_uploads.append(
                {
                    "label": item.get("label", "Attachment"),
                    "filename": item.get("filename"),
                    "description": item.get("description"),
                    "updated_display": format_service_date(item.get("updated")),
                    "url": item.get("url") or "#",
                }
            )

    stored_documents = []
    stored_other_uploads = []
    sorted_attachments = sorted(
        lift.attachments,
        key=lambda record: record.created_at or datetime.datetime.min,
        reverse=True,
    )
    for record in sorted_attachments:
        entry = {
            "label": record.display_label,
            "filename": record.original_filename,
            "description": record.description,
            "updated_display": record.uploaded_display,
            "url": url_for("static", filename=record.stored_path) if record.stored_path else "#",
            "uploaded_by": record.uploaded_by.display_name if record.uploaded_by else None,
            "size_display": record.display_size,
        }
        category = (record.category or "other").strip().lower()
        if category == "document":
            stored_documents.append(entry)
        else:
            stored_other_uploads.append(entry)

    def dedupe_uploads(items):
        seen = set()
        unique = []
        for item in items:
            key = (
                (item.get("label") or "").strip().lower(),
                (item.get("filename") or "").strip().lower(),
                item.get("url") or "",
            )
            if key in seen:
                continue
            unique.append(item)
            seen.add(key)
        return unique

    documents = dedupe_uploads(stored_documents + documents)
    additional_uploads = dedupe_uploads(stored_other_uploads + additional_uploads)

    breakdowns = [
        {
            "issue": item.get("issue", "—"),
            "technician": item.get("technician", "—"),
            "response": format_duration_hours(item.get("response_hours")),
            "resolution": format_duration_hours(item.get("resolution_hours")),
            "fault_type": item.get("fault_type", "—"),
            "spares": ", ".join(item.get("spares", []) or []) or "—",
            "status": item.get("status", "—"),
            "media": ", ".join(item.get("media", []) or []) or "—",
            "call_reference": item.get("call_reference", "—"),
        }
        for item in insight_config.get("breakdowns", [])
    ]

    summary_source = insight_config.get("breakdown_summary") or []
    breakdown_summary = []
    for item in summary_source:
        if not isinstance(item, dict):
            continue
        raw_date = item.get("date")
        summary_date = None
        if isinstance(raw_date, datetime.datetime):
            summary_date = raw_date.date()
        elif isinstance(raw_date, datetime.date):
            summary_date = raw_date
        elif isinstance(raw_date, str):
            try:
                summary_date = datetime.datetime.strptime(raw_date, "%Y-%m-%d").date()
            except ValueError:
                summary_date = None
        status_raw = clean_str(item.get("status"))
        status_key = clean_str(item.get("status_key")) or (
            status_raw.lower().replace(" ", "_") if status_raw else ""
        )
        breakdown_summary.append(
            {
                "date": summary_date,
                "date_display": format_service_date(summary_date),
                "date_iso": summary_date.isoformat() if isinstance(summary_date, datetime.date) else "",
                "type": item.get("type") or item.get("fault_type") or "—",
                "status": status_raw or "—",
                "status_key": status_key or "",
                "description": item.get("description")
                or item.get("detail")
                or "No additional details provided.",
                "call_reference": item.get("call_reference")
                or item.get("reference")
                or "—",
                "reported_by": item.get("reported_by")
                or item.get("reported_by_name")
                or item.get("reported_by_contact"),
            }
        )

    if breakdown_summary:
        breakdown_summary.sort(
            key=lambda entry: (
                entry.get("date") is None,
                entry.get("date") or datetime.date.min,
            ),
            reverse=True,
        )

    timeline_entries = []
    stored_timeline = lift.timeline_entries
    if stored_timeline:
        for item in stored_timeline:
            actor_info = apply_actor_context(item)
            timeline_entries.append(
                {
                    "date_display": format_service_date(item.get("date")),
                    "title": item.get("title", "—"),
                    "detail": item.get("detail", ""),
                    "category": item.get("category", "Update"),
                    "actor_label": actor_info.get("actor_label"),
                    "actor_role": actor_info.get("actor_role"),
                    "actor_name": actor_info.get("actor"),
                }
            )
    for item in insight_config.get("timeline", []) or []:
        actor_info = apply_actor_context(item)
        timeline_entries.append(
            {
                "date_display": format_service_date(item.get("date")),
                "title": item.get("title", "—"),
                "detail": item.get("detail", ""),
                "category": item.get("category", "Update"),
                "actor_label": actor_info.get("actor_label"),
                "actor_role": actor_info.get("actor_role"),
                "actor_name": actor_info.get("actor"),
            }
        )

    sorted_comments = sorted(
        lift.comments,
        key=lambda record: record.created_at or datetime.datetime.min,
        reverse=True,
    )

    machine_type_display = (
        lift.machine_type or insight_config.get("drive_type") or "—"
    )
    door_finish_display = (
        lift.door_finish or insight_config.get("door_finish") or "—"
    )
    cabin_finish_display = (
        lift.cabin_finish or insight_config.get("cabin_finish") or "—"
    )
    power_supply_display = (
        lift.power_supply or insight_config.get("power_supply") or "—"
    )
    machine_make_value = machine_make if machine_make != "—" else None
    machine_model_value = machine_model if machine_model != "—" else None
    machine_serial_value = machine_serial if machine_serial != "—" else None
    machine_details_parts = []
    if machine_make_value:
        machine_details_parts.append(machine_make_value)
    if machine_model_value:
        machine_details_parts.append(machine_model_value)
    if machine_serial_value:
        machine_details_parts.append(f"Serial {machine_serial_value}")
    machine_details_display = " · ".join(machine_details_parts) if machine_details_parts else "—"
    controller_type_value = insight_config.get("controller_type")
    controller_brand_value = lift.controller_brand
    controller_parts = []
    if controller_type_value:
        controller_parts.append(controller_type_value)
    if controller_brand_value:
        controller_parts.append(controller_brand_value)
    controller_display = " · ".join(controller_parts) if controller_parts else "—"

    payload = {
        "id": lift.id,
        "lift_code": lift.lift_code,
        "external_lift_id": lift.external_lift_id or "—",
        "customer_code": lift.customer_code or "—",
        "status": lift.status or "—",
        "site_lines": site_lines or ["—"],
        "customer_lines": customer_lines or ["—"],
        "site_summary": " · ".join(site_lines) if site_lines else "—",
        "customer_summary": " · ".join(customer_lines) if customer_lines else "—",
        "lift_type": lift.lift_type or "—",
        "lift_brand": lift.lift_brand or "—",
        "drive_type": machine_type_display,
        "machine_type": machine_type_display,
        "controller_type": controller_type_value or "—",
        "controller_brand": controller_brand_value or "—",
        "controller_display": controller_display,
        "door_type": lift.door_type or "—",
        "door_configuration": insight_config.get("door_configuration") or (lift.door_type or "—"),
        "floors_served": insight_config.get("floors_served") or (lift.building_floors or "—"),
        "route_display": route_display,
        "door_finish": door_finish_display,
        "cabin_finish": cabin_finish_display,
        "power_supply": power_supply_display,
        "site_address_line1": lift.site_address_line1 or "—",
        "site_address_line2": lift.site_address_line2 or "—",
        "city": lift.city or "—",
        "state": lift.state or "—",
        "pincode": lift.pincode or "—",
        "country": lift.country or "—",
        "capacity_display": lift.capacity_display or (f"{lift.capacity_persons} persons / {lift.capacity_kg} kg" if lift.capacity_persons and lift.capacity_kg else "—"),
        "speed_display": f"{lift.speed_mps:.2f} m/s" if lift.speed_mps is not None else "—",
        "machine_details_display": machine_details_display,
        "machine_make": machine_make,
        "machine_model": machine_model,
        "machine_serial": machine_serial,
        "machine_brand": lift.machine_brand or "—",
        "controller_brand": controller_brand_value or "—",
        "install_date_display": format_service_date(lift.install_date),
        "warranty_start_date_display": format_service_date(lift.warranty_start_date),
        "warranty_end_date_display": format_service_date(lift.warranty_end_date),
        "warranty_expiry_display": format_service_date(lift.warranty_expiry),
        "is_under_warranty": lift.is_under_warranty,
        "last_service_date_display": format_service_date(lift.last_service_date),
        "commissioned_date_display": format_service_date(insight_config.get("commissioned_date") or lift.install_date),
        "documents": documents,
        "other_uploads": additional_uploads,
        "amc": amc_payload,
        "breakdowns": breakdowns,
        "breakdown_summary": breakdown_summary,
        "timeline": timeline_entries,
        "lifetime_metrics": lifetime_metrics,
        "service_schedule": service_schedule,
        "remarks": lift.remarks or "—",
        "building_villa_number": lift.building_villa_number or "—",
        "preferred_service_day_display": preferred_day_display or "—",
        "preferred_service_date_display": preferred_date_display,
        "preferred_service_time_display": preferred_time_display,
        "preferred_service_summary": preferred_summary,
        "location_display": ", ".join(
            [part for part in [lift.city, lift.state, lift.pincode, lift.country] if part]
        )
        or "—",
        "geo_location": lift.geo_location or "—",
        "qr_code_url": lift.qr_code_url or None,
        "service_notes": lift.notes or "—",
        "comments": [
            {
                "body": comment.body,
                "author": comment.author_name,
                "created_display": comment.created_display,
            }
            for comment in sorted_comments
        ],
    }

    return payload


def log_sales_activity(parent_type, parent_id, title, notes=None, actor=None):
    entry = SalesActivity(
        parent_type=parent_type,
        parent_id=parent_id,
        actor=actor or (current_user if current_user.is_authenticated else None),
        title=title,
        notes=notes,
    )
    db.session.add(entry)
    return entry


def normalize_floor_label(raw_value):
    value = (raw_value or "").strip()
    if not value:
        return None

    compact = re.sub(r"\s+", "", value.upper())
    if compact in {"G", "G+"}:
        return None

    # If the value is purely numeric, prefix it with G+ for consistency.
    if re.fullmatch(r"\d+", compact):
        return f"G+{compact}"

    # Normalize leading G without a plus sign (e.g., G10 -> G+10).
    if compact.startswith("G") and not compact.startswith("G+"):
        compact = f"G+{compact[1:]}"

    # Ensure there is only a single + immediately after G when present.
    if compact.startswith("G+"):
        suffix = compact[2:]
        suffix = suffix.lstrip("+")
        compact = f"G+{suffix}" if suffix else "G+"

    if compact in {"", "G+"}:
        return None

    return compact


def _extract_task_timing(form):
    start_mode = (form.get("start_mode") or "immediate").strip().lower()
    if start_mode not in {"immediate", "scheduled", "after_previous"}:
        start_mode = "immediate"

    start_date_value = None
    start_date_raw = (form.get("start_date") or "").strip()
    if start_mode == "scheduled":
        if not start_date_raw:
            return None, None, None, None, "Provide a start date for scheduled tasks."
        try:
            start_date_value = datetime.datetime.strptime(start_date_raw, "%Y-%m-%d").date()
        except ValueError:
            return None, None, None, None, "Start date must be a valid YYYY-MM-DD date."
    elif start_mode == "after_previous":
        # Ignore any manually provided start date when using sequential scheduling.
        start_date_value = None
    elif start_date_raw:
        # Allow optionally overriding the start date even if immediate was chosen.
        try:
            start_date_value = datetime.datetime.strptime(start_date_raw, "%Y-%m-%d").date()
        except ValueError:
            return None, None, None, None, "Start date must be a valid YYYY-MM-DD date."

    duration_raw = (form.get("duration_days") or "").strip()
    duration_value = None
    if duration_raw:
        try:
            duration_value = int(duration_raw)
        except ValueError:
            return None, None, None, None, "Duration must be a whole number of days."
        if duration_value < 0:
            return None, None, None, None, "Duration must be zero or a positive number of days."

    milestone_value = (form.get("milestone") or "").strip() or None

    # If mode is immediate we ignore scheduled date (unless user typed one to override).
    if start_mode == "immediate" and start_date_raw == "":
        start_date_value = None

    return start_mode, start_date_value, duration_value, milestone_value, None


def normalize_template_task_order(template_id):
    tasks = ProjectTemplateTask.query.filter_by(template_id=template_id).order_by(
        ProjectTemplateTask.order_index.asc(),
        ProjectTemplateTask.id.asc()
    ).all()
    seen = set()
    needs_normalization = False
    for task in tasks:
        order_value = task.order_index
        if not order_value or order_value in seen:
            needs_normalization = True
            break
        seen.add(order_value)
    if not needs_normalization:
        return tasks
    for idx, task in enumerate(tasks, start=1):
        task.order_index = idx
    return tasks


def set_template_task_dependencies(task, dependency_ids):
    if not task:
        return
    cleaned = []
    for dep_id in dependency_ids or []:
        if not dep_id:
            continue
        if dep_id == task.id:
            continue
        if dep_id not in cleaned:
            cleaned.append(dep_id)
    task.depends_on_id = cleaned[0] if cleaned else None
    existing = {link.depends_on_id: link for link in getattr(task, "dependency_links", [])}
    for dep_id, link in list(existing.items()):
        if dep_id not in cleaned:
            db.session.delete(link)
    for dep_id in cleaned:
        if dep_id not in existing:
            db.session.add(ProjectTemplateTaskDependency(task_id=task.id, depends_on_id=dep_id))


def set_qc_work_dependencies(work, dependency_ids):
    if not work:
        return
    cleaned = []
    for dep_id in dependency_ids or []:
        if not dep_id:
            continue
        if dep_id == work.id:
            continue
        if dep_id not in cleaned:
            cleaned.append(dep_id)
    work.depends_on_id = cleaned[0] if cleaned else None
    existing = {link.depends_on_id: link for link in getattr(work, "dependency_links", [])}
    for dep_id, link in list(existing.items()):
        if dep_id not in cleaned:
            db.session.delete(link)
    for dep_id in cleaned:
        if dep_id not in existing:
            db.session.add(QCWorkDependency(task_id=work.id, depends_on_id=dep_id))


def set_project_task_dependencies(task, dependency_ids):
    if not task:
        return
    cleaned = []
    for dep_id in dependency_ids or []:
        if not dep_id:
            continue
        if dep_id == task.id:
            continue
        if dep_id not in cleaned:
            cleaned.append(dep_id)
    task.depends_on_id = cleaned[0] if cleaned else None
    existing = {link.depends_on_id: link for link in getattr(task, "dependency_links", [])}
    for dep_id, link in list(existing.items()):
        if dep_id not in cleaned:
            db.session.delete(link)
    for dep_id in cleaned:
        if dep_id not in existing:
            db.session.add(ProjectTaskDependency(task_id=task.id, depends_on_id=dep_id))


def synchronize_dependency_links():
    try:
        template_tasks = ProjectTemplateTask.query.filter(ProjectTemplateTask.depends_on_id.isnot(None)).all()
        for task in template_tasks:
            existing = {link.depends_on_id for link in getattr(task, "dependency_links", [])}
            if task.depends_on_id and task.depends_on_id not in existing:
                db.session.add(ProjectTemplateTaskDependency(task_id=task.id, depends_on_id=task.depends_on_id))

        qc_tasks = QCWork.query.filter(QCWork.depends_on_id.isnot(None)).all()
        for work in qc_tasks:
            existing = {link.depends_on_id for link in getattr(work, "dependency_links", [])}
            if work.depends_on_id and work.depends_on_id not in existing:
                db.session.add(QCWorkDependency(task_id=work.id, depends_on_id=work.depends_on_id))

        db.session.commit()
    except Exception as exc:
        db.session.rollback()
        print(f"⚠️ Unable to synchronize dependency links automatically: {exc}")


def build_task_template_blueprint(template):
    tasks = sorted(template.tasks, key=lambda t: ((t.order_index or 0), t.id))
    id_to_index = {task.id: idx for idx, task in enumerate(tasks)}
    blueprint = []
    for idx, task in enumerate(tasks):
        dependency_indexes = []
        for dep in task.dependencies:
            dep_index = id_to_index.get(dep.id)
            if dep_index is not None:
                dependency_indexes.append(dep_index)
        blueprint.append({
            "task_type": task.task_type or "general",
            "module": task.module or task.task_type or "general",
            "task_subtype": task.task_subtype or "general",
            "name": task.name,
            "description": task.description,
            "order_index": task.order_index or (idx + 1),
            "default_assignee_id": task.default_assignee_id,
            "form_template_id": task.form_template_id,
            "start_mode": task.start_mode or "immediate",
            "planned_start_date": task.planned_start_date.isoformat() if task.planned_start_date else None,
            "duration_days": task.duration_days,
            "milestone": task.milestone,
            "dependency_indexes": dependency_indexes,
        })
    return blueprint


def apply_blueprint_to_template(template, blueprint):
    if not isinstance(blueprint, list):
        return []
    created = []
    for idx, entry in enumerate(blueprint):
        if not isinstance(entry, dict):
            continue
        name = (entry.get("name") or f"Task {idx + 1}").strip()
        task_module = (entry.get("module") or entry.get("task_type") or "general").lower()
        if task_module not in dict(PROJECT_TEMPLATE_TASK_MODULES):
            task_module = "general"
        subtype_choices = dict(PROJECT_TEMPLATE_TASK_SUBTYPES.get(task_module, []))
        task_subtype = (entry.get("task_subtype") or "").lower()
        if task_subtype not in subtype_choices:
            task_subtype = next(iter(subtype_choices.keys()), "general")
        task_type = task_module
        description = (entry.get("description") or None)
        order_index = entry.get("order_index") or (idx + 1)
        default_assignee_id = entry.get("default_assignee_id")
        form_template_id = entry.get("form_template_id")
        start_mode = (entry.get("start_mode") or "immediate").lower()
        if start_mode not in {"immediate", "scheduled", "after_previous"}:
            start_mode = "immediate"
        planned_start = entry.get("planned_start_date")
        planned_start_date = None
        if planned_start:
            try:
                planned_start_date = datetime.datetime.strptime(planned_start, "%Y-%m-%d").date()
            except ValueError:
                planned_start_date = None
        duration_days = entry.get("duration_days")
        if isinstance(duration_days, str) and duration_days.isdigit():
            duration_days = int(duration_days)
        elif not isinstance(duration_days, int):
            duration_days = None
        milestone = entry.get("milestone") or None

        task = ProjectTemplateTask(
            template_id=template.id,
            task_type=task_type,
            module=task_module,
            task_subtype=task_subtype,
            name=name,
            description=description,
            order_index=order_index,
            default_assignee_id=default_assignee_id,
            form_template_id=form_template_id,
            start_mode=start_mode,
            planned_start_date=planned_start_date,
            duration_days=duration_days,
            milestone=milestone
        )
        db.session.add(task)
        db.session.flush()
        created.append((task, entry))

    for task, entry in created:
        dependency_indexes = entry.get("dependency_indexes") or []
        dependency_ids = []
        for dep_idx in dependency_indexes:
            if isinstance(dep_idx, int) and 0 <= dep_idx < len(created):
                dependency_ids.append(created[dep_idx][0].id)
        set_template_task_dependencies(task, dependency_ids)

    normalize_template_task_order(template.id)
    return [task for task, _ in created]
# -------------------------------------------------------------------------------


def _normalize_form_schema(schema_raw):
    """Return (sections, is_sectioned) for a stored form schema."""
    if not isinstance(schema_raw, list):
        return [], False

    def _normalize_item(item, idx):
        if not isinstance(item, dict):
            item = {}
        normalized = dict(item)
        normalized["label"] = str(item.get("label") or f"Item {idx + 1}")
        ftype = (item.get("type") or "select").lower()
        if ftype not in {"text", "textarea", "select", "table", "checkbox", "if_else"}:
            ftype = "select"
        normalized["type"] = ftype
        normalized["required"] = bool(item.get("required", False))
        if ftype in {"select", "checkbox", "if_else"}:
            default_opts = {
                "select": ["OK", "Not OK", "Need Client Input"],
                "checkbox": ["Option 1", "Option 2"],
                "if_else": ["If branch", "Else branch"],
            }
            opts = item.get("options") or default_opts.get(ftype, default_opts["select"])
            normalized["options"] = [str(opt) for opt in opts if str(opt).strip()]
            if not normalized["options"]:
                normalized["options"] = default_opts.get(ftype, default_opts["select"])
            normalized["photo_required_if_ng"] = bool(item.get("photo_required_if_ng", False)) if ftype == "select" else False
            normalized["allow_photo"] = bool(item.get("allow_photo", normalized["photo_required_if_ng"]))
            normalized["allow_remark"] = bool(item.get("allow_remark", False))
            normalized["reference_image"] = None
            normalized["rows"] = []
            normalized["columns"] = []
        elif ftype in {"text", "textarea"}:
            normalized["options"] = []
            normalized["photo_required_if_ng"] = False
            normalized["allow_photo"] = bool(item.get("allow_photo", False))
            normalized["allow_remark"] = bool(item.get("allow_remark", False))
            normalized["reference_image"] = None
            normalized["rows"] = []
            normalized["columns"] = []
        else:  # table
            rows = item.get("rows") or []
            cols = item.get("columns") or []
            if not isinstance(rows, list):
                rows = []
            if not isinstance(cols, list):
                cols = []
            normalized["rows"] = [str(r) for r in rows if str(r).strip()]
            normalized["columns"] = [str(c) for c in cols if str(c).strip()]
            if not normalized["rows"]:
                normalized["rows"] = ["Row 1", "Row 2"]
            if not normalized["columns"]:
                normalized["columns"] = ["Column 1", "Column 2"]
            ref_img = item.get("reference_image")
            normalized["reference_image"] = str(ref_img) if ref_img is not None else ""
            normalized["options"] = []
            normalized["photo_required_if_ng"] = False
            normalized["allow_photo"] = False
            normalized["allow_remark"] = False
        return normalized

    if schema_raw and isinstance(schema_raw[0], dict) and "section" in schema_raw[0]:
        sections = []
        for s_idx, section in enumerate(schema_raw):
            if not isinstance(section, dict):
                continue
            items = section.get("items") or []
            normalized_items = [_normalize_item(it, idx) for idx, it in enumerate(items)]
            sections.append({
                "section": section.get("section") or f"Section {s_idx + 1}",
                "items": normalized_items
            })
        return sections, True

    normalized_items = [_normalize_item(it, idx) for idx, it in enumerate(schema_raw)]
    return [{"section": "", "items": normalized_items}], False



from eleva_app import models
from eleva_app.models import (
    Customer,
    CustomerComment,
    Department,
    DropdownOption,
    FormSchema,
    FormTemplate,
    Lift,
    LiftComment,
    LiftFile,
    Position,
    Project,
    ProjectComment,
    ProjectTemplate,
    ProjectTemplateTask,
    ProjectTemplateTaskDependency,
    ProjectTask,
    ProjectTaskDependency,
    QCWork,
    QCWorkComment,
    QCWorkDependency,
    QCWorkLog,
    BillOfMaterials,
    BOMItem,
    BookInventory,
    BomTemplate,
    BomTemplateInput,
    BomTemplateLine,
    BomTemplateSection,
    BomTemplateStage,
    BOMPackage,
    BOMSpecChangeRequest,
    PartClass,
    DrawingComment,
    DrawingHistory,
    DrawingSite,
    DrawingStatusLog,
    DrawingVersion,
    DesignDrawing,
    DesignDrawingRevision,
    DesignTask,
    DesignTaskComment,
    SRTTask,
    CallLog,
    CallRecording,
    Notification,
    DeliveryChallan,
    DeliveryChallanItem,
    InventoryItem,
    InventoryStock,
    StockAdjustment,
    InventoryReceipt,
    InventoryReceiptItem,
    SalesActivity,
    SalesClient,
    SalesCompany,
    SalesOpportunity,
    SalesOpportunityComment,
    SalesOpportunityEngagement,
    SalesOpportunityFile,
    SalesOpportunityItem,
    SalesQuotationNegotiationLog,
    SalesQuotationRequest,
    SalesQuotationRequestItem,
    SalesTask,
    sales_task_assignees,
    ServiceDropdownOption,
    ServiceRoute,
    ServiceTask,
    DeliveryOrder,
    DeliveryOrderItem,
    Product,
    ProcurementStage,
    PurchaseOrderLine,
    VendorProductRate,
    VendorProductRateHistory,
    VendorContact,
    VendorIssue,
    VendorComplaint,
    Vendor,
    PurchaseOrder,
    PurchaseOrderItem,
    Submission,
    ClientRequirementForm,
    TaskTemplate,
    User,
    BOM_TYPE_CHOICES,
    BOM_TYPE_MAIN,
)

from eleva_app.uploads import (
    UploadOutcome,
    _build_pending_upload_path,
    _check_stage_timeout,
    _clear_pending_upload,
    _extract_tabular_upload,
    _extract_tabular_upload_from_path,
    _execute_with_timeout,
    cleanup_old_pending_uploads,
    process_customer_upload_file,
    process_lift_upload_file,
    save_pending_upload_file,
    UploadStageTimeoutError,
)
from eleva_app.drawing_history_import import (
    DrawingHistoryUploadResult,
    REQUIRED_HEADERS as DRAWING_REQUIRED_HEADERS,
    process_drawing_history_upload,
)



BOM_TYPE_LABELS = {
    "main": "Main",
    "fabrication": "Fabrication",
    "civil": "Civil",
    "supplementary": "Supplementary",
}


def _normalize_bom_type(value, *, default=BOM_TYPE_MAIN):
    candidate = clean_str(value).lower()
    if candidate in BOM_TYPE_CHOICES:
        return candidate
    return default


def _get_or_create_drawing_site_main_bom(site):
    main_bom = (
        BillOfMaterials.query.filter(
            BillOfMaterials.drawing_site_id == site.id,
            func.coalesce(BillOfMaterials.bom_type, BOM_TYPE_MAIN) == BOM_TYPE_MAIN,
        )
        .order_by(BillOfMaterials.created_at.asc().nullsfirst(), BillOfMaterials.id.asc())
        .first()
    )
    if main_bom:
        if not main_bom.bom_type:
            main_bom.bom_type = BOM_TYPE_MAIN
        return main_bom

    main_bom = BillOfMaterials(
        bom_name=f"Main BOM - {site.project_no or site.client_name or 'Site'}",
        bom_type=BOM_TYPE_MAIN,
        status="draft",
        drawing_site_id=site.id,
        project_id=site.project_id,
        created_by_user_id=(
            current_user.id
            if current_user and not getattr(current_user, "is_anonymous", False)
            else None
        ),
    )
    db.session.add(main_bom)
    db.session.flush()
    _get_or_create_default_bom_package(main_bom)
    return main_bom


def backup_org_structure():
    """Persist a lightweight backup of departments and positions to disk."""

    try:
        departments = Department.query.options(joinedload(Department.parent)).all()
        positions = Position.query.options(joinedload(Position.department), joinedload(Position.reports_to)).all()
    except Exception as exc:  # pragma: no cover - defensive guard for DB issues
        print(f"⚠️ Unable to read org structure for backup: {exc}")
        return False

    payload = {
        "departments": [
            {
                "name": dept.name,
                "branch": dept.branch,
                "description": dept.description,
                "active": bool(dept.active),
                "parent": dept.parent.name if dept.parent else None,
            }
            for dept in departments
        ],
        "positions": [
            {
                "title": pos.title,
                "department": pos.department.name if pos.department else None,
                "reports_to": pos.reports_to.title if pos.reports_to else None,
                "active": bool(pos.active),
            }
            for pos in positions
        ],
    }

    try:
        os.makedirs(os.path.dirname(ORG_BACKUP_PATH), exist_ok=True)
        with open(ORG_BACKUP_PATH, "w", encoding="utf-8") as fp:
            json.dump(payload, fp, ensure_ascii=False, indent=2)
        return True
    except OSError as exc:  # pragma: no cover - filesystem guard
        print(f"⚠️ Unable to write org structure backup: {exc}")
        return False


def restore_org_structure_from_backup():
    """Restore departments and positions from backup when the database is empty."""

    if Department.query.count() > 0 or Position.query.count() > 0:
        return False
    if not os.path.exists(ORG_BACKUP_PATH):
        return False

    try:
        with open(ORG_BACKUP_PATH, "r", encoding="utf-8") as fp:
            payload = json.load(fp)
    except (OSError, json.JSONDecodeError) as exc:  # pragma: no cover - IO guard
        print(f"⚠️ Unable to load org structure backup: {exc}")
        return False

    departments_data = payload.get("departments") or []
    positions_data = payload.get("positions") or []
    department_lookup = {}

    for entry in departments_data:
        name = (entry.get("name") or "").strip()
        if not name:
            continue
        branch = entry.get("branch") or DEPARTMENT_BRANCHES[0]
        if branch not in DEPARTMENT_BRANCHES:
            branch = DEPARTMENT_BRANCHES[0]
        dept = Department(
            name=name,
            branch=branch,
            description=(entry.get("description") or None),
            active=_parse_boolean_cell(entry.get("active"), default=True),
        )
        db.session.add(dept)
        db.session.flush()
        department_lookup[name.lower()] = dept

    for entry in departments_data:
        name = (entry.get("name") or "").strip()
        parent_name = (entry.get("parent") or "").strip()
        if not name or not parent_name:
            continue
        dept = department_lookup.get(name.lower())
        parent = department_lookup.get(parent_name.lower())
        if dept and parent:
            dept.parent = parent

    position_lookup = {}
    for entry in positions_data:
        title = (entry.get("title") or "").strip()
        if not title:
            continue
        department_name = (entry.get("department") or "").strip().lower()
        department = department_lookup.get(department_name) if department_name else None
        position = Position(
            title=title,
            department=department,
            active=_parse_boolean_cell(entry.get("active"), default=True),
        )
        db.session.add(position)
        db.session.flush()
        position_lookup[title.lower()] = position

    for entry in positions_data:
        title = (entry.get("title") or "").strip()
        manager_title = (entry.get("reports_to") or "").strip()
        if not title or not manager_title:
            continue
        position = position_lookup.get(title.lower())
        manager = position_lookup.get(manager_title.lower())
        if position and manager and not _position_cycle(position, manager):
            position.reports_to = manager

    db.session.commit()
    backup_org_structure()
    print("✅ Restored departments and positions from backup")
    return True
def _module_visibility_required(module_key, owner_user_id=None, owner_user_ids=None):
    if current_user.can_view_module(module_key):
        return

    candidate_owner_ids = set(owner_user_ids or [])
    if owner_user_id is not None:
        candidate_owner_ids.add(owner_user_id)

    if candidate_owner_ids and current_user.id in candidate_owner_ids:
        return

    abort(403)


def get_assignable_users_for_module(module_key, order_by="name"):
    module_key = (module_key or "").strip().lower()
    query = User.query
    if order_by == "username":
        query = query.order_by(User.username.asc())
    else:
        query = query.order_by(User.first_name.asc(), User.last_name.asc(), User.username.asc())
    users = query.all()
    return [user for user in users if user.can_be_assigned_module(module_key)]


@app.context_processor
def inject_current_user():
    # Ensure templates always receive the `current_user` proxy. Some rendering
    # flows (for example, template compilation during application startup or
    # when a request bypasses Flask-Login's context processor) may otherwise
    # fail to resolve `current_user`, resulting in Jinja undefined errors.
    return {"current_user": current_user}


@app.context_processor
def inject_workspace_modules():
    return {
        "workspace_modules": WORKSPACE_MODULES,
        "workspace_module_map": WORKSPACE_MODULE_MAP,
    }


@app.context_processor
def eleva_permissions_context():
    if not current_user or not getattr(current_user, "is_authenticated", False):
        return {}
    can_see_commercial = (
        current_user.can_view_module("sales")
        or current_user.can_view_module("finance")
        or current_user.can_view_module("accounts")
    )
    return {
        "can_see_commercial": can_see_commercial,
    }


@app.context_processor
def inject_service_form_options():
    return {
        "SERVICE_BRANCH_OPTIONS": SERVICE_BRANCH_OPTIONS,
        "SERVICE_BRANCH_OPTION_SET": SERVICE_BRANCH_OPTION_SET,
        "LIFT_TYPE_OPTIONS": LIFT_TYPE_OPTIONS,
        "LIFT_CAPACITY_PERSON_OPTIONS": LIFT_CAPACITY_PERSON_OPTIONS,
        "MACHINE_TYPE_OPTIONS": MACHINE_TYPE_OPTIONS,
        "DOOR_TYPE_OPTIONS": DOOR_TYPE_OPTIONS,
        "DOOR_FINISH_OPTIONS": DOOR_FINISH_OPTIONS,
        "POWER_SUPPLY_OPTIONS": POWER_SUPPLY_OPTIONS,
        "AMC_STATUS_OPTIONS": AMC_STATUS_OPTIONS,
        "LIFT_STATUS_OPTIONS": LIFT_STATUS_OPTIONS,
    }


@app.context_processor
def inject_switchable_users():
    users = []
    if current_user.is_authenticated:
        try:
            users = (
                User.query.order_by(
                    User.first_name.asc(),
                    User.last_name.asc(),
                    User.username.asc(),
                ).all()
            )
        except Exception:
            users = []
    return {"switchable_users": users}


@app.context_processor
def inject_notifications():
    if not current_user or not getattr(current_user, "is_authenticated", False):
        return {}
    notifications = (
        Notification.query.filter_by(user_id=current_user.id)
        .order_by(Notification.created_at.desc())
        .limit(10)
        .all()
    )
    unread_count = (
        Notification.query.filter_by(user_id=current_user.id, is_read=False).count()
    )
    return {
        "recent_notifications": notifications,
        "unread_notification_count": unread_count,
    }


# NEW: QC Work table (simple tracker for “create work for new site QC”)

@login_manager.user_loader
def load_user(user_id):
    # Ensure that any pending bootstrap/migration tasks run before we try to
    # query the database. When the application starts for the very first time
    # Flask-Login may attempt to load the user (via `current_user`) before our
    # `@app.before_request` hook that calls `ensure_bootstrap()` executes. In
    # that scenario the legacy SQLite schema might still be missing newer
    # columns such as `user.active`, resulting in an OperationalError during the
    # initial SELECT. Proactively invoking `ensure_bootstrap()` here guarantees
    # the schema has been patched before any queries are issued.
    ensure_bootstrap()
    try:
        user_obj = db.session.get(User, int(user_id))
    except (TypeError, ValueError):
        return None
    if user_obj and not user_obj.is_active:
        return None
    return user_obj


ALLOWED_PHOTO = {"png", "jpg", "jpeg", "webp"}
ALLOWED_VIDEO = {"mp4", "mov", "avi", "mkv"}
ALLOWED_ATTACHMENTS = ALLOWED_PHOTO.union(ALLOWED_VIDEO).union({"pdf", "doc", "docx", "xls", "xlsx"})

def allowed_file(filename, kind="photo"):
    if "." not in filename:
        return False
    ext = filename.rsplit(".", 1)[1].lower()
    if kind == "photo":
        return ext in ALLOWED_PHOTO
    if kind == "video":
        return ext in ALLOWED_VIDEO
    return ext in ALLOWED_ATTACHMENTS


@app.before_request
def enforce_user_session():
    if not current_user.is_authenticated:
        return

    if not current_user.is_active:
        session.pop("session_token", None)
        logout_user()
        flash("Your account has been deactivated.", "error")
        return

    if not current_user.session_token:
        current_user.issue_session_token()
        db.session.commit()

    token = session.get("session_token")
    if token and token == current_user.session_token:
        return

    session.pop("session_token", None)
    logout_user()
    flash("You have been signed out. Please log in again.", "info")


def log_work_event(work_id, action, actor_id=None, from_status=None, to_status=None, details=None):
    entry = QCWorkLog(
        work_id=work_id,
        actor_id=actor_id,
        action=action,
        from_status=from_status,
        to_status=to_status,
        details_json=json.dumps(details or {}, ensure_ascii=False)
    )
    db.session.add(entry)


def get_or_create_default_task_form():
    form = FormSchema.query.filter_by(name=DEFAULT_TASK_FORM_NAME).first()
    if form:
        return form
    fallback_schema = [
        {"label": "Summary", "type": "textarea", "required": False, "allow_remark": False},
        {"label": "Status", "type": "select", "required": True, "options": ["Not Started", "In Progress", "Completed"]}
    ]
    form = FormSchema(
        name=DEFAULT_TASK_FORM_NAME,
        schema_json=json.dumps(fallback_schema, ensure_ascii=False),
        min_photos_if_all_good=0
    )
    db.session.add(form)
    db.session.flush()
    return form


def release_dependent_tasks(work, actor_id=None):
    for dependent in work.all_dependents:
        if dependent.dependency_satisfied:
            log_work_event(
                dependent.id,
                "dependency_released",
                actor_id=actor_id,
                details={"dependency": work.id}
            )


def block_child_tasks(work, actor_id=None):
    for dependent in work.all_dependents:
        if work.id in dependent.dependency_ids:
            log_work_event(
                dependent.id,
                "dependency_reinstated",
                actor_id=actor_id,
                details={"dependency": work.id}
            )


# ---------------------- DESIGN / PURCHASE / STORE MODULES ----------------------


def _design_default_filters(query):
    """Limit design data visibility to design-team users unless admin."""
    if current_user.is_admin:
        return query
    role = (current_user.role or "").lower()
    if "design" in role:
        return query.filter(
            or_(
                DesignTask.assigned_to_user_id == current_user.id,
                DesignTask.requested_by_user_id == current_user.id,
            )
        )
    return query


def _normalize_design_task_type(task_type):
    normalized = (task_type or "").strip().lower()
    if normalized in {"drawing", "bom", "sales_query"}:
        return "design"
    if normalized in {"general", "design", "site_visit"}:
        return normalized
    return "general"


def _design_status_options_for(task_type):
    normalized = _normalize_design_task_type(task_type)
    if normalized == "design":
        return DESIGN_TASK_STATUS_OPTIONS
    if normalized == "site_visit":
        return DESIGN_SITE_VISIT_STATUS_OPTIONS
    return DESIGN_GENERAL_STATUS_OPTIONS


def _design_status_map():
    ordered = []
    seen = set()
    for status in (
        DESIGN_GENERAL_STATUS_OPTIONS
        + DESIGN_TASK_STATUS_OPTIONS
        + DESIGN_SITE_VISIT_STATUS_OPTIONS
    ):
        if status in seen:
            continue
        ordered.append(status)
        seen.add(status)
    return {status: status for status in ordered}


def _design_task_has_drawings(task) -> bool:
    return (
        db.session.query(DesignDrawing.id)
        .filter(DesignDrawing.design_task_id == task.id)
        .first()
        is not None
    )

def _mark_design_task_inputs_received(task, *, had_drawings: bool) -> bool:
    if had_drawings:
        return False
    if not task.has_pending_inputs:
        return False
    task.has_pending_inputs = False
    task.updated_at = datetime.datetime.utcnow()
    return True


def _get_design_board_payload():
    statuses = _design_status_map()
    tasks_by_status = {}
    ordered_tasks = []
    active_task_query = _design_default_filters(
        DesignTask.query.filter(
            or_(
                func.lower(func.trim(DesignTask.task_type)) != "design",
                func.lower(func.trim(DesignTask.status)) != "finalized",
            )
        )
    )
    for key in statuses:
        tasks_by_status[key] = (
            active_task_query
            .filter(DesignTask.status == key)
            .order_by(DesignTask.due_date.nullsfirst())
            .all()
        )
        ordered_tasks.extend(tasks_by_status[key])
    return statuses, tasks_by_status, ordered_tasks


@app.route("/design", methods=["GET"])
@login_required
def design_overview():
    ensure_bootstrap()
    base_query = _design_default_filters(
        DesignTask.query.filter(
            or_(
                func.lower(func.trim(DesignTask.task_type)) != "design",
                func.lower(func.trim(DesignTask.status)) != "finalized",
            )
        )
    )
    active_tasks = base_query.all()
    status_counts = {
        "pending_inputs": sum(1 for task in active_tasks if task.status in ["Drawing pending", "SRT input", "Sales input"]),
        "pending_drawings": sum(1 for task in active_tasks if task.status == "BOM pending"),
        "pending_bom": sum(1 for task in active_tasks if task.status == "BOM approved"),
        "sent_for_approval": sum(1 for task in active_tasks if task.status == "Sent for approval"),
        "approved": sum(1 for task in active_tasks if task.status in ["Complete", "Finalized"]),
    }

    return render_template(
        "design_overview.html",
        total_active_tasks=len(active_tasks),
        status_counts=status_counts,
    )


@app.route("/design/metrics", methods=["GET"])
@login_required
def design_metrics_legacy_redirect():
    return redirect(url_for("design_overview"), code=302)


@event.listens_for(DesignTask, "after_insert")
def _notify_design_task_assignee(mapper, connection, target):
    if not target.assigned_to_user_id:
        return
    connection.execute(
        Notification.__table__.insert().values(
            user_id=target.assigned_to_user_id,
            message=f"You have been assigned a new design task: {target.description or target.project_label}",
            link_url=f"/design/tasks/{target.id}",
            created_at=datetime.datetime.utcnow(),
            is_read=False,
        )
    )


@event.listens_for(DesignTask, "after_update")
def _notify_design_task_reassignment(mapper, connection, target):
    history = inspect(target).attrs.assigned_to_user_id.history
    if not history.has_changes():
        return

    previous = history.deleted[0] if history.deleted else None
    current = history.added[0] if history.added else None
    now = datetime.datetime.utcnow()
    link_url = f"/design/tasks/{target.id}"
    payload = []

    if previous and previous != current:
        payload.append(
            {
                "user_id": previous,
                "message": f"Task reassigned: {target.description or target.project_label}",
                "link_url": link_url,
                "created_at": now,
                "is_read": False,
            }
        )
    if current and current != previous:
        payload.append(
            {
                "user_id": current,
                "message": f"You have been assigned a new design task: {target.description or target.project_label}",
                "link_url": link_url,
                "created_at": now,
                "is_read": False,
            }
        )

    if payload:
        connection.execute(Notification.__table__.insert(), payload)


@app.route("/design/tasks", methods=["GET", "POST"])
@login_required
def design_tasks():
    ensure_bootstrap()
    if request.method == "POST":
        allowed_creators = ["admin", "design", "sales", "installation", "service"]
        role = (current_user.role or "").lower()
        if (not current_user.is_admin) and role not in allowed_creators:
            abort(403)

        task_type = _normalize_design_task_type(request.form.get("task_type") or "general")
        project_id = request.form.get("project_id") or None
        project_name = request.form.get("project_name") or None
        requested_by = request.form.get("requested_by_user_id") or None
        assigned_to = request.form.get("assigned_to_user_id") or None
        status_value = _design_status_options_for(task_type)[0]
        priority = request.form.get("priority") or "medium"
        due_date_raw = request.form.get("due_date")
        task_name = (request.form.get("task_name") or request.form.get("description") or "").strip()

        try:
            due_date = datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date() if due_date_raw else None
        except ValueError:
            due_date = None

        task = DesignTask(
            task_type=task_type,
            project_id=project_id if project_id else None,
            project_name=project_name,
            requested_by_user_id=requested_by if requested_by else current_user.id,
            assigned_to_user_id=assigned_to if assigned_to else None,
            status=status_value,
            has_pending_inputs=True,
            priority=priority,
            due_date=due_date,
            task_name=task_name,
            description=request.form.get("description") or task_name,
            origin_type=None,
            origin_id=None,
            origin_reference=None,
            attachment=request.form.get("attachment") or None,
            parent_task_id=request.form.get("parent_task_id") or None,
            notes=request.form.get("notes") or None,
            subtype=request.form.get("subtype") or None,
        )
        db.session.add(task)
        db.session.commit()
        flash("Design task created.", "success")
        return redirect(url_for("design_tasks"))

    projects = Project.query.order_by(Project.name).all()
    users = User.query.order_by(User.first_name, User.username).all()
    statuses, _, ordered_tasks = _get_design_board_payload()
    status_options_by_type = {
        "general": DESIGN_GENERAL_STATUS_OPTIONS,
        "design": DESIGN_TASK_STATUS_OPTIONS,
        "site_visit": DESIGN_SITE_VISIT_STATUS_OPTIONS,
        "default": DESIGN_GENERAL_STATUS_OPTIONS,
    }

    can_move_cards = current_user.is_admin or "design" in (current_user.role or "").lower()

    return render_template(
        "design_tasks.html",
        ordered_tasks=ordered_tasks,
        statuses=statuses,
        status_options_by_type=status_options_by_type,
        users=users,
        projects=projects,
        can_move_cards=can_move_cards,
    )


def _extract_design_status_value():
    payload = request.get_json(silent=True) or {}
    status_value = payload.get("status")
    if status_value is None:
        status_value = request.form.get("status")
    if isinstance(status_value, str):
        return status_value.strip()
    return status_value


def _apply_design_task_status_update(task, status_value):
    allowed_statuses = set(_design_status_options_for(_normalize_design_task_type(task.task_type)))
    if not isinstance(status_value, str) or not status_value:
        return False, "Missing status value."
    if status_value not in allowed_statuses:
        return False, "Invalid status value."

    task.status = status_value
    task.updated_at = datetime.datetime.utcnow()
    if (
        task.assigned_to_user_id
        and task.assigned_to_user_id != current_user.id
    ):
        create_notification(
            task.assigned_to_user_id,
            f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
            url_for("design_task_detail", task_id=task.id),
            commit=False,
        )
    return True, None


@app.route("/design/tasks/<int:task_id>/update_status", methods=["POST"])
@login_required
def design_task_update_status(task_id):
    task = DesignTask.query.get_or_404(task_id)
    role = (current_user.role or "").lower()
    if not (current_user.is_admin or "design" in role):
        return jsonify({"ok": False, "message": "You are not allowed to update task status."}), 403

    status_value = _extract_design_status_value()
    is_valid, error_message = _apply_design_task_status_update(task, status_value)
    if not is_valid:
        return jsonify({"ok": False, "message": error_message or "Invalid status."}), 400

    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        return jsonify({"ok": False, "message": "Failed to persist task status."}), 500

    return jsonify({
        "ok": True,
        "task_id": task.id,
        "status": task.status,
        "has_pending_inputs": bool(task.has_pending_inputs),
    })


@app.route("/design/tasks/<int:task_id>/status", methods=["POST"])
@login_required
def design_task_status(task_id):
    return design_task_update_status(task_id)


@app.route("/design/tasks/<int:task_id>", methods=["GET", "POST"])
@login_required
def design_task_detail(task_id):
    task = DesignTask.query.get_or_404(task_id)
    role = (current_user.role or "").lower()
    is_design_user = _is_design_user(current_user)
    is_purchase_user = _is_purchase_user(current_user)
    can_edit_bom = current_user.is_admin or any(
        keyword in role for keyword in ["design", "purchase", "project", "installation"]
    )
    can_link_project = current_user.is_admin or "project" in role
    drawing_type_options = [
        {"value": "GAD", "label": "GAD"},
        {"value": "Fabrication", "label": "Fabrication Drawing"},
        {"value": "Civil", "label": "Civil Drawing"},
        {"value": "Other", "label": "Other"},
    ]
    drawing_status_options = ["Draft", "Sent", "Approved", "Superseded"]
    allowed_drawing_types = {option["value"] for option in drawing_type_options}
    allowed_drawing_statuses = set(drawing_status_options)
    task_status_options = _design_status_options_for(_normalize_design_task_type(task.task_type))
    stage_options = _get_active_procurement_stages()
    default_stage = _get_default_procurement_stage()

    def _notify_assignee(message, link_suffix=""):
        assignee_id = getattr(task, "assigned_to_user_id", None)
        if assignee_id and assignee_id != current_user.id:
            create_notification(
                assignee_id,
                message,
                f"{url_for('design_task_detail', task_id=task.id)}{link_suffix}",
                commit=False,
            )

    if request.method == "POST":
        action = request.form.get("action")
        bom_actions = {
            "create_bom_package",
            "update_bom_package",
            "finalize_bom_package",
            "unlock_bom_package",
            "validate_bom_package",
            "generate_bom_package",
            "add_bom_item",
            "update_bom_item",
            "approve_spec_change",
            "reject_spec_change",
            "delete_bom_item",
        }
        if action in bom_actions and not can_edit_bom:
            abort(403)
        if action == "comment":
            body = request.form.get("body")
            if body:
                db.session.add(
                    DesignTaskComment(
                        design_task_id=task.id,
                        body=body,
                        author_id=current_user.id,
                    )
                )
                _notify_assignee(
                    f"New comment on task '{task.description or task.project_label}' by {current_user.display_name}.",
                    link_suffix="#comments",
                )
                db.session.commit()
                flash("Comment added.", "success")
        elif action == "upload_new_drawing":
            drawing_name = (request.form.get("drawing_name") or "").strip()
            drawing_type = request.form.get("drawing_type") or "Other"
            notes = request.form.get("change_reason") or None
            file = request.files.get("drawing_file")
            if not drawing_name:
                flash("Please provide a drawing name.", "danger")
            elif not file or not file.filename:
                flash("Please attach a drawing file.", "danger")
            else:
                if drawing_type not in allowed_drawing_types:
                    drawing_type = "Other"
                had_drawings = _design_task_has_drawings(task)
                filename = secure_filename(f"{uuid.uuid4().hex}_{file.filename}")
                save_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
                os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)
                file.save(save_path)
                drawing = DesignDrawing(
                    project_id=task.project_id,
                    design_task_id=task.id,
                    name=drawing_name,
                    drawing_type=drawing_type,
                    status="Draft",
                    created_by_user_id=current_user.id,
                )
                db.session.add(drawing)
                db.session.flush()
                revision = DesignDrawingRevision(
                    drawing_id=drawing.id,
                    version_number=1,
                    file_name=filename,
                    change_reason=notes,
                    changed_by_user_id=current_user.id,
                )
                drawing.current_version_number = 1
                drawing.updated_at = datetime.datetime.utcnow()
                db.session.add(revision)
                _mark_design_task_inputs_received(task, had_drawings=had_drawings)
                _notify_assignee(
                    f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
                )
                db.session.commit()
                flash("New drawing uploaded.", "success")
        elif action == "upload_revision":
            drawing_id = request.form.get("drawing_id")
            notes = request.form.get("change_reason") or None
            file = request.files.get("revision_file")
            if not drawing_id:
                flash("Please choose a drawing to upload a revision.", "danger")
            elif not file or not file.filename:
                flash("Please attach a drawing file for the revision.", "danger")
            else:
                drawing = DesignDrawing.query.get(drawing_id)
                if not drawing or drawing.design_task_id != task.id:
                    abort(404)
                filename = secure_filename(f"{uuid.uuid4().hex}_{file.filename}")
                save_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
                os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)
                file.save(save_path)
                latest_version = (
                    db.session.query(func.max(DesignDrawingRevision.version_number))
                    .filter(DesignDrawingRevision.drawing_id == drawing.id)
                    .scalar()
                    or 0
                )
                next_version = latest_version + 1
                drawing.current_version_number = next_version
                drawing.updated_at = datetime.datetime.utcnow()
                revision = DesignDrawingRevision(
                    drawing_id=drawing.id,
                    version_number=next_version,
                    file_name=filename,
                    change_reason=notes,
                    changed_by_user_id=current_user.id,
                )
                db.session.add(revision)
                _notify_assignee(
                    f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
                )
                db.session.commit()
                flash("Drawing revision uploaded.", "success")
        elif action == "update_drawing_status":
            drawing_id = request.form.get("drawing_id")
            status_value = request.form.get("status")
            drawing = DesignDrawing.query.get(drawing_id) if drawing_id else None
            if not drawing or drawing.design_task_id != task.id:
                abort(404)
            if status_value not in allowed_drawing_statuses:
                flash("Invalid drawing status.", "danger")
            else:
                previous_status = drawing.status
                drawing.status = status_value
                drawing.updated_at = datetime.datetime.utcnow()
                _log_drawing_status_change(
                    old_status=previous_status,
                    new_status=status_value,
                    drawing_id=drawing.id,
                )
                db.session.commit()
                flash("Drawing status updated.", "success")
        elif action == "update_task":
            title = (request.form.get("title") or "").strip()
            priority = request.form.get("priority") or task.priority
            due_date_raw = request.form.get("due_date")
            assignee_id = request.form.get("assigned_to_user_id") or None
            status_value = request.form.get("task_status") or task.status
            project_id = request.form.get("project_id") or None

            if not title:
                flash("Task title is required.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))

            try:
                due_date = (
                    datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date()
                    if due_date_raw
                    else None
                )
            except ValueError:
                due_date = None

            if status_value in task_status_options:
                task.status = status_value
            task.task_name = title
            task.description = request.form.get("description") or title
            task.attachment = request.form.get("attachment") or task.attachment
            task.priority = priority
            task.due_date = due_date
            task.assigned_to_user_id = int(assignee_id) if assignee_id else None

            if can_link_project:
                if project_id:
                    project = Project.query.get(project_id)
                    if project:
                        task.project_id = project.id
                        task.project_name = project.name
                else:
                    task.project_id = None

            task.updated_at = datetime.datetime.utcnow()
            db.session.commit()
            flash("Design task updated.", "success")
        elif action == "create_linked_task":
            link_kind = (request.form.get("link_kind") or "").strip().lower()
            linked_type = "site_visit" if link_kind == "srt" else "general"
            linked_title = f"{link_kind.upper()} input for Task #{task.id}" if link_kind else f"Linked input for Task #{task.id}"
            linked_task = DesignTask(
                task_type=linked_type,
                subtype=link_kind or None,
                task_name=linked_title,
                description=task.description or linked_title,
                project_id=task.project_id,
                project_name=task.project_name,
                requested_by_user_id=current_user.id,
                assigned_to_user_id=task.assigned_to_user_id,
                status=_design_status_options_for(linked_type)[0],
                has_pending_inputs=False,
                priority=task.priority or "medium",
                due_date=task.due_date,
                origin_type="design",
                origin_id=task.id,
                origin_reference=f"Linked from Design Task #{task.id}",
                parent_task_id=task.id,
            )
            db.session.add(linked_task)
            db.session.commit()
            flash("Linked task created.", "success")
        elif action == "create_bom_package":
            package_name = (request.form.get("package_name") or "").strip()
            template_id_raw = request.form.get("bom_template_id") or None
            template_id = int(template_id_raw) if template_id_raw else None
            if not package_name:
                flash("Package name is required.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            bom = _get_or_create_design_task_bom(task)
            package = BOMPackage(
                bom_id=bom.id,
                name=package_name,
                status="draft",
                bom_template_id=template_id,
                created_at=datetime.datetime.utcnow(),
            )
            db.session.add(package)
            db.session.commit()
            flash("BOM package created.", "success")
        elif action == "update_bom_package":
            package_id = request.form.get("bom_package_id")
            package = BOMPackage.query.get_or_404(package_id)
            if package.bom and package.bom.design_task_id != task.id:
                abort(404)
            if package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))
            package.name = (request.form.get("package_name") or package.name).strip()
            template_id_raw = request.form.get("bom_template_id") or None
            package.bom_template_id = (
                int(template_id_raw) if template_id_raw else package.bom_template_id
            )
            db.session.commit()
            flash("Package updated.", "success")
        elif action in {"finalize_bom_package", "unlock_bom_package"}:
            package_id = request.form.get("bom_package_id")
            package = BOMPackage.query.get_or_404(package_id)
            if package.bom and package.bom.design_task_id != task.id:
                abort(404)
            if package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if action == "finalize_bom_package":
                missing_spec_items = _bom_package_missing_spec_items(package.id)
                if missing_spec_items:
                    flash(
                        f"Cannot finalize. {len(missing_spec_items)} BOM line(s) are missing Specification.",
                        "danger",
                    )
                    return redirect(url_for("design_task_detail", task_id=task.id))
                package.status = "final"
                db.session.commit()
                flash("Package finalized.", "success")
            else:
                flash("This BOM package is finalized and cannot be edited.", "warning")
        elif action in {"validate_bom_package", "generate_bom_package"}:
            package_id = request.form.get("bom_package_id")
            package = BOMPackage.query.get_or_404(package_id)
            if package.bom and package.bom.design_task_id != task.id:
                abort(404)
            template_id_raw = request.form.get("bom_template_id") or package.bom_template_id
            template_id = int(template_id_raw) if template_id_raw else None
            if not template_id:
                flash("Select a BOM template before validating or generating.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            template = (
                BomTemplate.query.options(
                    joinedload(BomTemplate.inputs),
                    joinedload(BomTemplate.stages)
                    .joinedload(BomTemplateStage.sections)
                    .joinedload(BomTemplateSection.lines)
                    .joinedload(BomTemplateLine.part_class),
                )
                .get(template_id)
            )
            if not template:
                flash("Selected BOM template was not found.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            input_prefix = f"input_{package.id}_"
            input_values = {
                key.replace(input_prefix, ""): value
                for key, value in request.form.items()
                if key.startswith(input_prefix)
            }
            evaluation = evaluate_bom_template(template, input_values)
            error_count = len(evaluation.get("errors") or [])
            expression_error_count = len(evaluation.get("expression_errors") or [])
            if action == "validate_bom_package":
                if error_count or expression_error_count:
                    flash(
                        f"Validation found {error_count + expression_error_count} issue(s).",
                        "warning",
                    )
                else:
                    flash("Validation successful. Ready to generate.", "success")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if error_count or expression_error_count:
                flash("Resolve template errors before generating items.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            package.bom_template_id = template.id
            package.input_snapshot_json = json.dumps(input_values)
            package.generated_at = datetime.datetime.utcnow()
            package.generated_by_user_id = current_user.id

            (
                BOMItem.query.filter_by(bom_package_id=package.id)
                .filter(
                    or_(
                        BOMItem.is_generated.is_(True),
                        BOMItem.source_template_line_id.isnot(None),
                    )
                )
                .delete(synchronize_session=False)
            )
            created_count = 0
            for line_result in evaluation.get("lines") or []:
                if line_result.get("errors"):
                    continue
                final_qty = float(line_result.get("final_qty") or 0)
                if final_qty <= 0:
                    continue
                line = line_result.get("line")
                if not line:
                    continue
                section_name = line.section.section_name if line.section else None
                stage_name = (
                    line.section.stage.stage_name
                    if line.section and line.section.stage
                    else None
                )
                item_code = (
                    line.part_class.name if line.part_class else line.ref_key or "Item"
                )
                db.session.add(
                    BOMItem(
                        bom_id=package.bom_id,
                        bom_package_id=package.id,
                        part_class_id=line.part_class_id,
                        item_code=item_code,
                        description=None,
                        category=section_name,
                        stage=stage_name,
                        section_title=section_name,
                        specification=None,
                        unit=line.unit,
                        quantity_required=final_qty,
                        stage_id=None,
                        remarks=None,
                        source_template_line_id=line.id,
                        source_ref_key=line.ref_key,
                        is_generated=True,
                        suggested_part_id=(
                            line.part_class.primary_part_id
                            if line.part_class and line.part_class.primary_part_id
                            else None
                        ),
                    )
                )
                created_count += 1
            _notify_assignee(
                f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
            )
            db.session.commit()
            flash(f"Generated {created_count} BOM item(s) for {package.name}.", "success")
        elif action == "add_bom_item":
            package_id = request.form.get("bom_package_id")
            package = BOMPackage.query.get_or_404(package_id)
            if package.bom and package.bom.design_task_id != task.id:
                abort(404)
            if package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))
            item_code = (request.form.get("item_code") or "").strip()
            if not item_code:
                flash("Item name is required.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            specification = (request.form.get("specification") or "").strip() or None
            part_class_id_raw = request.form.get("part_class_id") or None
            part_class_id = int(part_class_id_raw) if part_class_id_raw else None
            if not part_class_id:
                flash("Part class is required.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            suggested_part_id = _parse_optional_int(request.form.get("suggested_part_id"))
            part_class = PartClass.query.get(part_class_id) if part_class_id else None
            if not part_class:
                flash("Part class was not found.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            allowed_suggested_part_ids = {part_class.primary_part_id} if part_class.primary_part_id else set()
            if suggested_part_id is None and part_class and part_class.primary_part_id:
                suggested_part_id = part_class.primary_part_id
            if suggested_part_id and suggested_part_id not in allowed_suggested_part_ids:
                flash("Suggested part must belong to the selected part class.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            unit = (request.form.get("unit") or "").strip()
            if unit not in BOM_UNIT_OPTIONS:
                flash("Please select a valid unit.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            item = BOMItem(
                bom_id=package.bom_id,
                bom_package_id=package.id,
                part_class_id=part_class_id,
                item_code=item_code,
                description=specification,
                category=None,
                stage=None,
                section_title=None,
                specification=specification,
                unit=unit,
                quantity_required=float(request.form.get("quantity_required") or 0),
                stage_id=(default_stage.id if default_stage else None),
                remarks=request.form.get("remarks"),
                is_generated=False,
                suggested_part_id=suggested_part_id,
            )
            if suggested_part_id and not Product.query.get(suggested_part_id):
                flash("Suggested part was not found.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if _bom_line_spec_required(item) and not specification:
                flash("Specification is required for this BOM line.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            db.session.add(item)
            _notify_assignee(
                f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
            )
            db.session.commit()
            flash("BOM item added.", "success")
        elif action in {"update_bom_item", "approve_spec_change", "reject_spec_change"}:
            item_id = request.form.get("item_id")
            item = BOMItem.query.get_or_404(item_id)
            if item.bom and item.bom.design_task_id != task.id:
                abort(404)
            if item.bom_package and item.bom_package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))

            active_request = (
                BOMSpecChangeRequest.query.filter_by(bom_line_id=item.id, status="Pending")
                .order_by(BOMSpecChangeRequest.requested_at.desc(), BOMSpecChangeRequest.id.desc())
                .first()
            )

            if action == "reject_spec_change":
                if not is_design_user:
                    abort(403)
                if not active_request:
                    flash("No pending spec change request found for this BOM line.", "warning")
                    return redirect(url_for("design_task_detail", task_id=task.id))
                active_request.status = "Rejected"
                active_request.resolved_by = current_user.id
                active_request.resolved_at = datetime.datetime.utcnow()
                active_request.resolution_notes = (request.form.get("resolution_notes") or "").strip() or None
                db.session.commit()
                flash("Spec change request rejected.", "info")
                return redirect(url_for("design_task_detail", task_id=task.id))

            part_class_id_raw = request.form.get("part_class_id") or None
            part_class_id = int(part_class_id_raw) if part_class_id_raw else None
            if not part_class_id:
                flash("Part class is required.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            suggested_part_id = _parse_optional_int(request.form.get("suggested_part_id"))
            part_class = PartClass.query.get(part_class_id)
            if not part_class:
                flash("Part class was not found.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            allowed_suggested_part_ids = {part_class.primary_part_id} if part_class.primary_part_id else set()
            if suggested_part_id and suggested_part_id not in allowed_suggested_part_ids:
                flash("Suggested part must belong to the selected part class.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            old_specification = (item.specification or "").strip()
            item.part_class_id = part_class_id
            item.suggested_part_id = suggested_part_id
            item.item_code = (request.form.get("item_code") or "").strip()
            item.stage = (request.form.get("stage") or "").strip() or None
            item.section_title = (request.form.get("section_title") or "").strip() or None
            item.specification = (request.form.get("specification") or "").strip() or None
            item.description = item.specification
            item.category = item.section_title
            item.unit = request.form.get("unit")
            item.quantity_required = float(request.form.get("quantity_required") or 0)
            item.remarks = request.form.get("remarks")
            item.is_generated = bool(item.is_generated)
            if suggested_part_id and not Product.query.get(suggested_part_id):
                flash("Suggested part was not found.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if _bom_line_spec_required(item) and not (item.specification or "").strip():
                flash("Specification is required for this BOM line.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))

            new_specification = (item.specification or "").strip()
            spec_changed = new_specification != old_specification
            requires_design_authority = spec_changed or action == "approve_spec_change"
            if requires_design_authority and not is_design_user:
                flash("Only Design can modify BOM specifications.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))
            if active_request and spec_changed and action != "approve_spec_change":
                flash("Use 'Approve + Save' to apply requested specification changes.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))

            if action == "approve_spec_change":
                if not active_request:
                    flash("No pending spec change request found for this BOM line.", "warning")
                    return redirect(url_for("design_task_detail", task_id=task.id))
                active_request.status = "Approved"
                active_request.resolved_by = current_user.id
                active_request.resolved_at = datetime.datetime.utcnow()
                active_request.resolution_notes = (request.form.get("resolution_notes") or "").strip() or None

            if spec_changed and item.bom:
                item.bom.revision_number = (item.bom.revision_number or 0) + 1
                item.bom.last_modified_at = datetime.datetime.utcnow()
                linked_po_lines = PurchaseOrderItem.query.filter_by(source_bom_line_id=item.id).all()
                for po_line in linked_po_lines:
                    po_line.is_out_of_sync = True

            db.session.commit()
            flash(
                "BOM item updated and spec change request approved."
                if action == "approve_spec_change"
                else "BOM item updated.",
                "success",
            )
        elif action == "delete_bom_item":
            item_id = request.form.get("item_id")
            item = BOMItem.query.get_or_404(item_id)
            if item.bom and item.bom.design_task_id != task.id:
                abort(404)
            if item.bom_package and item.bom_package.status == "final":
                flash("This BOM package is finalized and cannot be edited.", "warning")
                return redirect(url_for("design_task_detail", task_id=task.id))
            db.session.delete(item)
            db.session.commit()
            flash("BOM item deleted.", "info")
        elif action == "clarification":
            detail = (request.form.get("clarification_body") or "").strip()
            if not detail:
                flash("Please provide clarification details.", "danger")
                return redirect(url_for("design_task_detail", task_id=task.id))

            task.status = "Hold"
            db.session.add(
                DesignTaskComment(
                    design_task_id=task.id,
                    body=f"Designer requested clarification: {detail}",
                    author_id=current_user.id,
                )
            )

            sales_user_id = None
            if task.origin_type == "sales" and task.origin_id:
                opportunity = SalesOpportunity.query.get(task.origin_id)
                sales_user_id = opportunity.owner_id if opportunity else None

            if sales_user_id:
                create_notification(
                    sales_user_id,
                    f"Designer requested clarification on task {task.description or task.project_label}",
                    url_for("design_task_detail", task_id=task.id),
                    commit=False,
                )

            _notify_assignee(
                f"Task '{task.description or task.project_label}' was updated by {current_user.display_name}.",
            )

            db.session.commit()
            flash("Clarification request sent to sales.", "success")
        return redirect(url_for("design_task_detail", task_id=task.id))

    drawings = DesignDrawing.query.filter_by(design_task_id=task.id).all()

    def _latest_revision_at(drawing):
        latest = max(
            (rev.created_at for rev in drawing.revisions if rev.created_at),
            default=None,
        )
        return latest or drawing.updated_at or drawing.created_at

    drawings_sorted = sorted(drawings, key=_latest_revision_at, reverse=True)
    drawings_by_type = {option["value"]: [] for option in drawing_type_options}
    drawings_by_type.setdefault("Other", [])
    latest_revisions = {}
    for drawing in drawings_sorted:
        drawing_type = drawing.drawing_type or "Other"
        if drawing_type not in drawings_by_type:
            drawing_type = "Other"
        drawings_by_type[drawing_type].append(drawing)
        revisions_sorted = sorted(
            drawing.revisions, key=lambda rev: rev.version_number, reverse=True
        )
        latest_revisions[drawing.id] = revisions_sorted[0] if revisions_sorted else None
    bom = (
        BillOfMaterials.query.filter_by(design_task_id=task.id)
        .order_by(BillOfMaterials.id.asc())
        .first()
    )
    bom_packages = []
    bom_items_by_package = {}
    all_bom_items = []
    if bom:
        bom_packages = (
            BOMPackage.query.filter_by(bom_id=bom.id)
            .order_by(BOMPackage.created_at.asc().nullslast(), BOMPackage.id.asc())
            .all()
        )
        for package in bom_packages:
            package_items = (
                BOMItem.query.filter_by(bom_id=bom.id, bom_package_id=package.id)
                .order_by(BOMItem.item_code.asc(), BOMItem.id.asc())
                .all()
            )
            bom_items_by_package[package.id] = package_items
            for item in package_items:
                all_bom_items.append({"package": package, "item": item})
    pending_spec_requests_by_line = {}
    latest_spec_requests_by_line = {}
    if bom:
        bom_line_ids = [entry["item"].id for entry in all_bom_items]
        if bom_line_ids:
            all_requests = (
                BOMSpecChangeRequest.query.filter(BOMSpecChangeRequest.bom_line_id.in_(bom_line_ids))
                .order_by(BOMSpecChangeRequest.requested_at.desc(), BOMSpecChangeRequest.id.desc())
                .all()
            )
            for req in all_requests:
                latest_spec_requests_by_line.setdefault(req.bom_line_id, req)
                if req.status == "Pending":
                    pending_spec_requests_by_line.setdefault(req.bom_line_id, req)

    related_drawing_sites = []
    users = User.query.order_by(User.first_name, User.username).all()
    project_options = (
        Project.query.order_by(Project.created_at.desc().nullslast()).limit(100).all()
    )
    drawing_site_options = (
        DrawingSite.query.order_by(DrawingSite.last_updated.desc().nullslast())
        .limit(100)
        .all()
    )
    if task.project_id:
        related_drawing_sites = DrawingSite.query.filter(
            DrawingSite.project_id == task.project_id
        ).all()
    elif task.project_name:
        related_drawing_sites = DrawingSite.query.filter(
            DrawingSite.project_no.ilike(f"%{task.project_name}%")
        ).all()

    part_classes = (
        PartClass.query.filter(PartClass.active.is_(True))
        .order_by(PartClass.sort_order.asc(), PartClass.name.asc())
        .all()
    )
    parts = (
        Product.query.filter(Product.is_active.is_(True))
        .order_by(Product.name.asc())
        .all()
    )
    part_class_suggested_parts = {}
    for part_class in part_classes:
        suggestions = []
        if part_class.primary_part_id:
            primary_part = Product.query.get(part_class.primary_part_id)
            if primary_part:
                suggestions.append(
                    {
                        "id": primary_part.id,
                        "label": _product_option_label(primary_part),
                    }
                )
        part_class_suggested_parts[part_class.id] = suggestions
    bom_template_options = (
        BomTemplate.query.filter(BomTemplate.is_active.is_(True))
        .order_by(BomTemplate.name.asc())
        .all()
    )
    bom_template_map = {
        template.id: template
        for template in BomTemplate.query.options(joinedload(BomTemplate.inputs)).all()
    }
    package_input_values = {
        package.id: _parse_bom_package_inputs(package) for package in bom_packages
    }
    bom_package_spec_summary = {
        package.id: {
            "total": len(bom_items_by_package.get(package.id, [])),
            "missing": len(_bom_package_missing_spec_items(package.id)),
        }
        for package in bom_packages
    }

    return render_template(
        "design_task_detail.html",
        task=task,
        drawings=drawings,
        bom=bom,
        bom_packages=bom_packages,
        bom_items_by_package=bom_items_by_package,
        all_bom_items=all_bom_items,
        part_classes=part_classes,
        parts=parts,
        part_class_suggested_parts=part_class_suggested_parts,
        bom_unit_options=BOM_UNIT_OPTIONS,
        bom_template_options=bom_template_options,
        bom_template_map=bom_template_map,
        package_input_values=package_input_values,
        bom_package_spec_summary=bom_package_spec_summary,
        pending_spec_requests_by_line=pending_spec_requests_by_line,
        latest_spec_requests_by_line=latest_spec_requests_by_line,
        related_drawing_sites=related_drawing_sites,
        can_edit_bom=can_edit_bom,
        is_design_user=is_design_user,
        is_purchase_user=is_purchase_user,
        can_link_project=can_link_project,
        project_options=project_options,
        drawing_site_options=drawing_site_options,
        stage_options=stage_options,
        default_stage=default_stage,
        drawing_type_options=drawing_type_options,
        drawing_status_options=drawing_status_options,
        task_status_options=task_status_options,
        drawings_by_type=drawings_by_type,
        latest_revisions=latest_revisions,
        users=users,
    )


@app.route("/notifications")
@login_required
def notifications_list():
    notifications = (
        Notification.query.filter_by(user_id=current_user.id)
        .order_by(Notification.created_at.desc())
        .all()
    )
    Notification.query.filter_by(user_id=current_user.id, is_read=False).update(
        {"is_read": True}
    )
    db.session.commit()
    return render_template("notifications_list.html", notifications=notifications)


@app.route("/notifications/mark-read", methods=["POST"])
@login_required
def mark_notifications_read():
    Notification.query.filter_by(user_id=current_user.id, is_read=False).update(
        {"is_read": True}
    )
    db.session.commit()
    return jsonify({"status": "ok"})


@app.route("/design/drawing-history")
@login_required
def design_drawing_history():
    ensure_bootstrap()
    query = DrawingSite.query.filter(
        func.lower(func.trim(func.coalesce(DrawingSite.approval_status, ""))).in_(
            tuple(COMPLETED_DRAWING_STATUSES)
        )
    )

    project_no = (request.args.get("project_no") or "").strip()
    client_name = (request.args.get("client_name") or "").strip()
    site_location = (request.args.get("site_location") or "").strip()

    if project_no:
        query = query.filter(DrawingSite.project_no.ilike(f"%{project_no}%"))
    if client_name:
        query = query.filter(DrawingSite.client_name.ilike(f"%{client_name}%"))
    if site_location:
        query = query.filter(DrawingSite.site_location.ilike(f"%{site_location}%"))

    page = max(int(request.args.get("page", 1) or 1), 1)
    per_page = 20
    total_records = query.count()
    total_pages = max(1, math.ceil(total_records / per_page)) if total_records else 1
    sites = (
        query.order_by(DrawingSite.last_updated.desc().nullslast())
        .offset((page - 1) * per_page)
        .limit(per_page)
        .all()
    )

    for site in sites:
        _sync_drawing_history_for_site(site)
    db.session.commit()

    return render_template(
        "design_drawing_history.html",
        sites=sites,
        filters={
            "project_no": project_no,
            "client_name": client_name,
            "site_location": site_location,
        },
        page=page,
        total_pages=total_pages,
        total_records=total_records,
        per_page=per_page,
        required_headers=sorted(DRAWING_REQUIRED_HEADERS),
    )


@app.route("/design/drawing-history/<int:site_id>")
@login_required
def design_drawing_history_detail(site_id: int):
    ensure_bootstrap()
    site = DrawingSite.query.get_or_404(site_id)
    if not _is_completed_drawing_status(site.approval_status):
        flash("Only approved or finalized drawings appear in history.", "warning")
        return redirect(url_for("design_drawing_history"))

    _sync_drawing_history_for_site(site)
    db.session.commit()

    versions = sorted(
        [
            version
            for version in (site.versions or [])
            if _is_completed_drawing_status(version.approval_status)
        ],
        key=lambda v: (
            v.approved_date or v.created_at or datetime.datetime.min,
            v.id or 0,
        ),
        reverse=True,
    )

    return render_template(
        "design_drawing_history_detail.html",
        site=site,
        versions=versions,
    )


@app.route("/design/drawing-history/upload", methods=["POST"])
@login_required
def design_drawing_history_upload():
    ensure_bootstrap()

    def _render_result(result: DrawingHistoryUploadResult):
        return render_template(
            "drawing_history_upload_result.html",
            processed_rows=result.processed_rows,
            created_count=result.created_count,
            updated_count=result.updated_count,
            row_errors=result.row_errors,
            fatal_error=result.fatal_error,
        )

    upload = request.files.get("drawing_history_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        return _render_result(
            DrawingHistoryUploadResult(
                fatal_error=str(exc),
            )
        )

    result = process_drawing_history_upload(upload)
    return _render_result(result)


@app.route("/design/bom-templates", methods=["GET", "POST"])
@login_required
def design_bom_templates():
    _module_visibility_required("design")
    if request.method == "POST":
        action = (request.form.get("action") or "").strip()
        if action == "create_template":
            name = (request.form.get("name") or "").strip()
            lift_type = (request.form.get("lift_type") or "").strip()
            description = (request.form.get("description") or "").strip() or None
            if not name:
                flash("Template name is required.", "error")
            elif lift_type not in LIFT_TYPES:
                flash("Select a valid lift type.", "error")
            else:
                template = BomTemplate(
                    name=name,
                    lift_type=lift_type,
                    description=description,
                    is_active=True,
                    created_by_id=current_user.id,
                )
                db.session.add(template)
                db.session.commit()
                flash("Template created.", "success")
                return redirect(url_for("design_bom_template_edit", template_id=template.id))
        elif action == "toggle_template":
            template_id = request.form.get("template_id")
            template = BomTemplate.query.get_or_404(template_id)
            template.is_active = not bool(template.is_active)
            db.session.commit()
            flash("Template updated.", "success")
        elif action == "duplicate_template":
            template_id = request.form.get("template_id")
            template = BomTemplate.query.get_or_404(template_id)
            new_template = BomTemplate(
                name=f"{template.name} (Copy)",
                lift_type=template.lift_type,
                description=template.description,
                is_active=template.is_active,
                created_by_id=current_user.id,
            )
            db.session.add(new_template)
            db.session.flush()
            for stage in template.stages:
                new_stage = BomTemplateStage(
                    template_id=new_template.id,
                    stage_name=stage.stage_name,
                    display_order=stage.display_order,
                )
                db.session.add(new_stage)
                db.session.flush()
                for section in stage.sections:
                    new_section = BomTemplateSection(
                        stage_id=new_stage.id,
                        section_name=section.section_name,
                        include_if_expr=section.include_if_expr,
                        display_order=section.display_order,
                    )
                    db.session.add(new_section)
                    db.session.flush()
                    for line in section.lines:
                        new_line = BomTemplateLine(
                            section_id=new_section.id,
                            ref_key=line.ref_key,
                            part_class_id=line.part_class_id,
                            specification_text=line.specification_text,
                            unit=line.unit,
                            include_if_expr=line.include_if_expr,
                            qty_expr=line.qty_expr,
                            override_if_expr=line.override_if_expr,
                            override_qty_expr=line.override_qty_expr,
                            display_order=line.display_order,
                        )
                        db.session.add(new_line)
            for template_input in template.inputs:
                new_input = BomTemplateInput(
                    template_id=new_template.id,
                    input_key=template_input.input_key,
                    label=template_input.label,
                    unit=template_input.unit,
                    default_value=template_input.default_value,
                    data_type=template_input.data_type,
                    required=template_input.required,
                )
                db.session.add(new_input)
            db.session.commit()
            flash("Template duplicated.", "success")
            return redirect(url_for("design_bom_template_edit", template_id=new_template.id))
        elif action == "create_part_class":
            name = (request.form.get("part_class_name") or "").strip()
            description = (request.form.get("part_class_description") or "").strip() or None
            if not name:
                flash("Part Class name is required.", "error")
            elif PartClass.query.filter(func.lower(PartClass.name) == name.lower()).first():
                flash("Part Class name must be unique.", "error")
            else:
                part_class = PartClass(name=name, description=description, active=True)
                db.session.add(part_class)
                db.session.commit()
                flash("Part Class created.", "success")
        elif action == "toggle_part_class":
            part_class_id = request.form.get("part_class_id")
            part_class = PartClass.query.get_or_404(part_class_id)
            part_class.active = not bool(part_class.active)
            db.session.commit()
            flash("Part Class updated.", "success")

    lift_filter = (request.args.get("lift_type") or "").strip()
    query = BomTemplate.query
    if lift_filter:
        query = query.filter(BomTemplate.lift_type == lift_filter)
    templates = query.order_by(BomTemplate.name.asc()).all()
    status_map = {}
    for template in templates:
        evaluation = evaluate_bom_template(template)
        has_errors = any(err.get("type") != "input" for err in evaluation["errors"])
        for line in evaluation["lines"]:
            if line["errors"]:
                has_errors = True
        status_map[template.id] = "Has Errors" if has_errors else "OK"

    part_classes = PartClass.query.order_by(
        PartClass.sort_order.asc(),
        PartClass.name.asc(),
    ).all()
    return render_template(
        "bom_templates.html",
        templates=templates,
        status_map=status_map,
        lift_filter=lift_filter,
        LIFT_TYPES=LIFT_TYPES,
        part_classes=part_classes,
    )


@app.route("/part_classes", methods=["GET"])
@login_required
def part_classes():
    _module_visibility_required("design")
    part_classes = PartClass.query.order_by(
        PartClass.sort_order.asc(),
        PartClass.name.asc(),
    ).all()
    part_class_section_map = {
        part_class.id: _parse_associated_sections(part_class.associated_sections)
        for part_class in part_classes
    }
    parts = (
        Product.query.filter(Product.is_active.is_(True))
        .order_by(Product.name.asc())
        .all()
    )
    parts_lookup = {part.id: part for part in parts}
    primary_part_labels = {
        part_class.id: _product_option_label(parts_lookup.get(part_class.primary_part_id))
        if part_class.primary_part_id
        else None
        for part_class in part_classes
    }
    section_rows = (
        db.session.query(BomTemplateSection, BomTemplateStage, BomTemplate)
        .join(BomTemplateStage, BomTemplateSection.stage_id == BomTemplateStage.id)
        .join(BomTemplate, BomTemplateStage.template_id == BomTemplate.id)
        .order_by(
            BomTemplate.name.asc(),
            BomTemplateStage.display_order.asc(),
            BomTemplateSection.display_order.asc(),
            BomTemplateSection.section_name.asc(),
        )
        .all()
    )
    sections = [
        {
            "id": section.id,
            "label": f"{template.name} / {stage.stage_name} / {section.section_name}",
        }
        for section, stage, template in section_rows
    ]
    return render_template(
        "part_classes.html",
        part_classes=part_classes,
        part_class_section_map=part_class_section_map,
        primary_part_labels=primary_part_labels,
        sections=sections,
        parts=parts,
    )


@app.route("/api/part_classes/<int:class_id>", methods=["GET"])
@login_required
def get_part_class(class_id):
    _module_visibility_required("design")
    part_class = PartClass.query.get_or_404(class_id)
    return jsonify(_part_class_payload(part_class))


@app.route("/api/part_classes/<int:class_id>/update", methods=["POST"])
@login_required
def update_part_class(class_id):
    _module_visibility_required("design")
    part_class = PartClass.query.get_or_404(class_id)
    payload = request.get_json(silent=True) or {}
    name = (payload.get("name") or "").strip()
    description = (payload.get("description") or "").strip() or None
    is_active = _parse_bool_payload(payload.get("is_active"), default=part_class.active)
    associated_sections = part_class.associated_sections
    if "associated_sections" in payload:
        associated_sections = _serialize_associated_sections(
            payload.get("associated_sections")
        )
    primary_part_id = part_class.primary_part_id
    if "primary_part_id" in payload:
        primary_part_id = _parse_optional_int(payload.get("primary_part_id"))
    sort_order_raw = payload.get("sort_order")
    try:
        sort_order = int(sort_order_raw or 0)
    except (TypeError, ValueError):
        sort_order = 0

    if not name or len(name) < 2:
        return jsonify({"error": "Class name must be at least 2 characters."}), 400
    if _part_class_name_exists(name, exclude_id=part_class.id):
        return jsonify({"error": "Part Class name must be unique."}), 400

    if primary_part_id and not Product.query.get(primary_part_id):
        return jsonify({"error": "Selected primary part was not found."}), 400

    part_class.name = name
    part_class.description = description
    part_class.active = is_active
    part_class.sort_order = sort_order
    part_class.associated_sections = associated_sections
    part_class.primary_part_id = primary_part_id
    db.session.commit()
    return jsonify(_part_class_payload(part_class))


@app.route("/api/part_classes/create", methods=["POST"])
@login_required
def create_part_class_api():
    _module_visibility_required("design")
    payload = request.get_json(silent=True) or {}
    name = (payload.get("name") or "").strip()
    description = (payload.get("description") or "").strip() or None
    associated_sections = _serialize_associated_sections(payload.get("associated_sections"))
    primary_part_id = _parse_optional_int(payload.get("primary_part_id"))
    sort_order_raw = payload.get("sort_order")
    try:
        sort_order = int(sort_order_raw or 0)
    except (TypeError, ValueError):
        sort_order = 0

    if not name or len(name) < 2:
        return jsonify({"error": "Class name must be at least 2 characters."}), 400
    if _part_class_name_exists(name):
        return jsonify({"error": "Part Class name must be unique."}), 400
    if primary_part_id and not Product.query.get(primary_part_id):
        return jsonify({"error": "Selected primary part was not found."}), 400

    part_class = PartClass(
        name=name,
        description=description,
        active=True,
        sort_order=sort_order,
        associated_sections=associated_sections,
        primary_part_id=primary_part_id,
    )
    db.session.add(part_class)
    db.session.commit()
    return jsonify(_part_class_payload(part_class))


@app.route("/api/part_classes/<int:class_id>/disable", methods=["POST"])
@login_required
def disable_part_class(class_id):
    _module_visibility_required("design")
    part_class = PartClass.query.get_or_404(class_id)
    part_class.active = False
    db.session.commit()
    return jsonify(_part_class_payload(part_class))


@app.route("/design/bom-templates/<int:template_id>", methods=["GET", "POST"])
@login_required
def design_bom_template_edit(template_id):
    _module_visibility_required("design")
    template = (
        BomTemplate.query.options(
            joinedload(BomTemplate.inputs),
            joinedload(BomTemplate.stages)
            .joinedload(BomTemplateStage.sections)
            .joinedload(BomTemplateSection.lines)
            .joinedload(BomTemplateLine.part_class),
        )
        .get_or_404(template_id)
    )
    evaluation = None
    test_input_values = {}
    if request.method == "POST":
        action = (request.form.get("action") or "").strip()
        if action == "update_template":
            name = (request.form.get("name") or "").strip()
            lift_type = (request.form.get("lift_type") or "").strip()
            description = (request.form.get("description") or "").strip() or None
            is_active = bool(request.form.get("is_active"))
            if not name:
                flash("Template name is required.", "error")
            elif lift_type not in LIFT_TYPES:
                flash("Select a valid lift type.", "error")
            else:
                template.name = name
                template.lift_type = lift_type
                template.description = description
                template.is_active = is_active
                db.session.commit()
                flash("Template updated.", "success")
        elif action == "add_input":
            input_key = (request.form.get("input_key") or "").strip()
            label = (request.form.get("label") or "").strip()
            unit = (request.form.get("unit") or "").strip() or None
            default_value = (request.form.get("default_value") or "").strip() or None
            data_type = (request.form.get("data_type") or "number").strip()
            required = bool(request.form.get("required"))
            if not input_key or not label:
                flash("Input key and label are required.", "error")
            elif data_type not in BOM_INPUT_DATA_TYPES:
                flash("Select a valid data type.", "error")
            else:
                new_input = BomTemplateInput(
                    template_id=template.id,
                    input_key=input_key,
                    label=label,
                    unit=unit,
                    default_value=default_value,
                    data_type=data_type,
                    required=required,
                )
                db.session.add(new_input)
                db.session.commit()
                flash("Input added.", "success")
        elif action == "update_input":
            input_id = request.form.get("input_id")
            template_input = BomTemplateInput.query.get_or_404(input_id)
            if template_input.template_id != template.id:
                abort(404)
            template_input.input_key = (request.form.get("input_key") or "").strip()
            template_input.label = (request.form.get("label") or "").strip()
            template_input.unit = (request.form.get("unit") or "").strip() or None
            template_input.default_value = (request.form.get("default_value") or "").strip() or None
            template_input.data_type = (request.form.get("data_type") or "number").strip()
            template_input.required = bool(request.form.get("required"))
            db.session.commit()
            flash("Input updated.", "success")
        elif action == "delete_input":
            input_id = request.form.get("input_id")
            template_input = BomTemplateInput.query.get_or_404(input_id)
            if template_input.template_id != template.id:
                abort(404)
            db.session.delete(template_input)
            db.session.commit()
            flash("Input deleted.", "info")
        elif action == "add_stage":
            stage_name = (request.form.get("stage_name") or "").strip()
            display_order = int(request.form.get("display_order") or 0)
            if not stage_name:
                flash("Stage name is required.", "error")
            else:
                stage = BomTemplateStage(
                    template_id=template.id,
                    stage_name=stage_name,
                    display_order=display_order,
                )
                db.session.add(stage)
                db.session.commit()
                flash("Stage added.", "success")
        elif action == "update_stage":
            stage_id = request.form.get("stage_id")
            stage = BomTemplateStage.query.get_or_404(stage_id)
            if stage.template_id != template.id:
                abort(404)
            stage.stage_name = (request.form.get("stage_name") or "").strip()
            stage.display_order = int(request.form.get("display_order") or 0)
            db.session.commit()
            flash("Stage updated.", "success")
        elif action == "delete_stage":
            stage_id = request.form.get("stage_id")
            stage = BomTemplateStage.query.get_or_404(stage_id)
            if stage.template_id != template.id:
                abort(404)
            db.session.delete(stage)
            db.session.commit()
            flash("Stage deleted.", "info")
        elif action == "add_section":
            stage_id = request.form.get("stage_id")
            section_name = (request.form.get("section_name") or "").strip()
            include_if_expr = (request.form.get("include_if_expr") or "").strip() or None
            display_order = int(request.form.get("display_order") or 0)
            stage = BomTemplateStage.query.get_or_404(stage_id)
            if stage.template_id != template.id:
                abort(404)
            if not section_name:
                flash("Section name is required.", "error")
            else:
                section = BomTemplateSection(
                    stage_id=stage.id,
                    section_name=section_name,
                    include_if_expr=include_if_expr,
                    display_order=display_order,
                )
                db.session.add(section)
                db.session.commit()
                flash("Section added.", "success")
        elif action == "update_section":
            section_id = request.form.get("section_id")
            section = BomTemplateSection.query.get_or_404(section_id)
            if section.stage.template_id != template.id:
                abort(404)
            section.section_name = (request.form.get("section_name") or "").strip()
            section.include_if_expr = (request.form.get("include_if_expr") or "").strip() or None
            section.display_order = int(request.form.get("display_order") or 0)
            db.session.commit()
            flash("Section updated.", "success")
        elif action == "delete_section":
            section_id = request.form.get("section_id")
            section = BomTemplateSection.query.get_or_404(section_id)
            if section.stage.template_id != template.id:
                abort(404)
            db.session.delete(section)
            db.session.commit()
            flash("Section deleted.", "info")
        elif action == "add_line":
            section_id = request.form.get("section_id")
            section = BomTemplateSection.query.get_or_404(section_id)
            if section.stage.template_id != template.id:
                abort(404)
            ref_key = (request.form.get("ref_key") or "").strip()
            part_class_id = request.form.get("part_class_id")
            specification_text = (request.form.get("specification_text") or "").strip() or None
            unit = (request.form.get("unit") or "").strip()
            include_if_expr = (request.form.get("include_if_expr") or "").strip() or None
            qty_expr = (request.form.get("qty_expr") or "").strip()
            override_if_expr = (request.form.get("override_if_expr") or "").strip() or None
            override_qty_expr = (request.form.get("override_qty_expr") or "").strip() or None
            display_order = int(request.form.get("display_order") or 0)
            if not unit or not qty_expr or not part_class_id:
                flash("Part class, unit, and qty expression are required.", "error")
            else:
                if not ref_key:
                    existing_ref_keys = {
                        (line.ref_key or "").strip()
                        for stage in template.stages
                        for sec in stage.sections
                        for line in sec.lines
                        if (line.ref_key or "").strip()
                    }
                    part_class = PartClass.query.get(part_class_id)
                    base_value = (
                        (part_class.name if part_class else None)
                        or specification_text
                        or "item"
                    )
                    ref_key = _generate_unique_ref_key(base_value, existing_ref_keys)
                line = BomTemplateLine(
                    section_id=section.id,
                    ref_key=ref_key,
                    part_class_id=part_class_id,
                    specification_text=specification_text,
                    unit=unit,
                    include_if_expr=include_if_expr,
                    qty_expr=qty_expr,
                    override_if_expr=override_if_expr,
                    override_qty_expr=override_qty_expr,
                    display_order=display_order,
                )
                db.session.add(line)
                db.session.commit()
                flash("Line added.", "success")
        elif action == "update_line":
            line_id = request.form.get("line_id")
            line = BomTemplateLine.query.get_or_404(line_id)
            if line.section.stage.template_id != template.id:
                abort(404)
            submitted_ref_key = (request.form.get("ref_key") or "").strip()
            if submitted_ref_key:
                line.ref_key = submitted_ref_key
            line.part_class_id = request.form.get("part_class_id")
            line.specification_text = (request.form.get("specification_text") or "").strip() or None
            line.unit = (request.form.get("unit") or "").strip()
            line.include_if_expr = (request.form.get("include_if_expr") or "").strip() or None
            line.qty_expr = (request.form.get("qty_expr") or "").strip()
            line.override_if_expr = (request.form.get("override_if_expr") or "").strip() or None
            line.override_qty_expr = (request.form.get("override_qty_expr") or "").strip() or None
            line.display_order = int(request.form.get("display_order") or 0)
            db.session.commit()
            flash("Line updated.", "success")
        elif action == "delete_line":
            line_id = request.form.get("line_id")
            line = BomTemplateLine.query.get_or_404(line_id)
            if line.section.stage.template_id != template.id:
                abort(404)
            db.session.delete(line)
            db.session.commit()
            flash("Line deleted.", "info")
        elif action == "save_stage_order":
            for key, value in request.form.items():
                if not key.startswith("stage_order_"):
                    continue
                stage_id = key.replace("stage_order_", "")
                stage = BomTemplateStage.query.get(stage_id)
                if stage and stage.template_id == template.id:
                    stage.display_order = int(value or 0)
            db.session.commit()
            flash("Stage order saved.", "success")
        elif action == "save_section_order":
            for key, value in request.form.items():
                if not key.startswith("section_order_"):
                    continue
                section_id = key.replace("section_order_", "")
                section = BomTemplateSection.query.get(section_id)
                if section and section.stage.template_id == template.id:
                    section.display_order = int(value or 0)
            db.session.commit()
            flash("Section order saved.", "success")
        elif action == "save_line_order":
            for key, value in request.form.items():
                if not key.startswith("line_order_"):
                    continue
                line_id = key.replace("line_order_", "")
                line = BomTemplateLine.query.get(line_id)
                if line and line.section.stage.template_id == template.id:
                    line.display_order = int(value or 0)
            db.session.commit()
            flash("Line order saved.", "success")
        elif action == "test_inputs":
            input_values = {
                key.replace("test_input_", ""): value
                for key, value in request.form.items()
                if key.startswith("test_input_")
            }
            test_input_values = dict(input_values)
            evaluation = evaluate_bom_template(template, input_values)
        if action != "test_inputs":
            return redirect(url_for("design_bom_template_edit", template_id=template.id))

    part_classes = (
        PartClass.query.filter(PartClass.active.is_(True))
        .order_by(PartClass.sort_order.asc(), PartClass.name.asc())
        .all()
    )
    part_class_sections = [
        {
            "id": part_class.id,
            "associated_sections": _parse_associated_sections(
                part_class.associated_sections
            ),
        }
        for part_class in part_classes
    ]
    input_keys = [
        {
            "key": template_input.input_key,
            "label": template_input.label or "",
        }
        for template_input in template.inputs
        if template_input.input_key
    ]
    line_keys = []
    for stage in sorted(template.stages, key=lambda item: item.display_order or 0):
        for section in sorted(stage.sections, key=lambda item: item.display_order or 0):
            for line in sorted(section.lines, key=lambda item: item.display_order or 0):
                if not line.ref_key:
                    continue
                line_keys.append(
                    {
                        "ref_key": line.ref_key,
                        "specification_text": line.specification_text or "",
                        "unit": line.unit or "",
                        "part_class": line.part_class.name if line.part_class else "",
                        "section": section.section_name or "",
                        "stage": stage.stage_name or "",
                    }
                )
    if evaluation is None:
        evaluation = evaluate_bom_template(template)
    section_includes = evaluation.get("section_includes") if evaluation else {}
    return render_template(
        "bom_template_editor.html",
        template=template,
        part_classes=part_classes,
        part_class_sections=part_class_sections,
        LIFT_TYPES=LIFT_TYPES,
        BOM_INPUT_DATA_TYPES=BOM_INPUT_DATA_TYPES,
        evaluation=evaluation,
        input_keys=input_keys,
        line_keys=line_keys,
        section_includes=section_includes,
        test_input_values=test_input_values,
    )


def _parse_date_field(raw_value: str):
    raw_value = (raw_value or "").strip()
    if not raw_value:
        return None
    try:
        return datetime.datetime.strptime(raw_value, "%Y-%m-%d")
    except ValueError:
        return None


COMPLETED_DRAWING_STATUSES = {"approved", "finalized"}


def _is_completed_drawing_status(status_value: str) -> bool:
    return clean_str(status_value).lower() in COMPLETED_DRAWING_STATUSES


def _log_drawing_status_change(
    *,
    old_status: Optional[str],
    new_status: Optional[str],
    drawing_site_id: Optional[int] = None,
    drawing_id: Optional[int] = None,
    remark: Optional[str] = None,
):
    normalized_old = clean_str(old_status)
    normalized_new = clean_str(new_status)
    if not normalized_new or normalized_old == normalized_new:
        return

    db.session.add(
        DrawingStatusLog(
            drawing_site_id=drawing_site_id,
            drawing_id=drawing_id,
            old_status=normalized_old or None,
            new_status=normalized_new,
            changed_by_user_id=(current_user.id if current_user else None),
            changed_at=datetime.datetime.utcnow(),
            remark=(remark.strip() if isinstance(remark, str) and remark.strip() else None),
        )
    )


def _sync_drawing_history_for_site(site: DrawingSite):
    if not site:
        return

    for version in site.versions or []:
        if not _is_completed_drawing_status(version.approval_status):
            continue

        history = (
            DrawingHistory.query.filter(
                DrawingHistory.project_no == site.project_no,
                DrawingHistory.drg_number == version.drawing_number,
                DrawingHistory.rev_no == version.revision_no,
            )
            .order_by(DrawingHistory.id.asc())
            .first()
        )

        if not history:
            history = DrawingHistory(
                project_no=site.project_no,
                drg_number=version.drawing_number,
                rev_no=version.revision_no,
            )
            db.session.add(history)

        history.client_name = site.client_name
        history.site_location = site.site_location
        history.lift_type = site.lift_type
        history.drg_approval = version.approval_status or site.approval_status
        history.remarks = version.revision_reason
        history.is_active = True


@app.route("/design/drawing-site/<int:site_id>", methods=["GET", "POST"])
@login_required
def design_drawing_site_detail(site_id: int):
    ensure_bootstrap()
    site = DrawingSite.query.get_or_404(site_id)
    role = (current_user.role or "").lower()
    can_edit_bom = current_user.is_admin or any(
        keyword in role for keyword in ["design", "purchase", "project", "installation"]
    )
    stage_options = _get_active_procurement_stages()
    default_stage = _get_default_procurement_stage()

    main_bom = _get_or_create_drawing_site_main_bom(site)
    db.session.commit()

    site_boms = (
        BillOfMaterials.query.filter(BillOfMaterials.drawing_site_id == site.id)
        .order_by(BillOfMaterials.created_at.asc().nullsfirst(), BillOfMaterials.id.asc())
        .all()
    )
    for existing_bom in site_boms:
        existing_bom.bom_type = _normalize_bom_type(existing_bom.bom_type)

    selected_bom_type = _normalize_bom_type(request.args.get("bom_type"), default=BOM_TYPE_MAIN)
    bom = next(
        (
            entry
            for entry in site_boms
            if _normalize_bom_type(entry.bom_type) == selected_bom_type
        ),
        None,
    )
    if not bom:
        selected_bom_type = BOM_TYPE_MAIN
        bom = main_bom

    bom_summaries = []
    for entry in site_boms:
        item_count = len(entry.items) if entry.items else 0
        bom_summaries.append(
            {
                "id": entry.id,
                "type": _normalize_bom_type(entry.bom_type),
                "label": BOM_TYPE_LABELS.get(_normalize_bom_type(entry.bom_type), "Main").title(),
                "name": entry.bom_name,
                "status": entry.status,
                "created_at": entry.created_at,
                "item_count": item_count,
            }
        )

    bom_item_count = len(bom.items) if bom and bom.items else 0
    bom_stage_summary = []
    if bom and bom.items:
        stage_counter = Counter()
        for item in bom.items:
            stage_name = None
            if item.procurement_stage:
                stage_name = item.procurement_stage.name
            elif default_stage:
                stage_name = default_stage.name
            stage_counter[stage_name or "Unassigned"] += 1
        bom_stage_summary = [
            {"name": name, "count": count} for name, count in stage_counter.items()
        ]

    task_filters = []
    if site.project_id:
        task_filters.append(DesignTask.project_id == site.project_id)
    if site.project_no:
        task_filters.append(DesignTask.project_name.ilike(f"%{site.project_no}%"))
    if site.site_location:
        task_filters.append(DesignTask.origin_reference.ilike(f"%{site.site_location}%"))
    if site.lift_identifier:
        task_filters.append(DesignTask.origin_reference.ilike(f"%{site.lift_identifier}%"))

    related_tasks = (
        DesignTask.query.filter(or_(*task_filters)).order_by(DesignTask.created_at.desc()).all()
        if task_filters
        else []
    )
    design_users = User.query.order_by(User.first_name, User.username).all()

    if request.method == "POST":
        action = request.form.get("action")
        if action == "new_version":
            drawing_number = (request.form.get("drawing_number") or "").strip()
            revision_no = (request.form.get("revision_no") or "").strip() or None
            approval_status = (request.form.get("approval_status") or "").strip()
            revision_reason = (request.form.get("revision_reason") or "").strip()
            submitted_date = _parse_date_field(request.form.get("submitted_date"))
            approved_date = _parse_date_field(request.form.get("approved_date"))

            if not drawing_number:
                flash("Please provide a drawing number for this version.", "danger")
                return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

            file = request.files.get("version_file")
            if not file or not file.filename:
                flash("Upload a drawing file to create a new version.", "danger")
                return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

            fname = secure_filename(f"{uuid.uuid4().hex}_{file.filename}")
            save_path = os.path.join(app.config["UPLOAD_FOLDER"], fname)
            os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)
            file.save(save_path)
            file_path = os.path.join("uploads", fname)

            version = (
                DrawingVersion.query.filter(
                    DrawingVersion.drawing_site_id == site.id,
                    DrawingVersion.drawing_number == drawing_number,
                    DrawingVersion.revision_no == revision_no,
                ).first()
            )

            created_now = False
            if not version:
                version = DrawingVersion(
                    drawing_site_id=site.id,
                    drawing_number=drawing_number,
                    revision_no=revision_no,
                )
                db.session.add(version)
                created_now = True
                try:
                    site.versions.append(version)
                except Exception:
                    pass

            previous_version_status = version.approval_status

            if file_path:
                version.file_path = file_path
            version.approval_status = approval_status or version.approval_status
            version.revision_reason = revision_reason or version.revision_reason
            version.submitted_date = submitted_date or version.submitted_date
            version.approved_date = approved_date or version.approved_date
            version.created_by_user_id = (
                version.created_by_user_id
                or (current_user.id if current_user else None)
            )
            version.created_at = version.created_at or datetime.datetime.utcnow()

            previous_completion_state = _is_completed_drawing_status(previous_version_status)
            previous_site_status = site.approval_status

            site.latest_drawing_number = drawing_number or site.latest_drawing_number
            site.latest_revision = revision_no or site.latest_revision
            site.approval_status = approval_status or site.approval_status
            site.last_updated = datetime.datetime.utcnow()
            site.apply_latest_version()

            _log_drawing_status_change(
                old_status=previous_site_status,
                new_status=site.approval_status,
                drawing_site_id=site.id,
                remark=revision_reason,
            )

            if _is_completed_drawing_status(version.approval_status) and not previous_completion_state:
                _sync_drawing_history_for_site(site)
            elif _is_completed_drawing_status(site.approval_status):
                _sync_drawing_history_for_site(site)

            db.session.commit()
            flash(
                "Drawing version saved." if created_now else "Drawing version updated.",
                "success",
            )
            return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

        if action == "comment":
            body = (request.form.get("body") or "").strip()
            version_id_raw = request.form.get("drawing_version_id")
            version_id = int(version_id_raw) if version_id_raw else None
            if not body:
                flash("Please enter a comment before posting.", "danger")
            else:
                db.session.add(
                    DrawingComment(
                        drawing_site_id=site.id,
                        drawing_version_id=version_id,
                        body=body,
                        author_id=current_user.id,
                    )
                )
                db.session.commit()
                flash("Comment added.", "success")
            return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

        if action == "create_bom_type":
            requested_type = _normalize_bom_type(request.form.get("bom_type"), default=None)
            if requested_type not in {"fabrication", "civil", "supplementary"}:
                flash("Select a valid BOM type.", "danger")
                return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

            existing = (
                BillOfMaterials.query.filter(
                    BillOfMaterials.drawing_site_id == site.id,
                    func.coalesce(BillOfMaterials.bom_type, BOM_TYPE_MAIN) == requested_type,
                )
                .order_by(BillOfMaterials.id.asc())
                .first()
            )
            if existing:
                flash(f"{BOM_TYPE_LABELS.get(requested_type, requested_type.title())} BOM already exists for this site", "warning")
                return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=requested_type))

            created_bom = BillOfMaterials(
                bom_name=f"{BOM_TYPE_LABELS[requested_type]} BOM - {site.project_no or site.client_name or 'Site'}",
                bom_type=requested_type,
                status="draft",
                drawing_site_id=site.id,
                project_id=site.project_id,
                created_by_user_id=current_user.id,
            )
            db.session.add(created_bom)
            db.session.flush()
            _get_or_create_default_bom_package(created_bom)
            db.session.commit()
            flash(f"{BOM_TYPE_LABELS[requested_type]} BOM created for this site.", "success")
            return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=requested_type))

        if action == "bom_item" and bom:
            package = _get_or_create_default_bom_package(bom)
            item = BOMItem(
                bom_id=bom.id,
                bom_package_id=package.id,
                item_code=request.form.get("item_code"),
                description=(request.form.get("specification") or "").strip() or None,
                category=(request.form.get("section_title") or "").strip() or None,
                stage=(request.form.get("stage") or "").strip() or None,
                section_title=(request.form.get("section_title") or "").strip() or None,
                specification=(request.form.get("specification") or "").strip() or None,
                unit=request.form.get("unit"),
                quantity_required=float(request.form.get("quantity_required") or 0),
                stage_id=(default_stage.id if default_stage else None),
                remarks=request.form.get("remarks"),
                is_generated=False,
            )
            if _bom_line_spec_required(item) and not (item.specification or "").strip():
                flash("Specification is required for this BOM line.", "danger")
                return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))
            db.session.add(item)
            db.session.commit()
            flash("BOM item added.", "success")
            return redirect(url_for("design_drawing_site_detail", site_id=site.id, bom_type=selected_bom_type))

    versions = sorted(
        site.versions or [],
        key=lambda v: (v.created_at or datetime.datetime.min, v.id or 0),
        reverse=True,
    )
    comments = sorted(
        site.comments or [],
        key=lambda c: c.created_at or datetime.datetime.min,
        reverse=True,
    )
    status_logs = (
        DrawingStatusLog.query.filter(DrawingStatusLog.drawing_site_id == site.id)
        .order_by(DrawingStatusLog.changed_at.desc(), DrawingStatusLog.id.desc())
        .all()
    )

    project_options = (
        Project.query.order_by(Project.created_at.desc().nullslast()).limit(100).all()
    )
    drawing_site_options = (
        DrawingSite.query.order_by(DrawingSite.last_updated.desc().nullslast())
        .limit(100)
        .all()
    )

    return render_template(
        "design_drawing_site_detail.html",
        site=site,
        versions=versions,
        comments=comments,
        status_logs=status_logs,
        bom=bom,
        bom_item_count=bom_item_count,
        bom_stage_summary=bom_stage_summary,
        bom_summaries=bom_summaries,
        selected_bom_type=selected_bom_type,
        related_tasks=related_tasks,
        can_edit_bom=can_edit_bom,
        stage_options=stage_options,
        default_stage=default_stage,
        project_options=project_options,
        drawing_site_options=drawing_site_options,
        design_users=design_users,
        available_bom_types=["fabrication", "civil", "supplementary"],
        bom_type_labels=BOM_TYPE_LABELS,
    )


@app.route("/bom/<int:bom_id>/duplicate", methods=["POST"])

@login_required
def duplicate_bom(bom_id: int):
    ensure_bootstrap()
    source_bom = BillOfMaterials.query.get_or_404(bom_id)

    role = (current_user.role or "").lower()
    can_edit_bom = current_user.is_admin or any(
        keyword in role for keyword in ["design", "purchase", "project", "installation"]
    )
    if not can_edit_bom:
        abort(403)

    target_reference = (request.form.get("target_reference") or "").strip()
    lift_identifier = (request.form.get("target_lift_identifier") or "").strip()
    new_bom_name = (request.form.get("new_bom_name") or "").strip()
    redirect_url = request.form.get("redirect_url")

    if not target_reference or ":" not in target_reference:
        flash("Please select a target project or site for duplication.", "danger")
        return redirect(redirect_url or request.referrer or url_for("design_tasks"))

    target_type, target_id_value = target_reference.split(":", 1)
    try:
        target_id = int(target_id_value)
    except ValueError:
        flash("Invalid target selected for duplication.", "danger")
        return redirect(redirect_url or request.referrer or url_for("design_tasks"))

    target_project_id = None
    target_drawing_site_id = None
    target_label = "Selected location"

    if target_type == "drawing_site":
        target_site = DrawingSite.query.get(target_id)
        if not target_site:
            flash("Target drawing site not found.", "danger")
            return redirect(redirect_url or request.referrer or url_for("design_tasks"))
        target_drawing_site_id = target_site.id
        target_project_id = target_site.project_id or None
        target_label = (
            target_site.project_no
            or target_site.client_name
            or target_site.site_location
            or f"Site #{target_site.id}"
        )
    elif target_type == "project":
        target_project = Project.query.get(target_id)
        if not target_project:
            flash("Target project not found.", "danger")
            return redirect(redirect_url or request.referrer or url_for("design_tasks"))
        target_project_id = target_project.id
        target_label = target_project.name or f"Project #{target_project.id}"
    else:
        flash("Unsupported target type for duplication.", "danger")
        return redirect(redirect_url or request.referrer or url_for("design_tasks"))

    bom_name = new_bom_name or f"{source_bom.bom_name} (Copy)"
    if lift_identifier and not new_bom_name:
        bom_name = f"{bom_name} - {lift_identifier}"

    new_bom = BillOfMaterials(
        bom_name=bom_name,
        status=source_bom.status,
        project_id=target_project_id,
        design_task_id=None,
        drawing_site_id=target_drawing_site_id,
        bom_type=_normalize_bom_type(source_bom.bom_type),
        created_by_user_id=current_user.id,
    )

    try:
        db.session.add(new_bom)
        db.session.flush()

        source_packages = source_bom.packages or []
        if not source_packages:
            source_packages = [_get_or_create_default_bom_package(source_bom)]
        package_id_map = {}
        for package in source_packages:
            new_package = BOMPackage(
                bom_id=new_bom.id,
                name=package.name,
                status=package.status,
                bom_template_id=package.bom_template_id,
                input_snapshot_json=package.input_snapshot_json,
                generated_at=package.generated_at,
                generated_by_user_id=package.generated_by_user_id,
                created_at=datetime.datetime.utcnow(),
            )
            db.session.add(new_package)
            db.session.flush()
            package_id_map[package.id] = new_package.id

        default_new_package_id = next(iter(package_id_map.values()), None)
        for item in source_bom.items:
            db.session.add(
                BOMItem(
                    bom_id=new_bom.id,
                    bom_package_id=package_id_map.get(
                        item.bom_package_id, default_new_package_id
                    ),
                    part_class_id=item.part_class_id,
                    item_code=item.item_code,
                    description=item.description,
                    category=item.category,
                    stage=item.stage,
                    section_title=item.section_title,
                    specification=item.specification,
                    unit=item.unit,
                    quantity_required=item.quantity_required,
                    stage_id=item.stage_id,
                    remarks=item.remarks,
                    source_template_line_id=item.source_template_line_id,
                    source_ref_key=item.source_ref_key,
                    is_generated=bool(item.is_generated),
                )
            )

        db.session.commit()
    except Exception:
        db.session.rollback()
        current_app.logger.exception("Failed to duplicate BOM")
        flash("Could not duplicate BOM. Please try again.", "danger")
        return redirect(redirect_url or request.referrer or url_for("design_tasks"))

    flash(f"BOM duplicated successfully to Project/Site: {target_label}", "success")

    if new_bom.drawing_site_id:
        return redirect(
            url_for("design_drawing_site_detail", site_id=new_bom.drawing_site_id)
        )
    if redirect_url:
        return redirect(redirect_url)
    if new_bom.project_id:
        return redirect(url_for("project_detail", project_id=new_bom.project_id))
    return redirect(request.referrer or url_for("design_tasks"))


@app.route("/purchase/bom-item/<int:item_id>/stage", methods=["POST"])
@login_required
def update_bom_item_stage(item_id: int):
    ensure_bootstrap()
    item = BOMItem.query.get_or_404(item_id)
    role = (current_user.role or "").lower()
    can_edit_bom = current_user.is_admin or any(
        keyword in role for keyword in ["design", "purchase", "project", "installation"]
    )
    if not can_edit_bom:
        abort(403)

    redirect_url = request.form.get("redirect_url") or request.referrer or url_for("design_tasks")
    stage_id_raw = request.form.get("stage_id") or None
    try:
        stage_id = int(stage_id_raw) if stage_id_raw else None
    except (TypeError, ValueError):
        stage_id = None

    stage = ProcurementStage.query.get(stage_id) if stage_id else None
    item.stage_id = stage.id if stage else None
    db.session.commit()

    if stage:
        flash(f"Stage updated to {stage.name}.", "success")
    else:
        flash("Stage cleared for this BOM line.", "info")
    return redirect(redirect_url)


def _resolve_drawing_revision_file_path(file_name: Optional[str]) -> Optional[str]:
    if not file_name:
        return None
    safe_name = os.path.basename(file_name)
    if not safe_name:
        return None
    return os.path.join(app.config["UPLOAD_FOLDER"], safe_name)


def _drawing_revision_download_name(revision: DesignDrawingRevision) -> str:
    drawing = revision.drawing
    drawing_name = (drawing.name if drawing and drawing.name else f"drawing_{revision.drawing_id}").strip()
    drawing_slug = secure_filename(drawing_name) or f"drawing_{revision.drawing_id}"
    extension = os.path.splitext(os.path.basename(revision.file_name or ""))[1]
    if extension and not re.fullmatch(r"\.[A-Za-z0-9]{1,12}", extension):
        extension = ""
    return f"{drawing_slug}_v{revision.version_number}{extension}"


@app.route("/design/drawings/<int:drawing_id>/download/latest")
@login_required
def download_latest_drawing_revision(drawing_id: int):
    drawing = DesignDrawing.query.get_or_404(drawing_id)
    latest_revision = (
        DesignDrawingRevision.query.filter_by(drawing_id=drawing.id)
        .order_by(DesignDrawingRevision.version_number.desc(), DesignDrawingRevision.id.desc())
        .first()
    )
    if not latest_revision:
        abort(404)

    file_path = _resolve_drawing_revision_file_path(latest_revision.file_name)
    if not file_path or not os.path.exists(file_path):
        abort(404)

    return send_file(
        file_path,
        as_attachment=True,
        download_name=_drawing_revision_download_name(latest_revision),
    )


@app.route("/design/drawings/revisions/<int:revision_id>/download")
@login_required
def download_drawing_revision(revision_id: int):
    revision = DesignDrawingRevision.query.options(joinedload(DesignDrawingRevision.drawing)).get_or_404(revision_id)
    file_path = _resolve_drawing_revision_file_path(revision.file_name)
    if not file_path or not os.path.exists(file_path):
        abort(404)

    return send_file(
        file_path,
        as_attachment=True,
        download_name=_drawing_revision_download_name(revision),
    )


@app.route("/purchase/orders", methods=["GET", "POST"])
@login_required
def purchase_orders():
    ensure_bootstrap()

    def _parse_int_value(value):
        try:
            return int(value) if value not in (None, "") else None
        except (TypeError, ValueError):
            return None

    def _build_po_line_payload_from_bom_item(bom_item):
        part_id = _parse_int_value(bom_item.suggested_part_id)
        item_label = (
            (bom_item.part_class.name if bom_item.part_class else None)
            or (bom_item.description or "").strip()
            or (bom_item.item_code or "").strip()
            or f"BOM Line {bom_item.id}"
        )
        specification = (bom_item.specification or "").strip()
        return {
            "product_id": part_id,
            "item_name": item_label,
            "specification": specification,
            "unit": (bom_item.unit or "").strip(),
            "quantity": float(bom_item.quantity_required or 0),
            "unit_price": None,
            "currency": "INR",
            "stage": (bom_item.stage or "").strip() or None,
            "section_title": (bom_item.section_title or "").strip() or None,
            "source_bom_id": bom_item.bom_id,
            "source_bom_line_id": bom_item.id,
            "specification_locked": True,
            "is_bom_line": True,
        }
    if request.method == "POST":
        po_number = request.form.get("po_number") or f"PO-{uuid.uuid4().hex[:6].upper()}"
        project_id = request.form.get("project_id") or None
        vendor_id = request.form.get("vendor_id") or None
        bom_id_raw = request.form.get("bom_id") or None
        po_date_raw = request.form.get("po_date") or request.form.get("order_date")
        expected_raw = request.form.get("expected_delivery") or request.form.get(
            "expected_delivery_date"
        )
        notes = request.form.get("notes")
        try:
            po_date = (
                datetime.datetime.strptime(po_date_raw, "%Y-%m-%d").date()
                if po_date_raw
                else None
            )
        except ValueError:
            po_date = None
        try:
            expected_delivery_date = (
                datetime.datetime.strptime(expected_raw, "%Y-%m-%d").date()
                if expected_raw
                else None
            )
        except ValueError:
            expected_delivery_date = None
        if not po_date:
            po_date = date.today()
        if not expected_delivery_date:
            expected_delivery_date = po_date + datetime.timedelta(days=15)

        po = PurchaseOrder(
            po_number=po_number,
            project_id=project_id,
            vendor_id=vendor_id,
            bom_id=int(bom_id_raw) if bom_id_raw else None,
            status="draft",
            po_date=po_date,
            order_date=po_date,
            expected_delivery=expected_delivery_date,
            expected_delivery_date=expected_delivery_date,
            created_by_user_id=current_user.id,
            notes=notes,
            origin="erp",
        )
        db.session.add(po)
        if vendor_id:
            try:
                vendor_id_int = int(vendor_id)
            except (TypeError, ValueError):
                vendor_id_int = None
            if vendor_id_int:
                vendor_record = Vendor.query.get(vendor_id_int)
                if vendor_record:
                    vendor_record.last_used_at = datetime.datetime.utcnow()
        db.session.flush()

        item_product_ids = request.form.getlist("item_product_id[]") or request.form.getlist(
            "item_product_id"
        )
        item_names = request.form.getlist("item_name[]") or request.form.getlist(
            "item_name"
        )
        item_specs = request.form.getlist("item_specs[]") or request.form.getlist(
            "item_specs"
        )
        item_units = request.form.getlist("item_unit[]") or request.form.getlist(
            "item_unit"
        )
        item_qtys = request.form.getlist("item_qty[]") or request.form.getlist(
            "item_qty"
        )
        item_unit_prices = request.form.getlist("item_unit_price[]") or request.form.getlist(
            "item_unit_price"
        )
        item_currencies = request.form.getlist("item_currency[]") or request.form.getlist(
            "item_currency"
        )
        item_stages = request.form.getlist("item_stage[]") or request.form.getlist(
            "item_stage"
        )
        item_sections = request.form.getlist("item_section_title[]") or request.form.getlist(
            "item_section_title"
        )
        item_source_bom_ids = request.form.getlist("item_source_bom_id[]") or request.form.getlist(
            "item_source_bom_id"
        )
        item_source_bom_line_ids = request.form.getlist(
            "item_source_bom_line_id[]"
        ) or request.form.getlist("item_source_bom_line_id")
        item_spec_locks = request.form.getlist("item_spec_locked[]") or request.form.getlist(
            "item_spec_locked"
        )

        bom_apply_mode = (request.form.get("bom_apply_mode") or "").strip().lower()
        combined_rows = []

        has_valid_items = False
        invalid_rows = False
        subtotal_amount = 0.0

        row_count = max(
            len(item_product_ids),
            len(item_names),
            len(item_specs),
            len(item_units),
            len(item_qtys),
            len(item_unit_prices),
            len(item_currencies),
            len(item_stages),
            len(item_sections),
            len(item_source_bom_ids),
            len(item_source_bom_line_ids),
            len(item_spec_locks),
        )

        for idx in range(row_count):
            item_name = (item_names[idx] if idx < len(item_names) else "").strip()
            product_id_raw = (item_product_ids[idx] if idx < len(item_product_ids) else "").strip()
            specs = (item_specs[idx] if idx < len(item_specs) else "").strip()
            unit = (item_units[idx] if idx < len(item_units) else "").strip()
            quantity_raw = item_qtys[idx] if idx < len(item_qtys) else ""
            unit_price_raw = item_unit_prices[idx] if idx < len(item_unit_prices) else ""
            currency = (
                (item_currencies[idx] if idx < len(item_currencies) else "").strip()
                or "INR"
            )
            stage_value = (item_stages[idx] if idx < len(item_stages) else "").strip()
            section_title = (item_sections[idx] if idx < len(item_sections) else "").strip()
            source_bom_id = _parse_int_value(
                item_source_bom_ids[idx] if idx < len(item_source_bom_ids) else None
            )
            source_bom_line_id = _parse_int_value(
                item_source_bom_line_ids[idx] if idx < len(item_source_bom_line_ids) else None
            )
            spec_locked_flag = (
                (item_spec_locks[idx] if idx < len(item_spec_locks) else "").strip().lower()
                in {"1", "true", "yes"}
            )

            if (
                not item_name
                and not specs
                and not unit
                and not quantity_raw
                and not unit_price_raw
            ):
                continue

            try:
                quantity = float(quantity_raw or 0)
            except (TypeError, ValueError):
                quantity = 0

            unit_price = None
            if unit_price_raw not in (None, ""):
                try:
                    unit_price = float(unit_price_raw)
                except (TypeError, ValueError):
                    unit_price = None

            combined_rows.append(
                {
                    "item_name": item_name,
                    "product_id": _parse_int_value(product_id_raw),
                    "specification": specs,
                    "unit": unit,
                    "quantity": quantity,
                    "unit_price": unit_price,
                    "currency": currency,
                    "stage": stage_value or None,
                    "section_title": section_title or None,
                    "source_bom_id": source_bom_id,
                    "source_bom_line_id": source_bom_line_id,
                    "specification_locked": spec_locked_flag,
                }
            )

        if bom_id_raw and bom_apply_mode in {"replace", "add"}:
            bom_items = (
                BOMItem.query.options(joinedload(BOMItem.part_class))
                .filter(BOMItem.bom_id == int(bom_id_raw))
                .order_by(BOMItem.id.asc())
                .all()
            )
            mapped_rows = [
                _build_po_line_payload_from_bom_item(bom_item)
                for bom_item in bom_items
                if (bom_item.quantity_required or 0) > 0
            ]
            if bom_apply_mode == "replace":
                combined_rows = mapped_rows
            else:
                combined_rows.extend(mapped_rows)

        for row_data in combined_rows:
            item_name = (row_data.get("item_name") or "").strip()
            product_id = _parse_int_value(row_data.get("product_id"))
            specs = (row_data.get("specification") or "").strip()
            unit = (row_data.get("unit") or "").strip()
            quantity = float(row_data.get("quantity") or 0)
            unit_price = row_data.get("unit_price")
            currency = (row_data.get("currency") or "INR").strip() or "INR"

            if not item_name or quantity <= 0:
                invalid_rows = True
                continue

            if specs and not product_id and (row_data.get("source_bom_line_id") or row_data.get("specification_locked")):
                invalid_rows = True
                continue

            line_total = quantity * unit_price if unit_price is not None else None
            if unit_price is not None:
                subtotal_amount += line_total

            product_record = Product.query.get(product_id) if product_id else None
            if product_record and not item_name:
                item_name = product_record.name
            item_code = None
            if product_record and product_id:
                item_code = _ensure_product_sku(product_record) or f"PROD-{product_id}"
            poi = PurchaseOrderItem(
                purchase_order_id=po.id,
                bom_item_id=_parse_int_value(row_data.get("source_bom_line_id")),
                product_id=product_id,
                part_id=product_id,
                part_name=item_name,
                item_code=item_code,
                description=item_name or None,
                specification=specs or None,
                specification_locked=bool(row_data.get("specification_locked")),
                unit=unit or None,
                quantity_ordered=quantity,
                unit_price=unit_price,
                total_amount=line_total,
                currency=currency,
                stage=row_data.get("stage") or None,
                section_title=row_data.get("section_title") or None,
                source_bom_id=_parse_int_value(row_data.get("source_bom_id")),
                source_bom_line_id=_parse_int_value(row_data.get("source_bom_line_id")),
            )
            db.session.add(poi)
            has_valid_items = True

            if product_record and item_code:
                inv = InventoryItem.query.filter_by(item_code=item_code).first()
                if not inv:
                    inv = InventoryItem(
                        item_code=item_code,
                        description=product_record.name or specs or None,
                        unit=unit or product_record.purchase_uom or product_record.uom or None,
                    )
                    db.session.add(inv)
                _initialize_book_stock(inv)
                inv.book_stock = (inv.book_stock or inv.current_stock or 0) + quantity

                book = BookInventory.query.filter_by(item_code=item_code).first()
                if not book:
                    book = BookInventory(item_code=item_code)
                    db.session.add(book)
                book.quantity_ordered_total = (book.quantity_ordered_total or 0) + quantity
                book.last_po_id = po.id

        if not has_valid_items or invalid_rows:
            db.session.rollback()
            if not has_valid_items:
                flash("Add at least one valid line item before saving.", "danger")
            else:
                flash(
                    "Each line item needs part name, quantity, and mapped part when specification is provided.",
                    "danger",
                )
            return redirect(url_for("purchase_orders"))

        po.subtotal_amount = subtotal_amount
        po.grand_total_amount = subtotal_amount

        db.session.commit()
        flash("Purchase order saved.", "success")
        return redirect(url_for("purchase_orders"))

    pos = (
        PurchaseOrder.query.options(
            joinedload(PurchaseOrder.vendor),
            joinedload(PurchaseOrder.project),
            joinedload(PurchaseOrder.bom),
            subqueryload(PurchaseOrder.items),
        )
        .order_by(PurchaseOrder.id.desc())
        .all()
    )
    vendors = Vendor.query.order_by(Vendor.name).all()
    projects = Project.query.order_by(Project.name).all()
    bom_items = BOMItem.query.order_by(BOMItem.item_code).all()
    bom_options = (
        BillOfMaterials.query.order_by(BillOfMaterials.created_at.desc().nullslast())
        .limit(200)
        .all()
    )

    return render_template(
        "purchase_orders.html",
        pos=pos,
        vendors=vendors,
        projects=projects,
        bom_items=bom_items,
        bom_options=bom_options,
    )


@app.route("/purchase/bom/<int:bom_id>/po-lines-preview")
@login_required
def purchase_bom_po_lines_preview(bom_id: int):
    ensure_bootstrap()
    bom = BillOfMaterials.query.get_or_404(bom_id)
    bom_items = (
        BOMItem.query.options(joinedload(BOMItem.part_class))
        .filter(BOMItem.bom_id == bom.id)
        .order_by(BOMItem.id.asc())
        .all()
    )

    payload = []
    for bom_item in bom_items:
        qty_value = float(bom_item.quantity_required or 0)
        if qty_value <= 0:
            continue
        item_name = (
            (bom_item.part_class.name if bom_item.part_class else None)
            or (bom_item.description or "").strip()
            or (bom_item.item_code or "").strip()
            or f"BOM Line {bom_item.id}"
        )
        payload.append(
            {
                "source_bom_id": bom.id,
                "source_bom_line_id": bom_item.id,
                "part_id": bom_item.suggested_part_id,
                "item_name": item_name,
                "specification": (bom_item.specification or "").strip(),
                "qty": qty_value,
                "unit": (bom_item.unit or "").strip(),
                "stage": (bom_item.stage or "").strip(),
                "section_title": (bom_item.section_title or "").strip(),
            }
        )

    return jsonify({"bom_id": bom.id, "lines": payload})


@app.route("/purchase/vendor-rate")
@login_required
def purchase_vendor_rate():
    ensure_bootstrap()
    vendor_id_raw = request.args.get("vendor_id") or ""
    product_id_raw = request.args.get("product_id") or ""
    try:
        vendor_id = int(vendor_id_raw)
    except (TypeError, ValueError):
        vendor_id = None
    try:
        product_id = int(product_id_raw)
    except (TypeError, ValueError):
        product_id = None

    if not vendor_id or not product_id:
        return jsonify({"unit_price": None, "currency": "INR", "found": False})

    rate = VendorProductRate.query.filter_by(
        vendor_id=vendor_id, product_id=product_id
    ).first()
    if not rate or rate.unit_price is None:
        currency = rate.currency if rate and rate.currency else "INR"
        return jsonify({"unit_price": None, "currency": currency, "found": False})

    return jsonify(
        {
            "unit_price": float(rate.unit_price),
            "currency": rate.currency or "INR",
            "found": True,
        }
    )


@app.route("/api/parts/search")
@login_required
def parts_search():
    ensure_bootstrap()
    query = (request.args.get("q") or "").strip()
    limit_raw = request.args.get("limit") or "12"
    try:
        limit = max(1, min(int(limit_raw), 50))
    except (TypeError, ValueError):
        limit = 12

    if not query:
        return jsonify([])

    like = f"%{query.lower()}%"
    parts = (
        Product.query.filter(func.lower(Product.name).like(like))
        .order_by(Product.name.asc())
        .limit(limit)
        .all()
    )

    payload = []
    for part in parts:
        description = part.specifications or part.notes or ""
        unit = part.purchase_uom or part.uom or ""
        payload.append(
            {
                "id": part.id,
                "name": part.name,
                "description": description,
                "unit": unit,
                "sku": part.sku or "",
                "category": part.category or "",
            }
        )

    return jsonify(payload)


@app.route("/api/parts/create", methods=["POST"])
@login_required
def parts_create():
    ensure_bootstrap()
    payload = request.get_json(silent=True) or {}
    name = (payload.get("name") or "").strip()
    unit = (payload.get("unit") or "").strip()
    description = (payload.get("description") or "").strip()
    category = (payload.get("category") or "").strip()

    if len(name) < 2:
        return jsonify({"error": "Name must be at least 2 characters."}), 400
    if not category:
        return jsonify({"error": "Category is required."}), 400

    existing = Product.query.filter(func.lower(Product.name) == name.lower()).first()
    if existing:
        sku = _ensure_product_sku(existing)
        db.session.commit()
        return jsonify(
            {
                "id": existing.id,
                "name": existing.name,
                "unit": existing.purchase_uom or existing.uom or "",
                "description": existing.specifications or existing.notes or "",
                "sku": sku or "",
                "category": existing.category or "",
            }
        )

    product = Product(name=name, category=category)
    if unit:
        product.purchase_uom = unit
        if not product.uom:
            product.uom = unit
    if description:
        product.specifications = description
    db.session.add(product)
    db.session.flush()
    sku = _ensure_product_sku(product)
    db.session.commit()

    return jsonify(
        {
            "id": product.id,
            "name": product.name,
            "unit": product.purchase_uom or product.uom or "",
            "description": product.specifications or product.notes or "",
            "sku": sku or "",
            "category": product.category or "",
        }
    )


@app.route("/purchase/orders/<int:po_id>")
@login_required
def purchase_order_detail_view(po_id: int):
    ensure_bootstrap()
    po = (
        PurchaseOrder.query.options(
            joinedload(PurchaseOrder.vendor),
            joinedload(PurchaseOrder.project),
            joinedload(PurchaseOrder.bom),
            subqueryload(PurchaseOrder.items).joinedload(PurchaseOrderItem.bom_item),
        )
        .filter(PurchaseOrder.id == po_id)
        .first()
    )
    if not po:
        abort(404)

    vendor_issues = (
        VendorIssue.query.options(
            joinedload(VendorIssue.product),
            joinedload(VendorIssue.purchase_order),
        )
        .filter_by(po_id=po.id)
        .order_by(VendorIssue.created_at.desc())
        .all()
    )
    issue_products = []
    seen_products = set()
    po_line_request_map = {}
    for item in po.items or []:
        product_id = item.product_id or item.part_id
        if product_id and product_id not in seen_products:
            issue_products.append(
                {
                    "id": product_id,
                    "label": item.part_name or item.item_code or f"Item {item.id}",
                }
            )
            seen_products.add(product_id)

    if po.items:
        line_ids = [line.id for line in po.items]
        change_requests = (
            BOMSpecChangeRequest.query.filter(BOMSpecChangeRequest.po_line_id.in_(line_ids))
            .order_by(BOMSpecChangeRequest.requested_at.desc(), BOMSpecChangeRequest.id.desc())
            .all()
        )
        for req in change_requests:
            po_line_request_map.setdefault(req.po_line_id, req)

    return render_template(
        "purchase_order_detail.html",
        po=po,
        vendor_issues=vendor_issues,
        issue_products=issue_products,
        issue_type_options=VENDOR_ISSUE_TYPE_OPTIONS,
        po_line_request_map=po_line_request_map,
        po_has_out_of_sync_lines=any(bool(line.is_out_of_sync) for line in (po.items or [])),
        is_purchase_user=_is_purchase_user(current_user),
    )


@app.route("/purchase/orders/<int:po_id>/request-spec-change", methods=["POST"])
@login_required
def purchase_order_request_spec_change(po_id: int):
    ensure_bootstrap()
    if not _is_purchase_user(current_user):
        abort(403)

    po = PurchaseOrder.query.options(subqueryload(PurchaseOrder.items)).get_or_404(po_id)
    po_line_id = _parse_optional_int(request.form.get("po_line_id"))
    reason = (request.form.get("reason") or "").strip()
    suggested_alternative = (request.form.get("suggested_alternative") or "").strip() or None

    if not po_line_id:
        flash("Please select a PO line for spec change request.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    po_line = next((line for line in (po.items or []) if line.id == po_line_id), None)
    if not po_line:
        flash("PO line not found.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    bom_line_id = po_line.source_bom_line_id or po_line.bom_item_id
    if not bom_line_id:
        flash("This line is not linked to a BOM line. Spec change can be requested only for BOM-linked lines.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    if not reason:
        flash("Reason is required for spec change request.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    existing_pending = BOMSpecChangeRequest.query.filter_by(
        bom_line_id=bom_line_id,
        po_line_id=po_line.id,
        status="Pending",
    ).first()
    if existing_pending:
        flash("A pending spec change request already exists for this PO line.", "warning")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    request_entry = BOMSpecChangeRequest(
        bom_line_id=bom_line_id,
        po_line_id=po_line.id,
        requested_by=current_user.id,
        requested_at=datetime.datetime.utcnow(),
        reason=reason,
        suggested_alternative=suggested_alternative,
        status="Pending",
    )
    db.session.add(request_entry)
    db.session.commit()
    flash("Spec change request submitted to Design.", "success")
    return redirect(url_for("purchase_order_detail_view", po_id=po.id))


@app.route("/purchase/orders/<int:po_id>/issues", methods=["POST"])
@login_required
def purchase_order_issue_create(po_id: int):
    ensure_bootstrap()
    po = PurchaseOrder.query.options(joinedload(PurchaseOrder.vendor)).get_or_404(po_id)
    if not po.vendor_id:
        flash("Assign a vendor before logging an issue for this PO.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    product_id_raw = request.form.get("product_id") or None
    issue_type = _normalize_vendor_issue_type(request.form.get("issue_type"))
    description = (request.form.get("description") or "").strip()
    status = (request.form.get("status") or "").strip() or "Open"

    if not description:
        flash("Provide a description for the vendor issue.", "danger")
        return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    try:
        product_id = int(product_id_raw) if product_id_raw else None
    except (TypeError, ValueError):
        product_id = None

    product = Product.query.get(product_id) if product_id else None

    issue = VendorIssue(
        vendor_id=po.vendor_id,
        product_id=product.id if product else None,
        po_id=po.id,
        project_id=po.project_id,
        issue_type=issue_type,
        source="MANUAL",
        description=description,
        status=status,
        created_by=current_user.display_name,
    )
    db.session.add(issue)
    try:
        db.session.commit()
        flash("Vendor issue logged.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not log vendor issue right now.", "danger")

    return redirect(url_for("purchase_order_detail_view", po_id=po.id))


@app.route("/purchase/procurement-stages", methods=["GET", "POST"])
@login_required
def purchase_procurement_stages():
    ensure_bootstrap()

    if request.method == "POST":
        action = (request.form.get("action") or "create").strip().lower()
        name = (request.form.get("name") or "").strip()
        code = (request.form.get("code") or "").strip() or None
        sequence_raw = request.form.get("sequence") or None
        is_active = bool(request.form.get("is_active")) or action == "create"

        try:
            sequence_value = int(sequence_raw) if sequence_raw is not None else 10
        except (TypeError, ValueError):
            sequence_value = 10

        if action == "create":
            if not name:
                flash("Stage name is required.", "danger")
                return redirect(url_for("purchase_procurement_stages"))

            existing_code = None
            if code:
                existing_code = ProcurementStage.query.filter(
                    ProcurementStage.code == code
                ).first()
            if existing_code:
                flash("Code already in use for another stage.", "danger")
                return redirect(url_for("purchase_procurement_stages"))

            db.session.add(
                ProcurementStage(
                    name=name,
                    code=code,
                    sequence=sequence_value,
                    is_active=is_active,
                )
            )
            db.session.commit()
            flash("Procurement stage added.", "success")
            return redirect(url_for("purchase_procurement_stages"))

        if action in {"update", "deactivate"}:
            stage_id = request.form.get("stage_id")
            stage = ProcurementStage.query.get(stage_id)
            if not stage:
                flash("Stage not found.", "danger")
                return redirect(url_for("purchase_procurement_stages"))

            if action == "deactivate":
                stage.is_active = False
                db.session.commit()
                flash("Stage deactivated.", "info")
                return redirect(url_for("purchase_procurement_stages"))

            if not name:
                flash("Stage name is required.", "danger")
                return redirect(url_for("purchase_procurement_stages"))

            if code:
                conflict = (
                    ProcurementStage.query.filter(ProcurementStage.code == code)
                    .filter(ProcurementStage.id != stage.id)
                    .first()
                )
                if conflict:
                    flash("Code already in use for another stage.", "danger")
                    return redirect(url_for("purchase_procurement_stages"))

            stage.name = name
            stage.code = code
            stage.sequence = sequence_value
            stage.is_active = bool(request.form.get("is_active"))
            db.session.commit()
            flash("Stage updated.", "success")
            return redirect(url_for("purchase_procurement_stages"))

    stages = (
        ProcurementStage.query.order_by(
            ProcurementStage.sequence.asc(), ProcurementStage.name.asc()
        ).all()
    )
    return render_template("purchase_procurement_stages.html", stages=stages)


@app.route("/purchase/bom/<int:bom_id>/generate-po", methods=["GET", "POST"])
@login_required
def generate_po_from_bom(bom_id):
    ensure_bootstrap()
    bom = BillOfMaterials.query.get_or_404(bom_id)
    stage_options = _get_active_procurement_stages()
    default_stage = _get_default_procurement_stage()
    vendor_options = (
        Vendor.query.filter(Vendor.is_active.is_(True))
        .order_by(Vendor.name.asc())
        .all()
    )
    project_options = Project.query.order_by(Project.name.asc()).all()
    related_pos = (
        PurchaseOrder.query.options(
            joinedload(PurchaseOrder.vendor), joinedload(PurchaseOrder.stage)
        )
        .filter(PurchaseOrder.bom_id == bom.id)
        .order_by(PurchaseOrder.id.desc())
        .all()
    )

    selected_stage_id = request.values.get("stage_id") or (
        default_stage.id if default_stage else None
    )
    selected_vendor_id = request.values.get("vendor_id") or None
    project_id_value = request.values.get("project_id") or bom.project_id
    po_notes = request.values.get("po_notes") or None
    pending_only = request.values.get("pending_only") is not None
    allow_incomplete_spec = request.values.get("allow_incomplete_spec") is not None
    preview_items = None

    # Purchase flow guardrail: classified lines must have specifications unless the
    # user explicitly acknowledges an override.
    missing_spec_items = [
        item
        for item in bom.items
        if _bom_line_spec_required(item) and not (item.specification or "").strip()
    ]
    selected_stage_name = next(
        (
            stage.name
            for stage in stage_options
            if str(stage.id) == str(selected_stage_id)
        ),
        None,
    )
    if not selected_stage_name and selected_stage_id:
        stage_record = ProcurementStage.query.get(selected_stage_id)
        selected_stage_name = stage_record.name if stage_record else None

    def _stage_for_item(item: BOMItem):
        if item.stage_id:
            return item.stage_id
        return default_stage.id if default_stage else None

    def _procurement_stage_name(item: BOMItem):
        """Purchase screens must use procurement stage (stage_id), never template stage."""
        if item.procurement_stage:
            return item.procurement_stage.name
        if item.stage_id:
            stage_record = ProcurementStage.query.get(item.stage_id)
            if stage_record:
                return stage_record.name
        return default_stage.name if default_stage else "—"

    def _edit_spec_url(item: BOMItem):
        if bom.design_task_id:
            return url_for("design_task_detail", task_id=bom.design_task_id)
        if bom.drawing_site_id:
            return url_for("design_drawing_site_detail", site_id=bom.drawing_site_id)
        return None

    missing_spec_items_payload = [
        {
            "item": item,
            "item_code": item.item_code,
            "description": item.description or item.specification or "—",
            "section_label": item.section_title or item.category or "—",
            "edit_url": _edit_spec_url(item),
        }
        for item in missing_spec_items
    ]

    def _build_preview_items(target_stage_id, is_pending_only):
        rows = []
        for item in bom.items:
            item_stage_id = _stage_for_item(item)
            if target_stage_id and item_stage_id != target_stage_id:
                continue
            bom_qty = item.quantity_required or 0
            ordered_qty = 0
            if is_pending_only:
                book = BookInventory.query.filter_by(item_code=item.item_code).first()
                ordered_qty = book.quantity_ordered_total if book else 0
                suggested_qty = max(bom_qty - (ordered_qty or 0), 0)
                if suggested_qty <= 0:
                    continue
                quantity_to_order = suggested_qty
            else:
                quantity_to_order = bom_qty

            product = None
            if item.item_code:
                product = Product.query.filter(
                    func.lower(Product.name) == (item.item_code or "").lower()
                ).first()
            unit_price = product.cost if product else None
            rows.append(
                {
                    "item": item,
                    "bom_qty": bom_qty,
                    "ordered_qty": ordered_qty or 0,
                    "quantity_to_order": quantity_to_order,
                    "stage_name": _procurement_stage_name(item),
                    "unit_price": unit_price,
                }
            )
        return rows

    if request.method == "POST":
        step = (request.form.get("step") or "select").strip().lower()
        allow_incomplete_spec = request.form.get("allow_incomplete_spec") is not None

        if missing_spec_items and not allow_incomplete_spec:
            flash(
                "Specification is incomplete for one or more classified BOM items. Review the missing items below or tick override to proceed.",
                "danger",
            )
            if step == "confirm":
                selected_stage_id = request.form.get("stage_id") or None
                selected_vendor_id = request.form.get("vendor_id") or None
                project_id_value = request.form.get("project_id") or bom.project_id
                po_notes = request.form.get("po_notes") or None
                pending_only = request.form.get("pending_only") is not None
                try:
                    target_stage_id = int(selected_stage_id) if selected_stage_id else None
                except (TypeError, ValueError):
                    target_stage_id = None
                preview_items = _build_preview_items(target_stage_id, pending_only)
            step = "blocked"

        if step == "select":
            if not selected_stage_id:
                flash("Please select a procurement stage to continue.", "danger")
            elif not selected_vendor_id:
                flash("Please select a vendor for this purchase order.", "danger")
            else:
                try:
                    target_stage_id = int(selected_stage_id)
                except (TypeError, ValueError):
                    target_stage_id = None
                preview_items = _build_preview_items(target_stage_id, pending_only)

        elif step == "confirm":
            selected_stage_id = request.form.get("stage_id") or None
            selected_vendor_id = request.form.get("vendor_id") or None
            project_id_value = request.form.get("project_id") or bom.project_id
            po_notes = request.form.get("po_notes") or None
            pending_only = request.form.get("pending_only") is not None

            if not selected_stage_id or not selected_vendor_id:
                flash("Stage and vendor are required to create a purchase order.", "danger")
            else:
                try:
                    stage_id_int = int(selected_stage_id)
                except (TypeError, ValueError):
                    stage_id_int = None
                vendor_id_int = int(selected_vendor_id) if selected_vendor_id else None
                project_id_parsed = int(project_id_value) if project_id_value else None
                stage_record = ProcurementStage.query.get(stage_id_int) if stage_id_int else None
                vendor_record = Vendor.query.get(vendor_id_int) if vendor_id_int else None

                base_note = (
                    f"Generated from BOM {bom.bom_name} (ID {bom.id}) – Stage {stage_record.name if stage_record else 'N/A'}"
                )
                notes_combined = base_note
                if po_notes:
                    notes_combined = f"{base_note}\n\n{po_notes}" if base_note else po_notes

                po = PurchaseOrder(
                    po_number=f"PO-{uuid.uuid4().hex[:6].upper()}",
                    project_id=project_id_parsed,
                    vendor_id=vendor_id_int,
                    bom_id=bom.id,
                    stage_id=stage_id_int,
                    status="draft",
                    po_date=date.today(),
                    order_date=date.today(),
                    expected_delivery=date.today() + datetime.timedelta(days=15),
                    expected_delivery_date=date.today() + datetime.timedelta(days=15),
                    created_by_user_id=current_user.id,
                    notes=notes_combined,
                    origin="erp",
                )
                db.session.add(po)
                db.session.flush()

                item_ids = request.form.getlist("item_id")
                created_items = 0
                subtotal_amount = 0.0
                for item_id in item_ids:
                    try:
                        parsed_id = int(item_id)
                    except (TypeError, ValueError):
                        continue
                    bom_item = BOMItem.query.get(parsed_id)
                    if not bom_item or bom_item.bom_id != bom.id:
                        continue

                    qty_raw = request.form.get(f"quantity_to_order_{parsed_id}") or "0"
                    try:
                        qty_value = float(qty_raw)
                    except (TypeError, ValueError):
                        qty_value = 0
                    if qty_value <= 0:
                        continue

                    unit_price_raw = request.form.get(f"unit_price_{parsed_id}") or None
                    try:
                        unit_price = float(unit_price_raw) if unit_price_raw not in (None, "") else None
                    except (TypeError, ValueError):
                        unit_price = None
                    total_amount = qty_value * unit_price if unit_price is not None else None
                    if unit_price is not None:
                        subtotal_amount += total_amount

                    db.session.add(
                        PurchaseOrderItem(
                            purchase_order_id=po.id,
                            bom_item_id=bom_item.id,
                            part_name=bom_item.description or bom_item.item_code,
                            item_code=bom_item.item_code,
                            description=bom_item.description,
                            unit=bom_item.unit,
                            quantity_ordered=qty_value,
                            unit_price=unit_price,
                            total_amount=total_amount,
                        )
                    )

                    inv = InventoryItem.query.filter_by(item_code=bom_item.item_code).first()
                    if not inv:
                        inv = InventoryItem(
                            item_code=bom_item.item_code,
                            description=bom_item.description,
                            unit=bom_item.unit,
                        )
                        db.session.add(inv)
                    _initialize_book_stock(inv)
                    inv.book_stock = (inv.book_stock or inv.current_stock or 0) + qty_value

                    book = BookInventory.query.filter_by(item_code=bom_item.item_code).first()
                    if not book:
                        book = BookInventory(item_code=bom_item.item_code)
                        db.session.add(book)
                    book.quantity_ordered_total = (book.quantity_ordered_total or 0) + qty_value
                    book.last_po_id = po.id
                    created_items += 1

                if created_items == 0:
                    db.session.rollback()
                    flash("No line items were selected for ordering.", "danger")
                else:
                    po.subtotal_amount = subtotal_amount
                    po.grand_total_amount = subtotal_amount
                    if vendor_record:
                        vendor_record.last_used_at = datetime.datetime.utcnow()
                    db.session.commit()
                    # TODO: create_notification for purchase/design teams about PO creation from this BOM.
                    flash(
                        f"Purchase Order {po.po_number} created from BOM {bom.bom_name} – Stage {stage_record.name if stage_record else selected_stage_id} for vendor {vendor_record.name if vendor_record else selected_vendor_id}.",
                        "success",
                    )
                    return redirect(url_for("purchase_order_detail_view", po_id=po.id))

    return render_template(
        "purchase_generate_po_from_bom.html",
        bom=bom,
        stage_options=stage_options,
        vendor_options=vendor_options,
        project_options=project_options,
        selected_stage_id=str(selected_stage_id or ""),
        selected_vendor_id=str(selected_vendor_id or ""),
        project_id_value=project_id_value,
        po_notes=po_notes,
        pending_only=pending_only,
        allow_incomplete_spec=allow_incomplete_spec,
        missing_spec_items=missing_spec_items_payload,
        preview_items=preview_items,
        selected_stage_name=selected_stage_name,
        related_pos=related_pos,
    )


@app.route("/purchase/orders/upload-odoo", methods=["POST"])
@login_required
def purchase_orders_upload_odoo():
    ensure_bootstrap()

    if not _is_odoo_import_enabled():
        return render_template(
            "purchase_order_upload_result.html",
            processed_rows=0,
            created_count=0,
            updated_count=0,
            rows_with_errors=0,
            row_errors=[],
            fatal_error=(
                "Odoo PO import is disabled. All new POs must be created directly in Eleva ERP."
            ),
        )

    def _render_result(
        *,
        processed_rows=0,
        created_count=0,
        updated_count=0,
        rows_with_errors=0,
        row_errors=None,
        fatal_error=None,
    ):
        return render_template(
            "purchase_order_upload_result.html",
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            rows_with_errors=rows_with_errors,
            row_errors=row_errors or [],
            fatal_error=fatal_error,
        )

    upload = request.files.get("purchase_order_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        return _render_result(fatal_error=str(exc))

    try:
        header_cells, data_rows = _extract_tabular_upload(upload)
    except MissingDependencyError:
        return _render_result(fatal_error=OPENPYXL_MISSING_MESSAGE)
    except ValueError:
        return _render_result(
            fatal_error="Upload a .xlsx or .csv file exported from Odoo purchase orders.",
        )
    except UploadStageTimeoutError as exc:
        return _render_result(fatal_error=str(exc))
    except Exception:
        current_app.logger.exception("Failed to read uploaded purchase order file")
        return _render_result(
            fatal_error=(
                "There was a problem reading this Purchase Order file. Please check that you’re using the correct Odoo export and try again."
            )
        )

    required_headers = {
        "Billing Status",
        "Buyer",
        "Confirmation Date",
        "Expected Arrival",
        "Order Reference",
        "Priority",
        "Total",
        "Vendor",
        "Product",
    }

    header_map = {}
    for idx, header in enumerate(header_cells or []):
        label = stringify_cell(header)
        if label:
            header_map[label] = idx

    missing_headers = [label for label in required_headers if label not in header_map]
    if missing_headers:
        return _render_result(
            fatal_error=(
                "The uploaded sheet is missing required columns: "
                + ", ".join(sorted(missing_headers))
            )
        )

    processed_rows = 0
    created_count = 0
    updated_count = 0
    row_errors = []

    def _get_cell(row_values, position):
        return row_values[position] if position < len(row_values) else None

    def _parse_numeric(value, label):
        if value is None:
            return 0.0, None
        text_value = stringify_cell(value)
        if text_value is None or text_value == "":
            return 0.0, None
        try:
            return float(text_value), None
        except (TypeError, ValueError):
            try:
                cleaned = str(text_value).replace(",", "").replace("₹", "").strip()
                return float(cleaned), None
            except (TypeError, ValueError):
                return None, f"Invalid numeric {label}"

    def _parse_odoo_datetime(value, label):
        if value is None:
            return None, None
        if isinstance(value, datetime.datetime):
            return value, None
        if isinstance(value, datetime.date):
            return datetime.datetime.combine(value, datetime.time())
        text_value = stringify_cell(value)
        if text_value is None or text_value == "":
            return None, None
        for fmt in (
            "%Y-%m-%d %H:%M:%S",
            "%Y-%m-%d",
            "%d/%m/%Y %H:%M:%S",
            "%d/%m/%Y",
            "%m/%d/%Y %H:%M:%S",
            "%m/%d/%Y",
        ):
            try:
                return datetime.datetime.strptime(text_value, fmt), None
            except ValueError:
                continue
        return None, f"Could not parse {label}"

    for row_index, row_values in enumerate(data_rows or [], start=2):
        if not row_values:
            continue
        row_data = {}
        has_value = False
        for header, position in header_map.items():
            value = _get_cell(row_values, position)
            cell_value = stringify_cell(value)
            if cell_value not in (None, ""):
                has_value = True
            row_data[header] = value
        if not has_value:
            continue

        processed_rows += 1
        row_issue = []

        order_ref = clean_str(row_data.get("Order Reference"))
        vendor_name = clean_str(row_data.get("Vendor"))
        product_name = clean_str(row_data.get("Product"))
        billing_status = clean_str(row_data.get("Billing Status")) or None
        buyer = clean_str(row_data.get("Buyer")) or None
        priority_value = clean_str(row_data.get("Priority")) or None
        source_document = clean_str(row_data.get("Source Document")) or None

        confirmation_date, confirmation_error = _parse_odoo_datetime(
            row_data.get("Confirmation Date"), "Confirmation Date"
        )
        if confirmation_error:
            row_issue.append(confirmation_error)

        expected_arrival, arrival_error = _parse_odoo_datetime(
            row_data.get("Expected Arrival"), "Expected Arrival"
        )
        if arrival_error:
            row_issue.append(arrival_error)

        total_amount, total_error = _parse_numeric(row_data.get("Total"), "Total")
        if total_error:
            row_issue.append(total_error)

        if not order_ref:
            row_issue.append("Missing Order Reference")
        if not vendor_name:
            row_issue.append("Missing Vendor")
        if not product_name:
            row_issue.append("Missing Product")

        if row_issue:
            row_errors.append(f"Row {row_index}: " + "; ".join(row_issue))
            continue

        pol = (
            PurchaseOrderLine.query.filter_by(
                order_ref=order_ref,
                vendor_name=vendor_name,
                product_name=product_name,
                confirmation_date=confirmation_date,
            )
            .with_for_update(read=True)
            .first()
        )
        is_new = pol is None
        if is_new:
            pol = PurchaseOrderLine(
                order_ref=order_ref,
                vendor_name=vendor_name,
                product_name=product_name,
                confirmation_date=confirmation_date,
            )
            db.session.add(pol)
            created_count += 1
        else:
            updated_count += 1

        pol.order_ref = order_ref
        pol.vendor_name = vendor_name
        pol.product_name = product_name
        pol.confirmation_date = confirmation_date
        pol.billing_status = billing_status
        pol.buyer = buyer
        pol.expected_arrival = expected_arrival
        pol.priority = priority_value
        pol.source_document = source_document
        pol.total_amount = total_amount if total_amount is not None else 0
        pol.is_active = True if pol.is_active is None else pol.is_active
        if vendor_name:
            vendor_record = Vendor.query.filter(
                func.lower(Vendor.name) == vendor_name.lower()
            ).first()
            if vendor_record:
                vendor_record.last_used_at = datetime.datetime.utcnow()

    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        current_app.logger.exception(
            "Failed to save purchase order line upload changes"
        )
        return _render_result(
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            rows_with_errors=len(row_errors),
            row_errors=row_errors,
            fatal_error="Could not save purchase order lines due to a database error.",
        )

    return _render_result(
        processed_rows=processed_rows,
        created_count=created_count,
        updated_count=updated_count,
        rows_with_errors=len(row_errors),
        row_errors=row_errors,
    )


@app.route("/purchase/odoo-history")
@login_required
def purchase_odoo_history():
    ensure_bootstrap()
    order_ref = request.args.get("order_ref")
    vendor = request.args.get("vendor")
    product = request.args.get("product")
    start_date = request.args.get("start_date")
    end_date = request.args.get("end_date")

    query = PurchaseOrderLine.query.filter(PurchaseOrderLine.is_active.is_(True))
    if order_ref:
        query = query.filter(PurchaseOrderLine.order_ref.ilike(f"%{order_ref}%"))
    if vendor:
        query = query.filter(PurchaseOrderLine.vendor_name.ilike(f"%{vendor}%"))
    if product:
        query = query.filter(PurchaseOrderLine.product_name.ilike(f"%{product}%"))

    def _parse_filter_date(value: str):
        try:
            return datetime.datetime.strptime(value, "%Y-%m-%d").date()
        except (TypeError, ValueError):
            return None

    start_dt = _parse_filter_date(start_date)
    end_dt = _parse_filter_date(end_date)

    if start_dt:
        query = query.filter(
            PurchaseOrderLine.confirmation_date
            >= datetime.datetime.combine(start_dt, datetime.time.min)
        )
    if end_dt:
        query = query.filter(
            PurchaseOrderLine.confirmation_date
            <= datetime.datetime.combine(end_dt, datetime.time.max)
        )

    rows = (
        query.order_by(
            PurchaseOrderLine.confirmation_date.desc().nullslast(),
            PurchaseOrderLine.id.desc(),
        )
        .limit(500)
        .all()
    )

    return render_template(
        "purchase_odoo_history.html",
        rows=rows,
        order_ref_filter=order_ref or "",
        vendor_filter=vendor or "",
        product_filter=product or "",
        start_date=start_date or "",
        end_date=end_date or "",
        odoo_import_enabled=_is_odoo_import_enabled(),
        go_live_date=current_app.config.get("ERP_PO_GO_LIVE_DATE"),
    )


@app.route("/purchase/reports")
@login_required
def purchase_reports():
    ensure_bootstrap()
    item_code = request.args.get("item_code")
    vendor_id_raw = request.args.get("vendor_id")
    start_date = request.args.get("start_date")
    end_date = request.args.get("end_date")
    include_odoo = request.args.get("include_odoo") in {"1", "true", "on", "yes"}

    try:
        vendor_id = int(vendor_id_raw) if vendor_id_raw else None
    except (TypeError, ValueError):
        vendor_id = None

    history_query = (
        db.session.query(PurchaseOrderItem, PurchaseOrder, Vendor)
        .join(PurchaseOrder, PurchaseOrderItem.purchase_order_id == PurchaseOrder.id)
        .outerjoin(Vendor, PurchaseOrder.vendor_id == Vendor.id)
    )
    if item_code:
        history_query = history_query.filter(PurchaseOrderItem.item_code == item_code)
    if vendor_id:
        history_query = history_query.filter(PurchaseOrder.vendor_id == vendor_id)
    if start_date:
        try:
            start_dt = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
            history_query = history_query.filter(PurchaseOrder.order_date >= start_dt)
        except ValueError:
            start_dt = None
    else:
        start_dt = None
    if end_date:
        try:
            end_dt = datetime.datetime.strptime(end_date, "%Y-%m-%d").date()
            history_query = history_query.filter(PurchaseOrder.order_date <= end_dt)
        except ValueError:
            end_dt = None
    else:
        end_dt = None

    history_rows = history_query.order_by(PurchaseOrder.order_date).all()

    vendor_summary = (
        db.session.query(Vendor.name, func.sum(PurchaseOrderItem.total_amount))
        .join(PurchaseOrder, PurchaseOrderItem.purchase_order_id == PurchaseOrder.id)
        .join(Vendor, PurchaseOrder.vendor_id == Vendor.id)
        .group_by(Vendor.name)
        .all()
    )
    project_summary = (
        db.session.query(Project.name, func.sum(PurchaseOrderItem.total_amount))
        .join(PurchaseOrder, PurchaseOrderItem.purchase_order_id == PurchaseOrder.id)
        .join(Project, PurchaseOrder.project_id == Project.id)
        .group_by(Project.name)
        .all()
    )
    items = db.session.query(PurchaseOrderItem.item_code).distinct().all()
    vendors = Vendor.query.order_by(Vendor.name).all()

    combined_rows = [
        {
            "source": "ERP",
            "po_number": row.PurchaseOrder.po_number,
            "vendor": row.Vendor.name if row.Vendor else "—",
            "date": row.PurchaseOrder.order_date,
            "unit_price": row.PurchaseOrderItem.unit_price or 0,
        }
        for row in history_rows
    ]

    if include_odoo:
        odoo_query = PurchaseOrderLine.query.filter(PurchaseOrderLine.is_active.is_(True))
        if item_code:
            odoo_query = odoo_query.filter(
                PurchaseOrderLine.product_name.ilike(f"%{item_code}%")
            )
        if vendor_id:
            vendor_record = Vendor.query.get(vendor_id)
            if vendor_record and vendor_record.name:
                odoo_query = odoo_query.filter(
                    PurchaseOrderLine.vendor_name.ilike(
                        f"%{vendor_record.name}%"
                    )
                )
        if start_dt:
            odoo_query = odoo_query.filter(
                PurchaseOrderLine.confirmation_date
                >= datetime.datetime.combine(start_dt, datetime.time.min)
            )
        if end_dt:
            odoo_query = odoo_query.filter(
                PurchaseOrderLine.confirmation_date
                <= datetime.datetime.combine(end_dt, datetime.time.max)
            )

        odoo_rows = odoo_query.order_by(PurchaseOrderLine.confirmation_date).all()
        combined_rows.extend(
            [
                {
                    "source": "Odoo",
                    "po_number": row.order_ref,
                    "vendor": row.vendor_name,
                    "date": row.confirmation_date.date() if row.confirmation_date else None,
                    "unit_price": float(row.total_amount or 0),
                }
                for row in odoo_rows
            ]
        )

    combined_rows.sort(key=lambda row: (row["date"] or date.min, row["po_number"]))

    chart_label_keys = sorted(
        {row["date"].strftime("%Y-%m-%d") for row in combined_rows if row["date"]}
    )
    chart_labels = [
        datetime.datetime.strptime(label, "%Y-%m-%d").strftime("%d %b")
        for label in chart_label_keys
    ]

    def _series(source_name: str):
        grouped = defaultdict(list)
        for row in combined_rows:
            if row["source"] != source_name or not row["date"]:
                continue
            label = row["date"].strftime("%Y-%m-%d")
            grouped[label].append(row["unit_price"] or 0)
        return [
            sum(grouped.get(label, []) or [0]) / max(len(grouped.get(label, [])) or 1, 1)
            for label in chart_label_keys
        ]

    chart_datasets = [
        {
            "label": "ERP",
            "data": _series("ERP"),
            "borderColor": "#fb923c",
            "backgroundColor": "rgba(251, 146, 60, 0.15)",
            "tension": 0.35,
            "fill": True,
        }
    ]

    if include_odoo:
        chart_datasets.append(
            {
                "label": "Odoo",
                "data": _series("Odoo"),
                "borderColor": "#475569",
                "backgroundColor": "rgba(71, 85, 105, 0.15)",
                "tension": 0.35,
                "fill": True,
            }
        )

    return render_template(
        "purchase_reports.html",
        history_rows=combined_rows,
        vendor_summary=vendor_summary,
        project_summary=project_summary,
        items=items,
        vendors=vendors,
        selected_item=item_code,
        chart_labels=chart_labels,
        chart_datasets=chart_datasets,
        include_odoo=include_odoo,
    )


@app.route("/purchase/parts", methods=["GET"])
@login_required
def purchase_parts():
    ensure_bootstrap()
    records = Product.query.order_by(Product.name).all()
    vendors = Vendor.query.order_by(Vendor.name).all()

    return render_template(
        "purchase_parts.html",
        products=records,
        vendors=vendors,
    )


@app.route("/purchase/parts/<int:product_id>", methods=["GET"])
@login_required
def purchase_part_detail(product_id):
    ensure_bootstrap()
    product = Product.query.get_or_404(product_id)
    vendors = Vendor.query.order_by(Vendor.name).all()
    vendor_names = []
    if product.primary_vendor:
        vendor_names.append(product.primary_vendor)
    linked_names = [
        name.strip()
        for name in (product.linked_vendors or "").split(",")
        if name.strip()
    ]
    vendor_names.extend([name for name in linked_names if name not in vendor_names])
    vendor_records = (
        Vendor.query.filter(Vendor.name.in_(vendor_names)).all() if vendor_names else []
    )
    vendor_by_name = {vendor.name: vendor for vendor in vendor_records}
    vendor_ids = [vendor.id for vendor in vendor_records]
    rate_rows = []
    rate_lookup = {}
    if vendor_ids:
        for rate in VendorProductRate.query.filter(
            VendorProductRate.product_id == product.id,
            VendorProductRate.vendor_id.in_(vendor_ids),
        ).all():
            rate_lookup[rate.vendor_id] = rate
    for name in vendor_names:
        vendor = vendor_by_name.get(name)
        rate = rate_lookup.get(vendor.id) if vendor else None
        rate_rows.append(
            {
                "vendor": vendor,
                "vendor_name": name,
                "vendor_type": "Primary" if name == product.primary_vendor else "Linked",
                "rate": rate,
            }
        )

    history_rows = (
        VendorProductRateHistory.query.filter_by(product_id=product.id)
        .order_by(VendorProductRateHistory.changed_at.desc())
        .all()
    )
    recent_history = history_rows[:10]
    return render_template(
        "purchase_part_detail.html",
        product=product,
        vendors=vendors,
        vendor_rates=rate_rows,
        recent_rate_history=recent_history,
        all_rate_history=history_rows,
    )


@app.route("/products", methods=["GET"])
@login_required
def products():
    return redirect(url_for("purchase_parts"))


@app.route("/purchase/parts/<int:product_id>/update", methods=["POST"])
@login_required
def purchase_parts_update(product_id):
    ensure_bootstrap()

    product = Product.query.get_or_404(product_id)
    name = (request.form.get("name") or "").strip()
    primary_vendor = (request.form.get("primary_vendor") or "").strip() or None
    linked_vendors = (request.form.get("linked_vendors") or "").strip() or None
    specifications = (request.form.get("specifications") or "").strip() or None
    notes = (request.form.get("notes") or "").strip() or None

    sale_price, sale_error = parse_float_field(
        request.form.get("sale_price"), "Sale price"
    )
    cost, cost_error = parse_float_field(request.form.get("cost"), "Cost")
    qty_on_hand, stock_error = parse_float_field(
        request.form.get("qty_on_hand"), "Qty on hand"
    )
    forecast_qty, forecast_error = parse_float_field(
        request.form.get("forecast_qty"), "Forecast Qty"
    )

    errors = [
        message
        for message in [sale_error, cost_error, stock_error, forecast_error]
        if message
    ]

    if not name:
        errors.append("Part name is required.")

    if errors:
        for message in errors:
            flash(message, "danger")
        return redirect(url_for("purchase_part_detail", product_id=product.id))

    product.name = name
    product.sale_price = sale_price
    product.cost = cost
    product.uom = (request.form.get("uom") or "").strip() or None
    product.purchase_uom = (request.form.get("purchase_uom") or "").strip() or None
    product.qty_on_hand = qty_on_hand or 0
    product.forecast_qty = forecast_qty or 0
    product.is_favorite = request.form.get("is_favorite") == "on"
    product.is_active = request.form.get("is_active") == "on"
    product.primary_vendor = primary_vendor
    product.linked_vendors = linked_vendors
    product.specifications = specifications
    product.notes = notes

    try:
        db.session.commit()
        flash("Part details updated.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not update part details right now.", "danger")

    return redirect(url_for("purchase_part_detail", product_id=product.id))


@app.route("/purchase/parts/<int:product_id>/vendor-rate", methods=["POST"])
@login_required
def purchase_part_rate_update(product_id):
    ensure_bootstrap()
    product = Product.query.get_or_404(product_id)
    vendor_id_raw = request.form.get("vendor_id")
    vendor_part_name = (request.form.get("vendor_part_name") or "").strip() or None
    currency = (request.form.get("currency") or "INR").strip() or "INR"
    note = (request.form.get("note") or "").strip() or None

    unit_price, price_error = parse_float_field(request.form.get("unit_price"), "Unit price")
    if price_error:
        flash(price_error, "danger")
        return redirect(url_for("purchase_part_detail", product_id=product.id))

    try:
        vendor_id = int(vendor_id_raw)
    except (TypeError, ValueError):
        flash("Select a valid vendor for this part.", "danger")
        return redirect(url_for("purchase_part_detail", product_id=product.id))

    allowed_vendor_names = []
    if product.primary_vendor:
        allowed_vendor_names.append(product.primary_vendor)
    allowed_vendor_names.extend(
        [
            name.strip()
            for name in (product.linked_vendors or "").split(",")
            if name.strip()
        ]
    )
    allowed_vendors = (
        Vendor.query.filter(Vendor.name.in_(allowed_vendor_names)).all()
        if allowed_vendor_names
        else []
    )
    allowed_vendor_ids = {vendor.id for vendor in allowed_vendors}
    if vendor_id not in allowed_vendor_ids:
        flash("Vendor is not linked to this part.", "danger")
        return redirect(url_for("purchase_part_detail", product_id=product.id))

    rate = VendorProductRate.query.filter_by(
        vendor_id=vendor_id, product_id=product.id
    ).first()
    old_unit_price = rate.unit_price if rate else None
    price_changed = old_unit_price != unit_price

    if not rate:
        rate = VendorProductRate(vendor_id=vendor_id, product_id=product.id)
        db.session.add(rate)

    rate.unit_price = unit_price
    rate.currency = currency
    rate.vendor_part_name = vendor_part_name
    rate.updated_by = current_user.display_name

    if price_changed:
        history = VendorProductRateHistory(
            vendor_id=vendor_id,
            product_id=product.id,
            old_unit_price=old_unit_price,
            new_unit_price=unit_price,
            currency=currency,
            note=note,
            changed_by=current_user.display_name,
        )
        db.session.add(history)

    try:
        db.session.commit()
        flash("Vendor rate updated.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not update vendor rate right now.", "danger")

    return redirect(url_for("purchase_part_detail", product_id=product.id))


@app.route("/products/upload", methods=["POST"])
@login_required
def products_upload():
    ensure_bootstrap()

    def _render_result(
        *,
        processed_rows=0,
        created_count=0,
        updated_count=0,
        row_errors=None,
        fatal_error=None,
    ):
        return render_template(
            "product_upload_result.html",
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            row_errors=row_errors or [],
            fatal_error=fatal_error,
        )

    upload = request.files.get("product_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        return _render_result(fatal_error=str(exc))

    try:
        header_cells, data_rows = _extract_tabular_upload(upload)
    except MissingDependencyError:
        return _render_result(fatal_error=OPENPYXL_MISSING_MESSAGE)
    except ValueError:
        return _render_result(
            fatal_error="Upload a .xlsx or .csv file exported from Odoo products.",
        )
    except UploadStageTimeoutError as exc:
        return _render_result(fatal_error=str(exc))
    except Exception:
        current_app.logger.exception("Failed to read uploaded product file")
        return _render_result(
            fatal_error=(
                "There was a problem reading this file, please check the format and try again."
            )
        )

    required_headers = {
        "Name",
        "Sales Price",
        "Cost",
        "Unit of Measure",
        "Purchase Unit",
        "Quantity On Hand",
    }

    header_map = {}
    for idx, header in enumerate(header_cells or []):
        label = stringify_cell(header)
        if label:
            header_map[label] = idx

    missing_headers = [label for label in required_headers if label not in header_map]
    if missing_headers:
        return _render_result(
            fatal_error=(
                "The uploaded sheet is missing required columns: "
                + ", ".join(sorted(missing_headers))
            )
        )

    processed_rows = 0
    created_count = 0
    updated_count = 0
    row_errors = []

    def _get_cell(row_values, position):
        return row_values[position] if position < len(row_values) else None

    def _parse_numeric(value, label):
        if value is None:
            return 0.0, None
        text_value = stringify_cell(value)
        if text_value is None or text_value == "":
            return 0.0, None
        try:
            return float(text_value), None
        except (TypeError, ValueError):
            try:
                cleaned = str(text_value).replace(",", "")
                return float(cleaned), None
            except (TypeError, ValueError):
                return None, f"Invalid numeric value in {label}"

    for row_index, row_values in enumerate(data_rows or [], start=2):
        if not row_values:
            continue
        row_data = {}
        has_value = False
        for header, position in header_map.items():
            value = _get_cell(row_values, position)
            cell_value = stringify_cell(value)
            if cell_value:
                has_value = True
            row_data[header] = value
        if not has_value:
            continue

        processed_rows += 1
        row_issue = []
        name = clean_str(row_data.get("Name"))
        sale_price, error = _parse_numeric(row_data.get("Sales Price"), "Sales Price")
        if error:
            row_issue.append(error)
        cost, cost_error = _parse_numeric(row_data.get("Cost"), "Cost")
        if cost_error:
            row_issue.append(cost_error)
        qty_on_hand, qty_error = _parse_numeric(
            row_data.get("Quantity On Hand"), "Quantity On Hand"
        )
        if qty_error:
            row_issue.append(qty_error)
        forecast_qty, forecast_error = _parse_numeric(
            row_data.get("Forecasted Quantity"), "Forecasted Quantity"
        )
        if forecast_error:
            row_issue.append(forecast_error)

        if not name:
            row_issue.append("Missing Name")

        if row_issue:
            row_errors.append(f"Row {row_index}: " + "; ".join(row_issue))
            continue

        product = (
            Product.query.filter(func.lower(Product.name) == name.lower()).first()
        )
        is_new = product is None
        if is_new:
            product = Product(name=name)
            db.session.add(product)
            created_count += 1
        else:
            updated_count += 1

        product.name = name
        product.sale_price = sale_price
        product.cost = cost
        product.uom = clean_str(row_data.get("Unit of Measure")) or None
        product.purchase_uom = clean_str(row_data.get("Purchase Unit")) or None
        product.qty_on_hand = qty_on_hand or 0
        product.forecast_qty = forecast_qty or 0
        product.is_favorite = _parse_boolean_cell(
            row_data.get("Favorite"), default=False
        )
        product.is_active = (
            product.is_active if product.is_active is not None else True
        )

    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        current_app.logger.exception("Failed to save product upload changes")
        return _render_result(
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            row_errors=row_errors,
            fatal_error="Could not save product records due to a database error.",
        )

    _sync_inventory_with_products()

    return _render_result(
        processed_rows=processed_rows,
        created_count=created_count,
        updated_count=updated_count,
        row_errors=row_errors,
    )


def _sync_inventory_with_products():
    """Ensure imported products are reflected in the inventory list."""

    products = Product.query.order_by(Product.name).all()
    updates_made = False

    for product in products:
        sku_before = product.sku
        item_code = _ensure_product_sku(product)
        if sku_before != product.sku:
            updates_made = True
        if not item_code:
            continue

        inventory_item = (
            InventoryItem.query.filter(
                func.lower(InventoryItem.item_code) == item_code.lower()
            ).first()
        )

        if not inventory_item:
            inventory_item = InventoryItem(item_code=item_code)
            db.session.add(inventory_item)
            updates_made = True

        preferred_unit = product.uom or product.purchase_uom
        target_stock = product.qty_on_hand or 0

        if inventory_item.book_stock is None:
            inventory_item.book_stock = target_stock
            updates_made = True
        elif inventory_item.book_stock == 0 and target_stock and not inventory_item.id:
            inventory_item.book_stock = target_stock
            updates_made = True

        if inventory_item.description != product.name:
            inventory_item.description = product.name
            updates_made = True

        if preferred_unit and inventory_item.unit != preferred_unit:
            inventory_item.unit = preferred_unit
            updates_made = True

        if (inventory_item.current_stock or 0) != target_stock:
            inventory_item.current_stock = target_stock
            updates_made = True

    if updates_made:
        try:
            db.session.commit()
        except Exception:
            db.session.rollback()
            current_app.logger.exception(
                "Failed to sync products into inventory records"
            )


def _ensure_product_sku(product: Product) -> Optional[str]:
    if not product:
        return None
    sku = (product.sku or "").strip()
    if sku:
        return sku
    if not product.id:
        return None
    candidate = f"ELV-{product.id:06d}"
    existing = Product.query.filter(Product.sku == candidate, Product.id != product.id).first()
    if existing:
        suffix = 1
        while True:
            alternate = f"{candidate}-{suffix}"
            conflict = Product.query.filter(
                Product.sku == alternate, Product.id != product.id
            ).first()
            if not conflict:
                candidate = alternate
                break
            suffix += 1
    product.sku = candidate
    return product.sku


def _initialize_book_stock(inventory_item):
    updated = False
    physical = inventory_item.current_stock or 0
    if inventory_item.book_stock is None:
        inventory_item.book_stock = physical
        updated = True
    elif inventory_item.id is None and inventory_item.book_stock == 0 and physical:
        inventory_item.book_stock = physical
        updated = True
    return updated


def _normalize_inventory_header(header: str) -> str:
    text = clean_str(header).lower()
    normalized = re.sub(r"[^a-z0-9]+", " ", text).strip()
    return re.sub(r"\s+", " ", normalized)


INVENTORY_HEADER_ALIASES = {
    "product": "product",
    "product name": "product",
    "product_name": "product",
    "quantity": "quantity",
    "qty": "quantity",
    "location": "location",
    "uom": "uom",
    "unit of measure": "uom",
    "value": "value",
    "on hand value": "value",
    "company": "company",
}


def _process_inventory_upload(upload, extension):
    upload.stream.seek(0)
    if extension == ".xlsx":
        _ensure_openpyxl()
        workbook = load_workbook(upload.stream, data_only=True)
        sheet = workbook.active
        rows = sheet.iter_rows(values_only=True)
    else:
        content = upload.stream.read()
        try:
            text = content.decode("utf-8-sig")
        except Exception:
            text = content.decode("latin-1")
        reader = csv.reader(StringIO(text))
        rows = reader

    header_row = next(rows, None)
    if not header_row:
        return {
            "processed_rows": 0,
            "imported_rows": 0,
            "row_errors": ["The uploaded file does not contain any data."],
            "total_errors": 1,
            "rows_skipped": 1,
            "missing_products": [],
            "fatal_error": None,
        }

    header_map = {}
    for idx, header in enumerate(header_row):
        canonical = INVENTORY_HEADER_ALIASES.get(_normalize_inventory_header(header))
        if canonical and canonical not in header_map:
            header_map[canonical] = idx

    missing = [col for col in ("product", "quantity") if col not in header_map]
    if missing:
        return {
            "processed_rows": 0,
            "imported_rows": 0,
            "row_errors": ["Missing required column(s): " + ", ".join(missing).title()],
            "total_errors": 1,
            "rows_skipped": 1,
            "missing_products": [],
            "fatal_error": None,
        }

    processed_rows = 0
    imported_rows = 0
    row_errors = []
    missing_products = []
    now = datetime.datetime.utcnow()
    product_totals = {}
    product_records = {}

    # Clear historical snapshot so we only keep the latest upload
    try:
        db.session.query(InventoryStock).delete()
    except Exception:
        db.session.rollback()
        current_app.logger.exception("Failed to reset previous inventory snapshot")
        return {
            "processed_rows": 0,
            "imported_rows": 0,
            "row_errors": ["Could not reset previous inventory snapshot."],
            "total_errors": 1,
            "rows_skipped": 1,
            "missing_products": [],
            "fatal_error": "Could not reset previous inventory snapshot before import.",
        }

    for row_index, row in enumerate(rows, start=2):
        row_values = {}
        for key, idx in header_map.items():
            if isinstance(row, (list, tuple)):
                row_values[key] = row[idx] if idx < len(row) else None
            else:
                try:
                    row_values[key] = row[idx]
                except Exception:
                    row_values[key] = None

        if not any(clean_str(value) for value in row_values.values()):
            continue

        processed_rows += 1

        product = clean_str(row_values.get("product"))
        if not product:
            row_errors.append(f"Row {row_index}: Missing Product")
            continue

        product_in_master = Product.query.filter(
            func.lower(Product.name) == product.lower()
        ).first()
        if not product_in_master:
            message = (
                f"Row {row_index}: Product '{product}' not found in Parts master. Row ignored."
            )
            missing_products.append(message)
            continue

        quantity_raw = row_values.get("quantity")
        issues = []

        try:
            quantity = float(quantity_raw)
        except (TypeError, ValueError):
            quantity_text = clean_str(quantity_raw)
            if quantity_text:
                try:
                    quantity = float(quantity_text)
                except (TypeError, ValueError):
                    quantity = None
            else:
                quantity = None

        if quantity is None:
            issues.append("Quantity is not numeric")

        value_raw = row_values.get("value")
        on_hand_value = None
        if value_raw not in (None, ""):
            try:
                on_hand_value = float(value_raw)
            except (TypeError, ValueError):
                value_text = clean_str(value_raw)
                try:
                    on_hand_value = float(value_text)
                except (TypeError, ValueError):
                    issues.append("Value is not numeric")

        if issues:
            row_errors.append(f"Row {row_index}: " + "; ".join(issues))
            continue

        product_key = product.lower()
        product_totals[product_key] = product_totals.get(product_key, 0) + quantity
        product_records[product_key] = product_in_master

        location = clean_str(row_values.get("location")) or "Main Store"
        record = InventoryStock(
            product_name=product,
            location=location,
            quantity=quantity,
            uom=clean_str(row_values.get("uom")) or None,
            on_hand_value=on_hand_value,
            company=clean_str(row_values.get("company")) or None,
            last_updated=now,
            is_active=True,
        )
        db.session.add(record)
        imported_rows += 1

    for key, total_qty in product_totals.items():
        product_ref = product_records.get(key)
        inventory_item = InventoryItem.query.filter(
            func.lower(InventoryItem.item_code) == key
        ).first()
        if not inventory_item:
            inventory_item = InventoryItem(
                item_code=product_ref.name if product_ref else key,
                description=product_ref.name if product_ref else key,
                unit=(product_ref.uom or product_ref.purchase_uom) if product_ref else None,
            )
            db.session.add(inventory_item)
        if product_ref:
            preferred_unit = product_ref.uom or product_ref.purchase_uom
            if preferred_unit:
                inventory_item.unit = preferred_unit
            inventory_item.description = inventory_item.description or product_ref.name
        inventory_item.current_stock = total_qty
        inventory_item.book_stock = total_qty

    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        current_app.logger.exception("Failed to save inventory upload changes")
        return {
            "processed_rows": processed_rows,
            "imported_rows": imported_rows,
            "row_errors": row_errors,
            "total_errors": len(row_errors) + len(missing_products),
            "rows_skipped": len(row_errors) + len(missing_products),
            "missing_products": missing_products,
            "fatal_error": "Could not save inventory records due to a database error.",
        }

    return {
        "processed_rows": processed_rows,
        "imported_rows": imported_rows,
        "row_errors": row_errors,
        "total_errors": len(row_errors) + len(missing_products),
        "rows_skipped": len(row_errors) + len(missing_products),
        "missing_products": missing_products,
        "fatal_error": None,
    }


@app.route("/inventory/upload", methods=["POST"])
@login_required
def inventory_upload():
    ensure_bootstrap()

    def _render_result(**kwargs):
        defaults = {
            "processed_rows": 0,
            "imported_rows": 0,
            "row_errors": [],
            "total_errors": 0,
            "rows_skipped": 0,
            "missing_products": [],
            "fatal_error": None,
        }
        defaults.update(kwargs)
        return render_template("inventory_upload_result.html", **defaults)

    inventory_flags = _get_inventory_control()
    if not inventory_flags.get("ODOO_INVENTORY_IMPORT_ENABLED", True):
        return _render_result(
            fatal_error=(
                "Odoo inventory import is disabled. ERP inventory is now the single source of truth."
            )
        )

    upload = request.files.get("inventory_file")
    try:
        extension = _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        return _render_result(fatal_error=str(exc))
    except RequestEntityTooLarge:
        return _render_result(
            fatal_error=(
                f"Uploads are limited to {int(_get_max_upload_size_bytes() / (1024 * 1024))} MB."
            )
        )

    try:
        result = _process_inventory_upload(upload, extension)
    except MissingDependencyError:
        return _render_result(fatal_error=OPENPYXL_MISSING_MESSAGE)
    except Exception:
        current_app.logger.exception("Failed to process inventory upload")
        return _render_result(
            fatal_error=(
                "There was a problem reading this inventory file. Please check the template and try again."
            )
        )

    fatal_error = result.get("fatal_error")
    if fatal_error:
        return _render_result(**result)

    return render_template("inventory_upload_result.html", **result)


@app.route("/purchase/vendors/upload", methods=["POST"])
@login_required
def purchase_vendors_upload():
    ensure_bootstrap()

    def _render_result(
        *,
        processed_rows=0,
        created_count=0,
        updated_count=0,
        row_errors=None,
        fatal_error=None,
    ):
        return render_template(
            "purchase_vendor_upload_result.html",
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            row_errors=row_errors or [],
            fatal_error=fatal_error,
        )

    upload = request.files.get("vendor_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        return _render_result(fatal_error=str(exc))

    try:
        header_cells, data_rows = _extract_tabular_upload(upload)
    except MissingDependencyError:
        return _render_result(fatal_error=OPENPYXL_MISSING_MESSAGE)
    except ValueError:
        return _render_result(
            fatal_error="Upload a .xlsx or .csv file exported from Odoo vendors."
        )
    except UploadStageTimeoutError as exc:
        return _render_result(fatal_error=str(exc))
    except Exception:
        current_app.logger.exception("Failed to read uploaded vendor file")
        return _render_result(
            fatal_error="Could not read the uploaded file. Please ensure it is a valid spreadsheet."
        )

    required_headers = {
        "Complete Name",
        "Activities",
        "City",
        "Country",
        "Email",
        "Phone",
        "Salesperson",
    }

    header_map = {}
    for idx, header in enumerate(header_cells or []):
        label = stringify_cell(header)
        if label:
            header_map[label] = idx

    missing_headers = [label for label in required_headers if label not in header_map]
    if missing_headers:
        return _render_result(
            fatal_error=(
                "The uploaded sheet is missing required columns: "
                + ", ".join(sorted(missing_headers))
            )
        )

    email_pattern = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
    phone_pattern = re.compile(r"^[0-9+\-\s]+$")

    processed_rows = 0
    created_count = 0
    updated_count = 0
    row_errors = []

    for row_index, row_values in enumerate(data_rows or [], start=2):
        if not row_values:
            continue
        row_data = {}
        has_value = False
        for header, position in header_map.items():
            value = row_values[position] if position < len(row_values) else None
            cell_value = stringify_cell(value)
            if cell_value:
                has_value = True
            row_data[header] = cell_value
        if not has_value:
            continue

        processed_rows += 1
        name = clean_str(row_data.get("Complete Name"))
        activities = clean_str(row_data.get("Activities")) or None
        city = clean_str(row_data.get("City")) or None
        country = clean_str(row_data.get("Country")) or None
        email_value = clean_str(row_data.get("Email")) or None
        phone_value = clean_str(row_data.get("Phone")) or None
        salesperson = clean_str(row_data.get("Salesperson")) or None
        gstin = clean_str(row_data.get("GSTIN")) or None
        vendor_code = clean_str(row_data.get("Vendor Code")) or None
        address_line1 = (
            clean_str(row_data.get("Street"))
            or clean_str(row_data.get("Address Line 1"))
            or None
        )
        address_line2 = (
            clean_str(row_data.get("Street2"))
            or clean_str(row_data.get("Address Line 2"))
            or None
        )
        pincode = clean_str(row_data.get("Zip")) or clean_str(row_data.get("Pincode")) or None
        state = clean_str(row_data.get("State")) or None

        row_issue = []
        if not name:
            row_issue.append("Complete Name is required")
        if email_value and not email_pattern.match(email_value):
            row_issue.append("Email format is invalid")
        if phone_value and not phone_pattern.match(phone_value):
            row_issue.append("Phone contains invalid characters")

        if row_issue:
            row_errors.append(f"Row {row_index}: " + "; ".join(row_issue))
            continue

        vendor = (
            Vendor.query.filter(func.lower(Vendor.name) == name.lower()).first()
        )
        is_new = vendor is None
        if is_new:
            vendor = Vendor(name=name)
            db.session.add(vendor)
            created_count += 1
        else:
            updated_count += 1

        vendor.vendor_code = vendor_code or vendor.vendor_code
        vendor.name = name
        vendor.activities = activities
        vendor.city = city
        vendor.country = country
        vendor.email = email_value
        vendor.phone = phone_value
        vendor.salesperson = salesperson
        vendor.gstin = gstin
        vendor.address_line1 = address_line1
        vendor.address_line2 = address_line2
        vendor.pincode = pincode
        vendor.state = state
        vendor.is_active = True if vendor.is_active is None else vendor.is_active

        address_parts = [
            part
            for part in [address_line1, address_line2, city, state, pincode, country]
            if part
        ]
        vendor.address = ", ".join(address_parts) if address_parts else vendor.address

    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        current_app.logger.exception("Failed to save vendor upload changes")
        return _render_result(
            processed_rows=processed_rows,
            created_count=created_count,
            updated_count=updated_count,
            row_errors=row_errors,
            fatal_error="Could not save vendor records due to a database error.",
        )

    return _render_result(
        processed_rows=processed_rows,
        created_count=created_count,
        updated_count=updated_count,
        row_errors=row_errors,
    )


@app.route("/purchase/vendors", methods=["GET", "POST"])
@login_required
def purchase_vendors():
    ensure_bootstrap()
    if request.method == "POST":
        name = (request.form.get("name") or "").strip()
        contact_person = (request.form.get("contact_person") or "").strip() or None
        phone = (request.form.get("phone") or "").strip() or None
        email = (request.form.get("email") or "").strip() or None
        address = (request.form.get("address") or "").strip() or None
        notes = (request.form.get("notes") or "").strip() or None

        if not name:
            flash("Vendor name is required.", "danger")
        else:
            vendor = Vendor(name=name, contact_person=contact_person, phone=phone, email=email, address=address, notes=notes)
            db.session.add(vendor)
            db.session.commit()
            flash("Vendor added.", "success")
            return redirect(url_for("purchase_vendors"))

    vendors = (
        Vendor.query.order_by(
            case((Vendor.last_used_at.is_(None), 1), else_=0),
            Vendor.last_used_at.desc(),
            Vendor.name.asc(),
        ).all()
    )
    return render_template("purchase_vendors.html", vendors=vendors)


VENDOR_ISSUE_TYPE_OPTIONS = [
    ("QC_FAIL", "QC Fail"),
    ("REJECTED_MATERIAL", "Rejected material"),
    ("LATE_DELIVERY", "Late delivery"),
    ("OTHER", "Other"),
]
VENDOR_ISSUE_TYPE_SET = {value for value, _ in VENDOR_ISSUE_TYPE_OPTIONS}


def _normalize_vendor_issue_type(raw_value: str) -> str:
    cleaned = (raw_value or "").strip().upper()
    if cleaned in VENDOR_ISSUE_TYPE_SET:
        return cleaned
    return "OTHER"


@app.route("/purchase/vendors/<int:vendor_id>", methods=["GET"])
@login_required
def purchase_vendor_detail(vendor_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    contacts = (
        VendorContact.query.filter_by(vendor_id=vendor.id)
        .order_by(VendorContact.priority.asc().nullslast(), VendorContact.name.asc())
        .all()
    )
    rate_rows = (
        VendorProductRate.query.options(joinedload(VendorProductRate.product))
        .filter_by(vendor_id=vendor.id)
        .order_by(VendorProductRate.updated_at.desc().nullslast())
        .all()
    )
    vendor_issues = (
        VendorIssue.query.options(
            joinedload(VendorIssue.product),
            joinedload(VendorIssue.purchase_order),
            joinedload(VendorIssue.project),
        )
        .filter_by(vendor_id=vendor.id)
        .order_by(VendorIssue.created_at.desc())
        .all()
    )
    vendor_parts = []
    seen_parts = set()
    for rate in rate_rows:
        if rate.product and rate.product.id not in seen_parts:
            vendor_parts.append(rate.product)
            seen_parts.add(rate.product.id)

    purchase_orders = (
        PurchaseOrder.query.options(joinedload(PurchaseOrder.items))
        .filter_by(vendor_id=vendor.id)
        .order_by(PurchaseOrder.po_date.desc().nullslast(), PurchaseOrder.id.desc())
        .all()
    )
    vendors = Vendor.query.order_by(Vendor.name.asc()).all()
    products = Product.query.order_by(Product.name.asc()).all()
    projects = Project.query.order_by(Project.name.asc()).all()
    closed_statuses = {"received", "closed", "completed", "done", "cancelled"}
    open_pos = []
    received_pos = []
    po_rows = []
    for po in purchase_orders:
        status = (po.status or "").strip().lower()
        if status in closed_statuses:
            received_pos.append(po)
            status_label = "Received"
        else:
            open_pos.append(po)
            status_label = "Open"
        po_rows.append(
            {
                "po": po,
                "status_label": status_label,
            }
        )

    def _po_total(po):
        if po.grand_total_amount is not None:
            return float(po.grand_total_amount or 0)
        if po.subtotal_amount is not None:
            return float(po.subtotal_amount or 0)
        total = 0.0
        for item in po.items or []:
            if item.total_amount is not None:
                total += float(item.total_amount or 0)
            else:
                total += float(item.quantity_ordered or 0) * float(item.unit_price or 0)
        return total

    today = date.today()
    month_total = 0.0
    ytd_total = 0.0
    last_year_total = 0.0
    po_totals = {po.id: _po_total(po) for po in purchase_orders}
    open_total = sum(po_totals.get(po.id, 0) for po in open_pos)

    for po in purchase_orders:
        po_date = po.po_date or po.order_date
        if not po_date:
            continue
        po_total = po_totals.get(po.id, 0)
        if po_date.year == today.year and po_date.month == today.month:
            month_total += po_total
        if po_date.year == today.year and po_date <= today:
            ytd_total += po_total
        if po_date.year == today.year - 1:
            last_year_total += po_total

    return render_template(
        "vendor_detail.html",
        vendor=vendor,
        contacts=contacts,
        rate_rows=rate_rows,
        po_rows=po_rows,
        vendor_issues=vendor_issues,
        vendor_parts=vendor_parts,
        purchase_orders=purchase_orders,
        vendors=vendors,
        products=products,
        projects=projects,
        issue_type_options=VENDOR_ISSUE_TYPE_OPTIONS,
        po_totals=po_totals,
        analytics={
            "month_total": month_total,
            "open_total": open_total,
            "ytd_total": ytd_total,
            "last_year_total": last_year_total,
        },
    )


@app.route("/purchase/vendors/<int:vendor_id>/contacts", methods=["POST"])
@app.route("/purchase/vendors/<int:vendor_id>/contacts/create", methods=["POST"])
@login_required
def purchase_vendor_contact_create(vendor_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    name = (request.form.get("name") or "").strip()
    role = (request.form.get("role") or "").strip() or None
    phone = (request.form.get("phone") or "").strip() or None
    email = (request.form.get("email") or "").strip() or None
    priority_raw = (request.form.get("priority") or "").strip()

    if not name:
        flash("Contact name is required.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    try:
        priority = int(priority_raw) if priority_raw else None
    except (TypeError, ValueError):
        priority = None

    contact = VendorContact(
        vendor_id=vendor.id,
        name=name,
        role=role,
        phone=phone,
        email=email,
        priority=priority,
    )
    db.session.add(contact)
    try:
        db.session.commit()
        flash("Vendor contact added.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not add vendor contact right now.", "danger")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/contacts/<int:contact_id>/update", methods=["POST"])
@login_required
def purchase_vendor_contact_update(vendor_id: int, contact_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    contact = VendorContact.query.filter_by(id=contact_id, vendor_id=vendor.id).first_or_404()
    name = (request.form.get("name") or "").strip()
    role = (request.form.get("role") or "").strip() or None
    phone = (request.form.get("phone") or "").strip() or None
    email = (request.form.get("email") or "").strip() or None
    priority_raw = (request.form.get("priority") or "").strip()

    if not name:
        flash("Contact name is required.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    try:
        priority = int(priority_raw) if priority_raw else None
    except (TypeError, ValueError):
        priority = None

    contact.name = name
    contact.role = role
    contact.phone = phone
    contact.email = email
    contact.priority = priority
    try:
        db.session.commit()
        flash("Contact updated.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not update contact right now.", "danger")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/contacts/<int:contact_id>/delete", methods=["POST"])
@login_required
def purchase_vendor_contact_delete(vendor_id: int, contact_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    contact = VendorContact.query.filter_by(id=contact_id, vendor_id=vendor.id).first_or_404()
    try:
        db.session.delete(contact)
        db.session.commit()
        flash("Contact deleted.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not delete contact right now.", "danger")
    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/contacts/<int:contact_id>/transfer", methods=["POST"])
@login_required
def purchase_vendor_contact_transfer(vendor_id: int, contact_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    contact = VendorContact.query.filter_by(id=contact_id, vendor_id=vendor.id).first_or_404()
    target_vendor_id_raw = (request.form.get("target_vendor_id") or "").strip()
    try:
        target_vendor_id = int(target_vendor_id_raw)
    except (TypeError, ValueError):
        target_vendor_id = None

    if not target_vendor_id:
        flash("Select a vendor to transfer this contact.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    target_vendor = Vendor.query.get(target_vendor_id)
    if not target_vendor:
        flash("Target vendor not found.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    contact.vendor_id = target_vendor.id
    try:
        db.session.commit()
        flash("Contact transferred.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not transfer contact right now.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    return redirect(url_for("purchase_vendor_detail", vendor_id=target_vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/contacts/order", methods=["POST"])
@login_required
def purchase_vendor_contact_order(vendor_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    contacts = VendorContact.query.filter_by(vendor_id=vendor.id).all()
    updates = 0
    for contact in contacts:
        raw_value = (request.form.get(f"priority_{contact.id}") or "").strip()
        try:
            new_priority = int(raw_value) if raw_value else None
        except (TypeError, ValueError):
            new_priority = None
        if contact.priority != new_priority:
            contact.priority = new_priority
            updates += 1
    if updates:
        try:
            db.session.commit()
            flash("Contact order updated.", "success")
        except Exception:
            db.session.rollback()
            flash("Could not update contact order right now.", "danger")
    else:
        flash("No contact order changes detected.", "info")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/issues", methods=["POST"])
@app.route("/purchase/vendors/<int:vendor_id>/issues/create", methods=["POST"])
@login_required
def purchase_vendor_issue_create(vendor_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    product_id_raw = request.form.get("product_id") or None
    po_id_raw = request.form.get("po_id") or None
    project_id_raw = request.form.get("project_id") or None
    issue_type = _normalize_vendor_issue_type(request.form.get("issue_type"))
    description = (request.form.get("description") or "").strip()
    status = (request.form.get("status") or "").strip() or "Open"

    if not description:
        flash("Provide a description for the vendor issue.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    try:
        product_id = int(product_id_raw) if product_id_raw else None
    except (TypeError, ValueError):
        product_id = None
    try:
        po_id = int(po_id_raw) if po_id_raw else None
    except (TypeError, ValueError):
        po_id = None
    try:
        project_id = int(project_id_raw) if project_id_raw else None
    except (TypeError, ValueError):
        project_id = None

    product = Product.query.get(product_id) if product_id else None
    po = PurchaseOrder.query.get(po_id) if po_id else None
    if po and po.vendor_id != vendor.id:
        po = None
    project = Project.query.get(project_id) if project_id else None

    issue = VendorIssue(
        vendor_id=vendor.id,
        product_id=product.id if product else None,
        po_id=po.id if po else None,
        project_id=project.id if project else (po.project_id if po else None),
        issue_type=issue_type,
        source="MANUAL",
        description=description,
        status=status,
        created_by=current_user.display_name,
    )
    db.session.add(issue)
    try:
        db.session.commit()
        flash("Vendor issue logged.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not log vendor issue right now.", "danger")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/issues/<int:issue_id>/update", methods=["POST"])
@login_required
def purchase_vendor_issue_update(vendor_id: int, issue_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    issue = VendorIssue.query.filter_by(id=issue_id, vendor_id=vendor.id).first_or_404()
    issue_type = _normalize_vendor_issue_type(request.form.get("issue_type"))
    description = (request.form.get("description") or "").strip()
    status = (request.form.get("status") or "").strip() or issue.status
    product_id_raw = request.form.get("product_id") or None
    po_id_raw = request.form.get("po_id") or None
    project_id_raw = request.form.get("project_id") or None

    if not description:
        flash("Description is required for vendor issues.", "danger")
        return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))

    try:
        product_id = int(product_id_raw) if product_id_raw else None
    except (TypeError, ValueError):
        product_id = None
    try:
        po_id = int(po_id_raw) if po_id_raw else None
    except (TypeError, ValueError):
        po_id = None
    try:
        project_id = int(project_id_raw) if project_id_raw else None
    except (TypeError, ValueError):
        project_id = None

    product = Product.query.get(product_id) if product_id else None
    po = PurchaseOrder.query.get(po_id) if po_id else None
    if po and po.vendor_id != vendor.id:
        po = None
    project = Project.query.get(project_id) if project_id else None

    issue.issue_type = issue_type
    issue.description = description
    issue.status = status
    issue.product_id = product.id if product else None
    issue.po_id = po.id if po else None
    issue.project_id = project.id if project else None
    try:
        db.session.commit()
        flash("Vendor issue updated.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not update vendor issue right now.", "danger")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/issues/<int:issue_id>/delete", methods=["POST"])
@login_required
def purchase_vendor_issue_delete(vendor_id: int, issue_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    issue = VendorIssue.query.filter_by(id=issue_id, vendor_id=vendor.id).first_or_404()
    try:
        db.session.delete(issue)
        db.session.commit()
        flash("Vendor issue deleted.", "success")
    except Exception:
        db.session.rollback()
        flash("Could not delete vendor issue right now.", "danger")

    return redirect(url_for("purchase_vendor_detail", vendor_id=vendor.id))


@app.route("/purchase/vendors/<int:vendor_id>/edit", methods=["POST"])
@login_required
def purchase_vendor_edit(vendor_id: int):
    ensure_bootstrap()
    vendor = Vendor.query.get_or_404(vendor_id)
    name = (request.form.get("name") or "").strip()
    contact_person = (request.form.get("contact_person") or "").strip() or None
    phone = (request.form.get("phone") or "").strip() or None
    email = (request.form.get("email") or "").strip() or None
    address = (request.form.get("address") or "").strip() or None
    notes = (request.form.get("notes") or "").strip() or None

    if not name:
        flash("Vendor name is required.", "danger")
        return redirect(url_for("purchase_vendors"))

    vendor.name = name
    vendor.contact_person = contact_person
    vendor.phone = phone
    vendor.email = email
    vendor.address = address
    vendor.notes = notes
    db.session.commit()
    flash("Vendor updated.", "success")
    return redirect(url_for("purchase_vendors"))


@app.route("/store/delivery-orders")
@login_required
def store_delivery_orders():
    ensure_bootstrap()
    _require_delivery_order_permission("view")

    orders = (
        DeliveryOrder.query.options(
            joinedload(DeliveryOrder.created_by),
            joinedload(DeliveryOrder.dispatched_by),
        )
        .order_by(DeliveryOrder.id.desc())
        .all()
    )

    can_create = _current_role_key() in {"store", "purchase", "admin"}

    return render_template(
        "store_delivery_orders.html",
        orders=orders,
        can_create=can_create,
    )


def _parse_delivery_order_items(form):
    product_names = form.getlist("item_product_name")
    quantities_raw = form.getlist("item_quantity")
    uoms = form.getlist("item_uom")
    remarks = form.getlist("item_remarks")

    max_len = max(
        len(product_names), len(quantities_raw), len(uoms), len(remarks)
    )

    items = []
    errors = []

    for idx in range(max_len):
        product_name = (product_names[idx] if idx < len(product_names) else "").strip()
        quantity_raw = (quantities_raw[idx] if idx < len(quantities_raw) else "").strip()
        uom = (uoms[idx] if idx < len(uoms) else "").strip() or None
        remark = (remarks[idx] if idx < len(remarks) else "").strip() or None

        if not any([product_name, quantity_raw, uom, remark]):
            continue

        try:
            quantity_value = float(quantity_raw)
        except (TypeError, ValueError):
            quantity_value = None

        if not product_name:
            errors.append("Product name is required for each item.")
        if quantity_value is None:
            errors.append("Quantity must be numeric.")
        elif quantity_value <= 0:
            errors.append("Quantity must be greater than zero.")

        items.append(
            {
                "item_code": product_name,
                "product_name": product_name,
                "quantity": quantity_value,
                "uom": uom,
                "remarks": remark,
            }
        )

    if not items:
        errors.append("Add at least one delivery item.")

    return items, errors


@app.route("/store/delivery-orders/new", methods=["GET", "POST"])
@login_required
def create_delivery_order():
    ensure_bootstrap()
    _require_delivery_order_permission("create")

    products = Product.query.filter_by(is_active=True).order_by(Product.name).all()

    if request.method == "POST":
        project_or_site = (request.form.get("project_or_site") or "").strip()
        receiver_name = (request.form.get("receiver_name") or "").strip()
        remarks = (request.form.get("remarks") or "").strip() or None

        items, item_errors = _parse_delivery_order_items(request.form)
        errors = []

        if not project_or_site:
            errors.append("Project / Site Name is required.")
        if not receiver_name:
            errors.append("Receiver Name is required.")

        errors.extend(item_errors)

        if errors:
            for error in errors:
                flash(error, "danger")
            return render_template(
                "store_delivery_order_new.html",
                products=products,
                form_data={
                    "project_or_site": project_or_site,
                    "receiver_name": receiver_name,
                    "remarks": remarks,
                    "items": items,
                },
            )

        order = DeliveryOrder(
            do_number="DO-PENDING",
            date_created=datetime.datetime.utcnow(),
            created_by_user_id=current_user.id,
            project_or_site=project_or_site,
            receiver_name=receiver_name,
            remarks=remarks,
            status="Draft",
        )
        db.session.add(order)
        db.session.flush()

        order.do_number = f"DO-{order.id:04d}"

        for item in items:
                    db.session.add(
                        DeliveryOrderItem(
                            delivery_order_id=order.id,
                            item_code=item.get("item_code") or item.get("product_name"),
                            product_name=item.get("product_name"),
                            requested_qty=item.get("quantity") or 0,
                            reserved_qty=0,
                            delivered_qty_total=0,
                            uom=item.get("uom"),
                            remarks=item.get("remarks"),
                        )
                    )

        db.session.commit()
        flash("Delivery Order created.", "success")
        return redirect(url_for("delivery_order_detail", order_id=order.id))

    return render_template(
        "store_delivery_order_new.html",
        products=products,
        form_data={"items": [{}]},
    )


@app.route("/store/delivery-orders/<int:order_id>")
@login_required
def delivery_order_detail(order_id):
    ensure_bootstrap()
    _require_delivery_order_permission("view")

    order = (
        DeliveryOrder.query.options(
            subqueryload(DeliveryOrder.items),
            joinedload(DeliveryOrder.created_by),
            joinedload(DeliveryOrder.dispatched_by),
        )
        .filter_by(id=order_id)
        .first_or_404()
    )

    can_dispatch = _current_role_key() in {"store", "purchase", "admin"}

    return render_template(
        "store_delivery_order_detail.html",
        order=order,
        can_dispatch=can_dispatch,
    )


@app.route(
    "/store/delivery-orders/<int:order_id>/delivery-challans/new",
    methods=["GET", "POST"],
)
@login_required
def create_delivery_challan_from_do(order_id):
    ensure_bootstrap()
    _require_delivery_order_permission("dispatch")

    order = (
        DeliveryOrder.query.options(subqueryload(DeliveryOrder.items))
        .filter_by(id=order_id)
        .first_or_404()
    )

    if order.status in {"Draft", "Created"}:
        flash("Confirm the Delivery Order before creating a Delivery Challan.", "warning")
        return redirect(url_for("delivery_order_detail", order_id=order.id))

    items_context = []
    for item in order.items:
        reserved = item.reserved_qty or item.requested_qty or 0
        delivered = item.delivered_qty_total or 0
        remaining = max(reserved - delivered, 0)
        items_context.append(
            {
                "record": item,
                "reserved": reserved,
                "delivered": delivered,
                "remaining": remaining,
            }
        )

    if request.method == "POST":
        selections = []
        for ctx in items_context:
            key = f"item_{ctx['record'].id}_qty"
            try:
                qty_value = float(request.form.get(key) or 0)
            except (TypeError, ValueError):
                qty_value = 0
            if qty_value > 0:
                if qty_value > ctx["remaining"]:
                    flash(
                        f"Cannot deliver more than reserved for {ctx['record'].item_code}.", "danger"
                    )
                    return render_template(
                        "store_delivery_challan_new.html",
                        order=order,
                        items=items_context,
                    )
                selections.append((ctx["record"], qty_value))

        if not selections:
            flash("Enter at least one quantity to include in the Delivery Challan.", "danger")
            return render_template(
                "store_delivery_challan_new.html",
                order=order,
                items=items_context,
            )

        challan = DeliveryChallan(
            dc_number="DC-PENDING",
            delivery_order_id=order.id,
            project_id=order.project_id,
            dispatch_date=datetime.date.today(),
            created_by_user_id=current_user.id,
            dispatched_by_user_id=current_user.id,
            status="Draft",
        )
        db.session.add(challan)
        db.session.flush()
        challan.dc_number = f"DC-{challan.id:04d}"

        for record, qty in selections:
            db.session.add(
                DeliveryChallanItem(
                    delivery_challan_id=challan.id,
                    delivery_order_item_id=record.id,
                    item_code=record.item_code,
                    description=record.product_name,
                    unit=record.uom,
                    qty_delivered=qty,
                )
            )

        db.session.commit()
        flash(
            "Delivery challan created in Draft. Mark it as delivered once the materials move.",
            "success",
        )
        return redirect(url_for("delivery_order_detail", order_id=order.id))

    return render_template(
        "store_delivery_challan_new.html",
        order=order,
        items=items_context,
    )


@app.route("/store/delivery-orders/<int:order_id>/confirm", methods=["POST"])
@login_required
def confirm_delivery_order(order_id):
    ensure_bootstrap()
    _require_delivery_order_permission("dispatch")

    order = DeliveryOrder.query.options(subqueryload(DeliveryOrder.items)).filter_by(id=order_id).first_or_404()

    if order.status not in {"Draft", "Created"}:
        flash("This Delivery Order has already been confirmed.", "info")
        return redirect(url_for("delivery_order_detail", order_id=order.id))

    warnings = []

    for item in order.items:
        item.reserved_qty = item.requested_qty or 0
        item.delivered_qty_total = item.delivered_qty_total or 0
        inv = InventoryItem.query.filter_by(item_code=item.item_code).first()
        if not inv:
            inv = InventoryItem(item_code=item.item_code, description=item.product_name, unit=item.uom)
            db.session.add(inv)
        _initialize_book_stock(inv)
        available_book = inv.book_stock if inv.book_stock is not None else inv.current_stock or 0
        if item.reserved_qty > (available_book or 0):
            warnings.append(f"Book stock shortfall for {item.item_code} ({item.reserved_qty} requested, {available_book or 0} available).")
        inv.book_stock = (inv.book_stock or inv.current_stock or 0) - item.reserved_qty

    order.status = "Confirmed" if not any((item.delivered_qty_total or 0) > 0 for item in order.items) else "Partially Delivered"
    order.updated_at = datetime.datetime.utcnow()

    db.session.commit()

    if warnings:
        for warn in warnings:
            flash(warn, "warning")
    # TODO: create_notification for store team when a DO is confirmed.
    flash("Delivery Order confirmed and stock reserved (book).", "success")
    return redirect(url_for("delivery_order_detail", order_id=order.id))


@app.route("/store/delivery-orders/<int:order_id>/dispatch", methods=["POST"])
@login_required
def dispatch_delivery_order(order_id):
    ensure_bootstrap()
    _require_delivery_order_permission("dispatch")

    DeliveryOrder.query.filter_by(id=order_id).first_or_404()
    flash("Please use Delivery Challans to record dispatches.", "info")
    return redirect(url_for("delivery_order_detail", order_id=order_id))


@app.route("/store/receive", methods=["GET", "POST"])
@login_required
def store_receive():
    ensure_bootstrap()
    pos = PurchaseOrder.query.order_by(PurchaseOrder.id.desc()).all()

    if request.method == "POST":
        purchase_order_id = request.form.get("purchase_order_id")
        purchase_order = (
            PurchaseOrder.query.get(purchase_order_id) if purchase_order_id else None
        )
        receipt_number = request.form.get("receipt_number") or f"RC-{uuid.uuid4().hex[:6].upper()}"
        received_date_raw = request.form.get("received_date")
        try:
            received_date = (
                datetime.datetime.strptime(received_date_raw, "%Y-%m-%d").date()
                if received_date_raw
                else None
            )
        except ValueError:
            received_date = None

        receipt = InventoryReceipt(
            purchase_order_id=purchase_order_id,
            receipt_number=receipt_number,
            received_date=received_date,
            received_by_user_id=current_user.id,
        )
        db.session.add(receipt)
        db.session.flush()

        for key in request.form:
            if key.startswith("item_") and key.endswith("_qty"):
                item_id = key.split("_")[1]
                qty = float(request.form.get(key) or 0)
                status_key = f"item_{item_id}_qc"
                notes_key = f"item_{item_id}_notes"
                qc_status = request.form.get(status_key)
                qc_notes = request.form.get(notes_key)
                poi = PurchaseOrderItem.query.get(item_id)
                receipt_item = InventoryReceiptItem(
                    inventory_receipt_id=receipt.id,
                    purchase_order_item_id=item_id,
                    item_code=poi.item_code if poi else "",
                    description=poi.description if poi else None,
                    quantity_received=qty,
                    qc_status=qc_status,
                    qc_notes=qc_notes,
                )
                db.session.add(receipt_item)

                qc_status_normalized = (qc_status or "").strip().lower()
                issue_type = None
                source = None
                if qc_status_normalized in {"ng", "fail", "failed", "nok", "not ok"}:
                    issue_type = "QC_FAIL"
                    source = "AUTO_QC"
                elif qc_status_normalized in {"rejected", "damaged", "short"}:
                    issue_type = "REJECTED_MATERIAL"
                    source = "AUTO_STORE"

                if issue_type and purchase_order and purchase_order.vendor_id:
                    product_id = None
                    if poi:
                        product_id = poi.product_id or poi.part_id
                    db.session.add(
                        VendorIssue(
                            vendor_id=purchase_order.vendor_id,
                            product_id=product_id,
                            po_id=purchase_order.id,
                            project_id=purchase_order.project_id,
                            issue_type=issue_type,
                            source=source,
                            description=qc_notes
                            or f"QC status marked {qc_status} during receipt.",
                            status="Open",
                            created_by=current_user.display_name,
                        )
                    )

                inv = InventoryItem.query.filter_by(item_code=receipt_item.item_code).first()
                if not inv:
                    inv = InventoryItem(
                        item_code=receipt_item.item_code,
                        description=receipt_item.description,
                        unit=poi.unit if poi else None,
                    )
                    db.session.add(inv)
                if qc_status == "OK":
                    inv.current_stock = (inv.current_stock or 0) + qty
                else:
                    inv.quarantined_stock = (inv.quarantined_stock or 0) + qty
                _initialize_book_stock(inv)
                book = BookInventory.query.filter_by(item_code=receipt_item.item_code).first()
                if book:
                    book.quantity_received_total = (book.quantity_received_total or 0) + qty

        db.session.commit()
        flash("Receipt captured and inventory updated.", "success")
        return redirect(url_for("store_receive"))

    selected_po = pos[0] if pos else None
    receipts = (
        InventoryReceipt.query.options(
            joinedload(InventoryReceipt.purchase_order),
            joinedload(InventoryReceipt.received_by),
            subqueryload(InventoryReceipt.items),
        )
        .order_by(InventoryReceipt.id.desc())
        .all()
    )
    return render_template(
        "store_receive.html", pos=pos, selected_po=selected_po, receipts=receipts
    )


def _build_inventory_movements(item):
    movements = []
    item_code = (item.item_code or "").lower()

    receipts = (
        db.session.query(InventoryReceiptItem, InventoryReceipt)
        .join(InventoryReceipt, InventoryReceipt.id == InventoryReceiptItem.inventory_receipt_id)
        .filter(func.lower(InventoryReceiptItem.item_code) == item_code)
        .all()
    )
    for receipt_item, receipt in receipts:
        qc_status = (receipt_item.qc_status or "").strip().lower()
        if qc_status and qc_status != "ok":
            continue
        qty = receipt_item.quantity_received or 0
        timestamp = receipt.received_date
        if isinstance(timestamp, datetime.date) and not isinstance(timestamp, datetime.datetime):
            timestamp = datetime.datetime.combine(
                timestamp, datetime.datetime.min.time()
            )
        timestamp = timestamp or datetime.datetime.min
        movements.append(
            {
                "timestamp": timestamp,
                "movement_type": "GRN",
                "physical_delta": qty,
                "book_delta": 0,
                "reference": receipt.receipt_number if receipt else None,
                "source_url": url_for("store_receive"),
            }
        )

    dispatches = (
        db.session.query(DeliveryChallanItem, DeliveryChallan)
        .join(DeliveryChallan, DeliveryChallan.id == DeliveryChallanItem.delivery_challan_id)
        .filter(func.lower(DeliveryChallanItem.item_code) == item_code)
        .filter(DeliveryChallan.is_completed.is_(True))
        .all()
    )
    for dispatch_item, dispatch in dispatches:
        qty = -(dispatch_item.qty_delivered or 0)
        timestamp = (
            dispatch.delivered_at
            or dispatch.completed_at
            or (
                datetime.datetime.combine(
                    dispatch.dispatch_date, datetime.datetime.min.time()
                )
                if dispatch.dispatch_date
                else None
            )
            or dispatch.created_at
            or datetime.datetime.min
        )
        book_delta = qty if not dispatch.delivery_order_id else 0
        movements.append(
            {
                "timestamp": timestamp,
                "movement_type": "Delivery Challan",
                "physical_delta": qty,
                "book_delta": book_delta,
                "reference": dispatch.dc_number,
                "source_url": url_for("store_dispatch"),
            }
        )

    adjustments = (
        StockAdjustment.query.filter_by(inventory_item_id=item.id)
        .order_by(StockAdjustment.created_at)
        .all()
    )
    for adjustment in adjustments:
        physical_delta = (adjustment.new_physical_stock or 0) - (
            adjustment.old_physical_stock or 0
        )
        book_delta = (adjustment.new_book_stock or 0) - (
            adjustment.old_book_stock or 0
        )
        movements.append(
            {
                "timestamp": adjustment.created_at or datetime.datetime.min,
                "movement_type": f"Stock Adjustment ({adjustment.adjustment_type})",
                "physical_delta": physical_delta,
                "book_delta": book_delta,
                "reference": adjustment.reason,
                "source_url": None,
            }
        )

    movements.sort(key=lambda entry: entry["timestamp"])
    running_physical = (item.current_stock or 0) - sum(
        move.get("physical_delta", 0) for move in movements
    )
    for move in movements:
        running_physical += move.get("physical_delta", 0)
        move["updated_physical"] = running_physical

    return movements


@app.route("/store/inventory")
@login_required
def store_inventory():
    ensure_bootstrap()
    inventory_flags = _get_inventory_control()
    _sync_inventory_with_products()
    items = InventoryItem.query.order_by(InventoryItem.item_code).all()
    for item in items:
        if item.book_stock is None:
            item.book_stock = item.current_stock or 0
    total_items = len(items)
    quarantined_items = [item for item in items if (item.quarantined_stock or 0) > 0]
    quarantined_count = len(quarantined_items)
    usable_items = [item for item in items if (item.current_stock or 0) > 0]
    usable_count = len(usable_items)
    low_stock = [item for item in items if (item.current_stock or 0) < 1]
    snapshot_available = InventoryStock.query.count() > 0
    can_adjust = _current_role_key() in {"admin", "store"}
    return render_template(
        "store_inventory.html",
        items=items,
        total_items=total_items,
        quarantined=quarantined_count,
        quarantined_items=quarantined_items,
        usable=usable_count,
        usable_items=usable_items,
        low_stock=low_stock,
        inventory_flags=inventory_flags,
        snapshot_available=snapshot_available,
        can_adjust=can_adjust,
    )


@app.route("/inventory/item/<int:item_id>/adjust", methods=["GET", "POST"])
@login_required
def adjust_inventory_item(item_id):
    ensure_bootstrap()
    _require_inventory_adjust_permission()
    item = InventoryItem.query.filter_by(id=item_id).first_or_404()

    if request.method == "POST":
        reason = (request.form.get("reason") or "").strip()
        if not reason:
            flash("A reason is required for stock adjustments.", "warning")
            return redirect(url_for("adjust_inventory_item", item_id=item.id))

        def _parse_value(raw_value, fallback):
            if raw_value in (None, ""):
                return fallback
            try:
                return float(raw_value)
            except (TypeError, ValueError):
                return None

        new_physical = _parse_value(
            request.form.get("new_physical_stock"), item.current_stock or 0
        )
        new_book = _parse_value(
            request.form.get("new_book_stock"),
            item.book_stock if item.book_stock is not None else item.current_stock or 0,
        )

        if new_physical is None or new_book is None:
            flash("Stock values must be numeric.", "danger")
            return redirect(url_for("adjust_inventory_item", item_id=item.id))

        if (
            new_physical == (item.current_stock or 0)
            and new_book == (item.book_stock if item.book_stock is not None else item.current_stock or 0)
        ):
            flash("No changes detected for this item.", "info")
            return redirect(url_for("adjust_inventory_item", item_id=item.id))

        if new_physical < 0 or new_book < 0:
            flash("Stock values cannot be negative.", "warning")
            return redirect(url_for("adjust_inventory_item", item_id=item.id))

        adjustment_type = "both"
        if new_physical == (item.current_stock or 0):
            adjustment_type = "book"
        elif new_book == (item.book_stock if item.book_stock is not None else item.current_stock or 0):
            adjustment_type = "physical"

        adjustment = StockAdjustment(
            inventory_item_id=item.id,
            old_physical_stock=item.current_stock or 0,
            new_physical_stock=new_physical,
            old_book_stock=item.book_stock if item.book_stock is not None else item.current_stock or 0,
            new_book_stock=new_book,
            reason=reason,
            adjustment_type=adjustment_type,
            created_by_user_id=current_user.id,
            created_at=datetime.datetime.utcnow(),
        )
        db.session.add(adjustment)

        item.current_stock = new_physical
        item.book_stock = new_book

        try:
            db.session.commit()
        except Exception:
            db.session.rollback()
            current_app.logger.exception("Failed to record stock adjustment")
            flash("Could not save the stock adjustment. Please try again.", "danger")
            return redirect(url_for("adjust_inventory_item", item_id=item.id))

        flash("Stock adjusted with audit trail recorded.", "success")
        return redirect(url_for("inventory_item_movements", item_id=item.id))

    return render_template("stock_adjustment_form.html", item=item)


@app.route("/inventory/item/<int:item_id>/movements")
@login_required
def inventory_item_movements(item_id):
    ensure_bootstrap()
    item = InventoryItem.query.filter_by(id=item_id).first_or_404()
    movements = _build_inventory_movements(item)
    can_adjust = _current_role_key() in {"admin", "store"}
    return render_template(
        "inventory_movements.html",
        item=item,
        movements=movements,
        can_adjust=can_adjust,
    )


@app.route("/inventory/odoo-snapshot")
@login_required
def inventory_snapshot():
    ensure_bootstrap()
    records = (
        InventoryStock.query.order_by(
            InventoryStock.product_name, InventoryStock.location
        ).all()
    )
    return render_template(
        "inventory_snapshot.html",
        records=records,
        inventory_flags=_get_inventory_control(),
    )


@app.route("/store/dispatch", methods=["GET", "POST"])
@login_required
def store_dispatch():
    ensure_bootstrap()
    projects = Project.query.order_by(Project.name).all()
    inventory = InventoryItem.query.order_by(InventoryItem.item_code).all()

    if request.method == "POST":
        item_code = request.form.get("item_code")
        try:
            quantity = float(request.form.get("quantity_dispatched") or 0)
        except (TypeError, ValueError):
            quantity = 0

        if not item_code or quantity <= 0:
            flash(
                "Please select an item and enter a quantity before creating a delivery challan.",
                "warning",
            )
            return redirect(url_for("store_dispatch"))

        inv = InventoryItem.query.filter_by(item_code=item_code).first()
        available_qty = inv.current_stock if inv and inv.current_stock is not None else 0

        if not inv:
            flash("The selected item is not available in inventory.", "danger")
            return redirect(url_for("store_dispatch"))

        if quantity > available_qty:
            flash("Insufficient stock available for this dispatch quantity.", "danger")
            return redirect(url_for("store_dispatch"))

        dispatch_number = request.form.get("dispatch_number") or f"DC-{uuid.uuid4().hex[:6].upper()}"
        project_id = request.form.get("project_id") or None
        dispatch_date_raw = request.form.get("dispatch_date")
        try:
            dispatch_date = datetime.datetime.strptime(dispatch_date_raw, "%Y-%m-%d").date() if dispatch_date_raw else None
        except ValueError:
            dispatch_date = None

        dispatch = DeliveryChallan(
            project_id=project_id,
            dc_number=dispatch_number,
            dispatch_date=dispatch_date,
            dispatched_by_user_id=current_user.id,
            created_by_user_id=current_user.id,
            vehicle_details=request.form.get("vehicle_details"),
            driver_name=request.form.get("driver_name"),
            notes=request.form.get("notes"),
            status="Draft",
            delivered_at=None,
            is_completed=False,
            completed_at=None,
        )
        db.session.add(dispatch)
        db.session.flush()

        dispatch_item = DeliveryChallanItem(
            delivery_challan_id=dispatch.id,
            item_code=item_code,
            description=request.form.get("description"),
            unit=request.form.get("unit"),
            qty_delivered=quantity,
        )
        db.session.add(dispatch_item)

        db.session.commit()
        flash("Delivery challan created in Draft. Mark as delivered when dispatched.", "success")
        return redirect(url_for("store_dispatch"))

    dispatches = (
        DeliveryChallan.query.options(
            joinedload(DeliveryChallan.project),
            joinedload(DeliveryChallan.delivery_order),
            subqueryload(DeliveryChallan.items),
        )
        .order_by(DeliveryChallan.id.desc())
        .all()
    )
    return render_template(
        "store_dispatch.html",
        projects=projects,
        inventory=inventory,
        dispatches=dispatches,
    )


@app.route("/store/dispatch/<int:dispatch_id>/edit", methods=["POST"])
@login_required
def edit_dispatch(dispatch_id):
    ensure_bootstrap()
    dispatch = (
        DeliveryChallan.query.options(subqueryload(DeliveryChallan.items))
        .filter_by(id=dispatch_id)
        .first_or_404()
    )

    if dispatch.is_completed:
        flash("Completed dispatches cannot be edited.", "warning")
        return redirect(url_for("store_dispatch"))

    item_code = request.form.get("item_code")
    try:
        quantity = float(request.form.get("quantity_dispatched") or 0)
    except (TypeError, ValueError):
        quantity = 0

    if not item_code or quantity <= 0:
        flash(
            "Please select an item and enter a quantity before updating the dispatch.",
            "warning",
        )
        return redirect(url_for("store_dispatch"))

    dispatch_date_raw = request.form.get("dispatch_date")
    try:
        dispatch_date = datetime.datetime.strptime(dispatch_date_raw, "%Y-%m-%d").date() if dispatch_date_raw else None
    except ValueError:
        dispatch_date = None

    target_inv = InventoryItem.query.filter_by(item_code=item_code).first()

    if not target_inv:
        flash("The selected item is not available in inventory.", "danger")
        return redirect(url_for("store_dispatch"))

    available_stock = (target_inv.current_stock or 0)

    if quantity > available_stock:
        flash("Insufficient stock available for this dispatch quantity.", "danger")
        return redirect(url_for("store_dispatch"))

    dispatch.project_id = request.form.get("project_id") or None
    dispatch.dispatch_number = request.form.get("dispatch_number") or dispatch.dispatch_number
    dispatch.dispatch_date = dispatch_date
    dispatch.vehicle_details = request.form.get("vehicle_details")
    dispatch.driver_name = request.form.get("driver_name")
    dispatch.notes = request.form.get("notes")
    dispatch.is_completed = False
    dispatch.completed_at = None
    dispatch.status = "Draft"

    existing_item = dispatch.items[0] if dispatch.items else None
    if not existing_item:
        existing_item = DeliveryChallanItem(delivery_challan_id=dispatch.id)
        db.session.add(existing_item)

    existing_item.item_code = item_code
    existing_item.description = request.form.get("description")
    existing_item.unit = request.form.get("unit")
    existing_item.quantity_dispatched = quantity

    db.session.commit()
    flash("Delivery challan updated.", "success")
    return redirect(url_for("store_dispatch"))


@app.route("/store/dispatch/<int:dispatch_id>/complete", methods=["POST"])
@login_required
def complete_dispatch(dispatch_id):
    ensure_bootstrap()
    dispatch = DeliveryChallan.query.options(subqueryload(DeliveryChallan.items)).filter_by(id=dispatch_id).first_or_404()

    if dispatch.status == "Delivered" or dispatch.is_completed:
        flash("Delivery challan already marked as delivered.", "info")
        return redirect(url_for("store_dispatch"))

    for item in dispatch.items:
        inv = InventoryItem.query.filter_by(item_code=item.item_code).first()
        if not inv:
            continue
        _initialize_book_stock(inv)
        inv.current_stock = (inv.current_stock or 0) - (item.qty_delivered or 0)
        if not dispatch.delivery_order_id:
            inv.book_stock = (inv.book_stock or inv.current_stock or 0) - (item.qty_delivered or 0)

        if dispatch.delivery_order_id and item.delivery_order_item_id:
            doi = DeliveryOrderItem.query.filter_by(id=item.delivery_order_item_id).first()
            if doi:
                doi.delivered_qty_total = (doi.delivered_qty_total or 0) + (item.qty_delivered or 0)

    if dispatch.delivery_order_id:
        order = DeliveryOrder.query.options(subqueryload(DeliveryOrder.items)).filter_by(id=dispatch.delivery_order_id).first()
        if order:
            all_fulfilled = True
            for order_item in order.items:
                reserved = order_item.reserved_qty or order_item.requested_qty or 0
                delivered = order_item.delivered_qty_total or 0
                if delivered < reserved:
                    all_fulfilled = False
            order.status = "Completed" if all_fulfilled else "Partially Delivered"

    dispatch.status = "Delivered"
    dispatch.delivered_at = datetime.datetime.utcnow()
    dispatch.is_completed = True
    dispatch.completed_at = dispatch.delivered_at

    db.session.commit()
    # TODO: create_notification for purchase team when a DC is delivered.
    flash("Delivery challan marked as delivered.", "success")

    return redirect(url_for("store_dispatch"))


# ---------------------- SAFE DB REPAIR / MIGRATIONS ----------------------
def ensure_qc_columns():
    """Check and auto-add 'stage' and 'lift_type' in form_schema, and 'work_id' in submission."""
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_qc_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    # form_schema
    cur.execute("PRAGMA table_info(form_schema)")
    fs_cols = [r[1] for r in cur.fetchall()]
    added_fs = []
    if "stage" not in fs_cols:
        cur.execute("ALTER TABLE form_schema ADD COLUMN stage TEXT;")
        added_fs.append("stage")
    if "lift_type" not in fs_cols:
        cur.execute("ALTER TABLE form_schema ADD COLUMN lift_type TEXT;")
        added_fs.append("lift_type")
    if "is_primary" not in fs_cols:
        cur.execute("ALTER TABLE form_schema ADD COLUMN is_primary INTEGER DEFAULT 0;")
        added_fs.append("is_primary")
    if "updated_at" not in fs_cols:
        cur.execute("ALTER TABLE form_schema ADD COLUMN updated_at DATETIME;")
        cur.execute("UPDATE form_schema SET updated_at = CURRENT_TIMESTAMP WHERE updated_at IS NULL;")
        added_fs.append("updated_at")

    # submission
    cur.execute("PRAGMA table_info(submission)")
    sub_cols = [r[1] for r in cur.fetchall()]
    added_sub = []
    if "work_id" not in sub_cols:
        cur.execute("ALTER TABLE submission ADD COLUMN work_id INTEGER;")
        added_sub.append("work_id")

    # user profile additions
    cur.execute("PRAGMA table_info(user)")
    user_cols = [r[1] for r in cur.fetchall()]
    added_user = []
    user_column_defs = {
        "first_name": "TEXT",
        "last_name": "TEXT",
        "department": "TEXT",
        "role": "TEXT",
        "mobile_number": "TEXT",
        "email": "TEXT",
        "display_picture": "TEXT",
        "active": "INTEGER DEFAULT 1",
        "session_token": "TEXT",
        "position_id": "INTEGER",
        "module_permissions_json": "TEXT"
    }
    for col, col_type in user_column_defs.items():
        if col not in user_cols:
            cur.execute(f"ALTER TABLE user ADD COLUMN {col} {col_type};")
            added_user.append(col)

    # department additions
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='department'")
    department_exists = cur.fetchone() is not None
    added_department_cols = []
    if department_exists:
        cur.execute("PRAGMA table_info(department)")
        department_cols = [r[1] for r in cur.fetchall()]
        if "branch" not in department_cols:
            cur.execute("ALTER TABLE department ADD COLUMN branch TEXT DEFAULT 'Goa';")
            cur.execute("UPDATE department SET branch = COALESCE(branch, 'Goa');")
            added_department_cols.append("branch")

    # qc_work (only attempt to alter when table exists)
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='qc_work'")
    qc_exists = cur.fetchone() is not None
    added_qc = []
    if qc_exists:
        cur.execute("PRAGMA table_info(qc_work)")
        qc_cols = [r[1] for r in cur.fetchall()]
        if "assigned_to" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN assigned_to INTEGER;")
            added_qc.append("assigned_to")
        if "project_id" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN project_id INTEGER;")
            added_qc.append("project_id")
        if "name" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN name TEXT;")
            added_qc.append("name")
        if "description" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN description TEXT;")
            added_qc.append("description")
        if "template_task_id" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN template_task_id INTEGER;")
            added_qc.append("template_task_id")
        if "depends_on_id" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN depends_on_id INTEGER;")
            added_qc.append("depends_on_id")
        if "planned_start_date" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN planned_start_date TEXT;")
            added_qc.append("planned_start_date")
        if "planned_duration_days" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN planned_duration_days INTEGER;")
            added_qc.append("planned_duration_days")
        if "milestone" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN milestone TEXT;")
            added_qc.append("milestone")
        if "project_task_id" not in qc_cols:
            cur.execute("ALTER TABLE qc_work ADD COLUMN project_task_id INTEGER;")
            added_qc.append("project_task_id")

    # project_template_task additions
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='project_template_task'")
    template_task_exists = cur.fetchone() is not None
    added_template_cols = []
    if template_task_exists:
        cur.execute("PRAGMA table_info(project_template_task)")
        template_cols = [r[1] for r in cur.fetchall()]
        if "task_type" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN task_type TEXT DEFAULT 'general';")
            added_template_cols.append("task_type")
        if "depends_on_id" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN depends_on_id INTEGER;")
            added_template_cols.append("depends_on_id")
        if "start_mode" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN start_mode TEXT DEFAULT 'immediate';")
            added_template_cols.append("start_mode")
        if "planned_start_date" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN planned_start_date TEXT;")
            added_template_cols.append("planned_start_date")
        if "duration_days" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN duration_days INTEGER;")
            added_template_cols.append("duration_days")
        if "milestone" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN milestone TEXT;")
            added_template_cols.append("milestone")
        if "module" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN module TEXT DEFAULT 'general';")
            added_template_cols.append("module")
        if "task_subtype" not in template_cols:
            cur.execute("ALTER TABLE project_template_task ADD COLUMN task_subtype TEXT DEFAULT 'general';")
            added_template_cols.append("task_subtype")

        cur.execute(
            "UPDATE project_template_task SET module = 'qc', task_subtype = 'qc' "
            "WHERE lower(task_type) = 'qc' AND (module IS NULL OR module = '' OR module = 'general')"
        )
        cur.execute(
            "UPDATE project_template_task SET module = 'srt', task_subtype = 'srt' "
            "WHERE lower(task_type) = 'srt' AND (module IS NULL OR module = '')"
        )
        cur.execute(
            "UPDATE project_template_task SET module = 'design' "
            "WHERE lower(task_type) = 'design' AND (module IS NULL OR module = '')"
        )
        cur.execute(
            "UPDATE project_template_task SET task_subtype = 'drawing' "
            "WHERE module = 'design' AND (task_subtype IS NULL OR task_subtype = '' OR task_subtype = 'general')"
        )
        cur.execute(
            "UPDATE project_template_task SET module = 'general', task_subtype = 'general' "
            "WHERE module IS NULL OR module = ''"
        )

    dependency_tables = [
        (
            "project_template_task_dependency",
            "project_template_task",
        ),
        (
            "project_task_dependency",
            "project_tasks",
        ),
        (
            "qc_work_dependency",
            "qc_work",
        ),
    ]
    for table_name, parent_table in dependency_tables:
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
        if cur.fetchone() is None:
            cur.execute(
                f"""
                CREATE TABLE {table_name} (
                    id INTEGER PRIMARY KEY,
                    task_id INTEGER NOT NULL,
                    depends_on_id INTEGER NOT NULL,
                    UNIQUE(task_id, depends_on_id),
                    FOREIGN KEY(task_id) REFERENCES {parent_table}(id),
                    FOREIGN KEY(depends_on_id) REFERENCES {parent_table}(id)
                );
                """
            )

    # project additions
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='project'")
    project_exists = cur.fetchone() is not None
    added_project_cols = []
    if project_exists:
        cur.execute("PRAGMA table_info(project)")
        project_cols = {row[1]: (row[2] or "").upper() for row in cur.execute("PRAGMA table_info(project)")}

        if "floors" in project_cols and project_cols["floors"] not in {"TEXT", "VARCHAR", "NVARCHAR"}:
            cur.execute("ALTER TABLE project RENAME COLUMN floors TO floors_numeric;")
            project_cols = {row[1]: (row[2] or "").upper() for row in cur.execute("PRAGMA table_info(project)")}

        project_column_defs = {
            "floors": "TEXT",
            "stops": "INTEGER",
            "opening_type": "TEXT",
            "location": "TEXT",
            "handover_date": "TEXT",
            "priority": "TEXT",
            "structure_type": "TEXT",
            "cladding_type": "TEXT",
            "cabin_finish": "TEXT",
            "door_operation_type": "TEXT",
            "door_finish": "TEXT",
        }
        for col, col_type in project_column_defs.items():
            if col not in project_cols:
                cur.execute(f"ALTER TABLE project ADD COLUMN {col} {col_type};")
                added_project_cols.append(col)

        if "floors_numeric" in project_cols and "floors" in project_column_defs:
            cur.execute(
                "UPDATE project SET floors = CASE WHEN floors IS NULL OR floors = '' THEN CAST(floors_numeric AS TEXT) ELSE floors END WHERE floors_numeric IS NOT NULL;"
            )

    conn.commit()
    conn.close()

    if added_fs:
        print(f"✅ Auto-added in form_schema: {', '.join(added_fs)}")
    else:
        print("✔️ form_schema OK")

    if added_sub:
        print(f"✅ Auto-added in submission: {', '.join(added_sub)}")
    else:
        print("✔️ submission OK")

    if added_user:
        print(f"✅ Auto-added in user: {', '.join(added_user)}")
    else:
        print("✔️ user OK")

    if qc_exists:
        if added_qc:
            print(f"✅ Auto-added in qc_work: {', '.join(added_qc)}")
        else:
            print("✔️ qc_work OK")
    else:
        print("ℹ️ qc_work table did not exist prior to ensure_qc_columns")

    if department_exists:
        if added_department_cols:
            print(f"✅ Auto-added in department: {', '.join(added_department_cols)}")
        else:
            print("✔️ department OK")

    if template_task_exists:
        if added_template_cols:
            print(f"✅ Auto-added in project_template_task: {', '.join(added_template_cols)}")
        else:
            print("✔️ project_template_task OK")

    if added_project_cols:
        print(f"✅ Auto-added in project: {', '.join(added_project_cols)}")
    else:
        print("✔️ project OK")


def ensure_lift_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_lift_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    cur.execute("PRAGMA table_info(lift)")
    lift_cols = [row[1] for row in cur.fetchall()]
    added_cols = []

    column_defs = [
        ("remarks", "TEXT"),
        ("preferred_service_date", "DATE"),
        ("preferred_service_time", "TEXT"),
        ("preferred_service_day", "TEXT"),
        ("lift_brand", "TEXT"),
        ("amc_contract_id", "TEXT"),
        ("building_villa_number", "TEXT"),
        ("geo_location", "TEXT"),
        ("amc_duration_key", "TEXT"),
        ("preferred_service_days_json", "TEXT"),
        ("lifetime_metrics_json", "TEXT"),
        ("amc_contacts_json", "TEXT"),
        ("timeline_entries_json", "TEXT"),
        ("service_schedule_json", "TEXT"),
        # Backward-compatibility columns for databases created before
        # warranty/AMC enhancements landed.
        ("warranty_start_date", "DATE"),
        ("warranty_end_date", "DATE"),
        ("warranty_expiry", "DATE"),
        ("amc_status", "TEXT"),
        ("amc_start", "DATE"),
        ("amc_end", "DATE"),
        ("capacity_display", "TEXT"),
        ("last_updated_by", "TEXT"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in lift_cols:
            cur.execute(f"ALTER TABLE lift ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in lift: {', '.join(added_cols)}")
    else:
        print("✔️ lift OK")


def ensure_service_route_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_service_route_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    cur.execute("PRAGMA table_info(service_route)")
    route_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    if "branch" not in route_cols:
        cur.execute("ALTER TABLE service_route ADD COLUMN branch TEXT;")
        added_cols.append("branch")

    # One-time SQL fallback for older SQLite DBs without migrations:
    # ALTER TABLE service_route ADD COLUMN remark VARCHAR(255);
    if "remark" not in route_cols:
        cur.execute("ALTER TABLE service_route ADD COLUMN remark VARCHAR(255);")
        added_cols.append("remark")

    before_update = conn.total_changes
    cur.execute(
        """
        UPDATE service_route
        SET branch = CASE
            WHEN lower(state) = 'goa' THEN 'Goa'
            WHEN lower(state) = 'maharashtra' THEN 'Mumbai'
            WHEN lower(state) = 'karnataka' THEN 'Mumbai'
            ELSE branch
        END
        WHERE branch IS NULL
        """
    )
    branch_backfill_changes = conn.total_changes - before_update

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in service_route: {', '.join(added_cols)}")
    elif branch_backfill_changes:
        print("♻️ service_route branches backfilled")
    else:
        print("✔️ service_route OK")


def ensure_customer_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_customer_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    cur.execute("PRAGMA table_info(customer)")
    customer_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("office_address_line1", "TEXT"),
        ("office_address_line2", "TEXT"),
        ("office_city", "TEXT"),
        ("office_state", "TEXT"),
        ("office_pincode", "TEXT"),
        ("office_country", "TEXT"),
        ("external_customer_id", "TEXT"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in customer_cols:
            cur.execute(f"ALTER TABLE customer ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in customer: {', '.join(added_cols)}")
    else:
        print("✔️ customer OK")


def ensure_vendor_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_vendor_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(vendor)")
    vendor_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("vendor_code", "TEXT"),
        ("activities", "TEXT"),
        ("city", "TEXT"),
        ("country", "TEXT"),
        ("salesperson", "TEXT"),
        ("gstin", "TEXT"),
        ("address_line1", "TEXT"),
        ("address_line2", "TEXT"),
        ("pincode", "TEXT"),
        ("state", "TEXT"),
        ("address", "TEXT"),
        ("notes", "TEXT"),
        ("is_active", "INTEGER DEFAULT 1"),
        ("last_used_at", "DATETIME"),
        ("created_at", "DATETIME"),
        ("updated_at", "DATETIME"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in vendor_cols:
            cur.execute(f"ALTER TABLE vendor ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in vendor: {', '.join(added_cols)}")
    else:
        print("✔️ vendor OK")


def ensure_product_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_product_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(product)")
    product_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("sale_price", "REAL"),
        ("cost", "REAL"),
        ("uom", "TEXT"),
        ("purchase_uom", "TEXT"),
        ("qty_on_hand", "REAL DEFAULT 0"),
        ("forecast_qty", "REAL DEFAULT 0"),
        ("is_favorite", "INTEGER DEFAULT 0"),
        ("is_active", "INTEGER DEFAULT 1"),
        ("part_class_id", "INTEGER"),
        ("primary_vendor", "TEXT"),
        ("linked_vendors", "TEXT"),
        ("specifications", "TEXT"),
        ("notes", "TEXT"),
        ("sku", "TEXT"),
        ("category", "TEXT"),
        ("created_at", "DATETIME"),
        ("updated_at", "DATETIME"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in product_cols:
            cur.execute(f"ALTER TABLE product ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in product: {', '.join(added_cols)}")
    else:
        print("✔️ product OK")


def ensure_sales_client_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_sales_client_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    cur.execute("PRAGMA table_info(sales_client)")
    client_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("email_opt_out", "TEXT"),
        ("company_id", "INTEGER"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in client_cols:
            cur.execute(f"ALTER TABLE sales_client ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in sales_client: {', '.join(added_cols)}")
    else:
        print("✔️ sales_client OK")


def ensure_sales_task_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_sales_task_columns: database is not a SQLite file.")
        return
    cur = conn.cursor()

    cur.execute("PRAGMA table_info(sales_task)")
    task_cols = {row[1] for row in cur.fetchall()}
    added_cols = []
    created_tables = []

    column_defs = [
        ("related_type", "TEXT"),
        ("opportunity_id", "INTEGER"),
        ("client_id", "INTEGER"),
        ("assignee_id", "INTEGER"),
        ("created_by_id", "INTEGER"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in task_cols:
            cur.execute(f"ALTER TABLE sales_task ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    if "assignee_id" not in task_cols:
        cur.execute(
            "UPDATE sales_task SET assignee_id = owner_id WHERE assignee_id IS NULL;"
        )
    if "created_by_id" not in task_cols:
        cur.execute(
            "UPDATE sales_task SET created_by_id = owner_id WHERE created_by_id IS NULL;"
        )

    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='sales_task_assignee'"
    )
    assignee_table_exists = cur.fetchone() is not None
    if not assignee_table_exists:
        cur.execute(
            "CREATE TABLE sales_task_assignee (task_id INTEGER NOT NULL, user_id INTEGER NOT NULL, PRIMARY KEY (task_id, user_id));"
        )
        created_tables.append("sales_task_assignee")

    cur.execute(
        "INSERT OR IGNORE INTO sales_task_assignee (task_id, user_id) SELECT id, assignee_id FROM sales_task WHERE assignee_id IS NOT NULL;"
    )

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in sales_task: {', '.join(added_cols)}")
    if created_tables:
        print(f"✅ Created missing tables: {', '.join(created_tables)}")
    if not added_cols and not created_tables:
        print("✔️ sales_task OK")


def ensure_sales_opportunity_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print(
            "⚠️ Skipping ensure_sales_opportunity_columns: database is not a SQLite file."
        )
        return
    cur = conn.cursor()

    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='sales_opportunity'"
    )
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        return

    cur.execute("PRAGMA table_info(sales_opportunity)")
    cols = [row[1] for row in cur.fetchall()]
    added = []

    if "project_id" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN project_id INTEGER;")
        added.append("project_id")
    if "final_crf_id" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN final_crf_id INTEGER;")
        added.append("final_crf_id")
    if "final_quotation_file_id" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN final_quotation_file_id INTEGER;")
        added.append("final_quotation_file_id")
    if "closed_status" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN closed_status TEXT;")
        added.append("closed_status")
    if "closed_at" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN closed_at DATETIME;")
        added.append("closed_at")
    if "closed_reason" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN closed_reason TEXT;")
        added.append("closed_reason")

    if "created_at" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN created_at DATETIME;")
        added.append("created_at")

    if "updated_at" not in cols:
        cur.execute("ALTER TABLE sales_opportunity ADD COLUMN updated_at DATETIME;")
        added.append("updated_at")

    cur.execute(
        """
        UPDATE sales_opportunity
        SET created_at = COALESCE(created_at, updated_at, CURRENT_TIMESTAMP)
        WHERE created_at IS NULL
        """
    )

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in sales_opportunity: {', '.join(added)}")
    else:
        print("✔️ sales_opportunity OK")


def ensure_sales_opportunity_item_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_sales_opportunity_item_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='sales_opportunity_item'"
    )
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        return

    cur.execute("PRAGMA table_info(sales_opportunity_item)")
    cols = [row[1] for row in cur.fetchall()]
    added = []

    if "item_value" not in cols:
        cur.execute("ALTER TABLE sales_opportunity_item ADD COLUMN item_value NUMERIC;")
        added.append("item_value")
    if "project_id" not in cols:
        cur.execute("ALTER TABLE sales_opportunity_item ADD COLUMN project_id INTEGER;")
        added.append("project_id")

    cur.execute(
        """
        UPDATE sales_opportunity_item
        SET quantity = 1
        WHERE quantity IS NULL OR quantity < 1
        """
    )

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in sales_opportunity_item: {', '.join(added)}")
    else:
        print("✔️ sales_opportunity_item OK")


def ensure_sales_opportunity_engagement_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_sales_opportunity_engagement_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='sales_opportunity_engagement'"
    )
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        return

    cur.execute("PRAGMA table_info(sales_opportunity_engagement)")
    cols = {row[1] for row in cur.fetchall()}
    added = []

    additions = [
        ("status", "TEXT DEFAULT 'open'"),
        ("completed_at", "DATETIME"),
        ("completed_by_id", "INTEGER"),
        ("outcome", "TEXT"),
        ("log_details", "TEXT"),
    ]

    for column, ctype in additions:
        if column not in cols:
            cur.execute(f"ALTER TABLE sales_opportunity_engagement ADD COLUMN {column} {ctype};")
            added.append(column)

    if "status" in cols or "status" in [name for name, _ in additions]:
        cur.execute(
            "UPDATE sales_opportunity_engagement SET status = COALESCE(NULLIF(status, ''), 'open')"
        )

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in sales_opportunity_engagement: {', '.join(added)}")
    else:
        print("✔️ sales_opportunity_engagement OK")


def ensure_sales_opportunity_file_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_sales_opportunity_file_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='sales_opportunity_file'"
    )
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        return

    cur.execute("PRAGMA table_info(sales_opportunity_file)")
    cols = {row[1] for row in cur.fetchall()}
    added = []

    if "quotation_request_id" not in cols:
        cur.execute("ALTER TABLE sales_opportunity_file ADD COLUMN quotation_request_id INTEGER;")
        added.append("quotation_request_id")

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in sales_opportunity_file: {', '.join(added)}")
    else:
        print("✔️ sales_opportunity_file OK")


def ensure_user_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_user_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='user'")
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        return

    cur.execute("PRAGMA table_info(user)")
    cols = [row[1] for row in cur.fetchall()]
    added = []

    if "is_service_manager" not in cols:
        cur.execute("ALTER TABLE user ADD COLUMN is_service_manager INTEGER DEFAULT 0;")
        added.append("is_service_manager")

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in user: {', '.join(added)}")
    else:
        print("✔️ user table OK")


def ensure_tables():
    """Ensure all known tables exist. Creates them if missing."""
    created_tables = []
    inspector = inspect(db.engine)
    try:
        existing_tables = set(inspector.get_table_names())
    except OperationalError:
        # Database file might be missing – create all tables fresh.
        db.create_all()
        existing_tables = set(inspect(db.engine).get_table_names())

    models = [
        Department.__table__,
        Position.__table__,
        User.__table__,
        Project.__table__,
        ProjectComment.__table__,
        FormSchema.__table__,
        FormTemplate.__table__,
        Submission.__table__,
        ProjectTemplate.__table__,
        ProjectTemplateTask.__table__,
        ProjectTemplateTaskDependency.__table__,
        ProjectTask.__table__,
        ProjectTaskDependency.__table__,
        TaskTemplate.__table__,
        SalesCompany.__table__,
        SalesClient.__table__,
        SalesOpportunity.__table__,
        SalesActivity.__table__,
        SalesTask.__table__,
        sales_task_assignees,
        SalesOpportunityComment.__table__,
        SalesOpportunityFile.__table__,
        SalesOpportunityEngagement.__table__,
        SalesOpportunityItem.__table__,
        SalesQuotationRequest.__table__,
        SalesQuotationRequestItem.__table__,
        SalesQuotationNegotiationLog.__table__,
        ServiceRoute.__table__,
        ServiceTask.__table__,
        Customer.__table__,
        CustomerComment.__table__,
        Lift.__table__,
        LiftFile.__table__,
        LiftComment.__table__,
        DropdownOption.__table__,
        ServiceDropdownOption.__table__,
        QCWork.__table__,
        QCWorkDependency.__table__,
        QCWorkComment.__table__,
        QCWorkLog.__table__,
        Notification.__table__,
        CallLog.__table__,
        CallRecording.__table__,
        DesignTask.__table__,
        DesignTaskComment.__table__,
        DesignDrawing.__table__,
        DesignDrawingRevision.__table__,
        DrawingSite.__table__,
        DrawingVersion.__table__,
        DrawingComment.__table__,
        DrawingHistory.__table__,
        SRTTask.__table__,
        ProcurementStage.__table__,
        PartClass.__table__,
        BomTemplate.__table__,
        BomTemplateInput.__table__,
        BomTemplateStage.__table__,
        BomTemplateSection.__table__,
        BomTemplateLine.__table__,
        BillOfMaterials.__table__,
        BOMPackage.__table__,
        BOMItem.__table__,
        Product.__table__,
        Vendor.__table__,
        VendorIssue.__table__,
        VendorProductRate.__table__,
        PurchaseOrder.__table__,
        PurchaseOrderLine.__table__,
        PurchaseOrderItem.__table__,
        BookInventory.__table__,
        InventoryItem.__table__,
        InventoryStock.__table__,
        StockAdjustment.__table__,
        InventoryReceipt.__table__,
        InventoryReceiptItem.__table__,
        DeliveryChallan.__table__,
        DeliveryChallanItem.__table__,
        DeliveryOrder.__table__,
        DeliveryOrderItem.__table__,
        ClientRequirementForm.__table__,
    ]

    for table in models:
        if table.name not in existing_tables:
            table.create(bind=db.engine, checkfirst=True)
            created_tables.append(table.name)

    if created_tables:
        print(f"✅ Created missing tables: {', '.join(created_tables)}")


def _ensure_sqlite_table(table_name, table_obj, column_defs):
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print(f"⚠️ Skipping ensure_{table_name}_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
        (table_name,),
    )
    exists = cur.fetchone() is not None
    if not exists:
        conn.close()
        table_obj.create(bind=db.engine, checkfirst=True)
        print(f"✅ Created missing table: {table_name}")
        return

    cur.execute(f"PRAGMA table_info({table_name})")
    cols = {row[1] for row in cur.fetchall()}
    added = []
    for column_name, column_type in column_defs:
        if column_name not in cols:
            cur.execute(
                f"ALTER TABLE {table_name} ADD COLUMN {column_name} {column_type};"
            )
            added.append(column_name)

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in {table_name}: {', '.join(added)}")
    else:
        print(f"✔️ {table_name} OK")


def ensure_part_class_table():
    _ensure_sqlite_table(
        "part_class",
        PartClass.__table__,
        [
            ("name", "TEXT"),
            ("description", "TEXT"),
            ("active", "INTEGER DEFAULT 1"),
            ("sort_order", "INTEGER DEFAULT 0"),
            ("associated_sections", "TEXT"),
            ("primary_part_id", "INTEGER"),
        ],
    )


def ensure_bom_template_table():
    _ensure_sqlite_table(
        "bom_template",
        BomTemplate.__table__,
        [
            ("name", "TEXT"),
            ("lift_type", "TEXT"),
            ("description", "TEXT"),
            ("is_active", "INTEGER DEFAULT 1"),
            ("created_at", "DATETIME"),
            ("created_by_id", "INTEGER"),
        ],
    )


def ensure_bom_template_input_table():
    _ensure_sqlite_table(
        "bom_template_input",
        BomTemplateInput.__table__,
        [
            ("template_id", "INTEGER"),
            ("input_key", "TEXT"),
            ("label", "TEXT"),
            ("unit", "TEXT"),
            ("default_value", "TEXT"),
            ("data_type", "TEXT"),
            ("required", "INTEGER DEFAULT 0"),
        ],
    )


def ensure_bom_template_stage_table():
    _ensure_sqlite_table(
        "bom_template_stage",
        BomTemplateStage.__table__,
        [
            ("template_id", "INTEGER"),
            ("stage_name", "TEXT"),
            ("display_order", "INTEGER DEFAULT 0"),
        ],
    )


def ensure_bom_template_section_table():
    _ensure_sqlite_table(
        "bom_template_section",
        BomTemplateSection.__table__,
        [
            ("stage_id", "INTEGER"),
            ("section_name", "TEXT"),
            ("include_if_expr", "TEXT"),
            ("display_order", "INTEGER DEFAULT 0"),
        ],
    )


def ensure_bom_template_line_table():
    _ensure_sqlite_table(
        "bom_template_line",
        BomTemplateLine.__table__,
        [
            ("section_id", "INTEGER"),
            ("ref_key", "TEXT"),
            ("part_class_id", "INTEGER"),
            ("specification_text", "TEXT"),
            ("unit", "TEXT"),
            ("include_if_expr", "TEXT"),
            ("qty_expr", "TEXT"),
            ("override_if_expr", "TEXT"),
            ("override_qty_expr", "TEXT"),
            ("display_order", "INTEGER DEFAULT 0"),
        ],
    )


def ensure_bom_package_table():
    _ensure_sqlite_table(
        "bom_package",
        BOMPackage.__table__,
        [
            ("bom_id", "INTEGER"),
            ("name", "TEXT"),
            ("status", "TEXT DEFAULT 'draft'"),
            ("bom_template_id", "INTEGER"),
            ("input_snapshot_json", "TEXT"),
            ("generated_at", "DATETIME"),
            ("generated_by_user_id", "INTEGER"),
            ("created_at", "DATETIME"),
        ],
    )


def ensure_project_comment_table():
    """Backfill the project_comment table for legacy databases."""
    try:
        inspector = inspect(db.engine)
        table_names = {name.lower() for name in inspector.get_table_names()}
    except OperationalError:
        table_names = set()

    if "project_comment" in table_names:
        return

    # Use SQLAlchemy metadata to create the table if it is missing. checkfirst
    # guards against race conditions with ensure_tables.
    ProjectComment.__table__.create(bind=db.engine, checkfirst=True)
    print("✅ Backfilled missing table: project_comment")


def _current_role_key():
    return (current_user.role or "").strip().lower()


def _require_delivery_order_permission(action: str):
    role = _current_role_key()
    if role in {"admin", "purchase"}:
        return "full"

    if role == "store" and action in {"view", "create", "dispatch"}:
        return "limited"

    abort(403)


def _require_inventory_adjust_permission():
    role = _current_role_key()
    if role in {"admin", "store"}:
        return
    abort(403)


def ensure_project_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_project_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(project)")
    project_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("sales_won_at", "DATETIME"),
        ("sales_executive_name", "TEXT"),
        ("opportunity_id", "INTEGER"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in project_cols:
            cur.execute(f"ALTER TABLE project ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in project: {', '.join(added_cols)}")
    else:
        print("✔️ project OK")


def ensure_inventory_item_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_inventory_item_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(inventory_item)")
    cols = {row[1] for row in cur.fetchall()}
    added = []

    if "book_stock" not in cols:
        cur.execute("ALTER TABLE inventory_item ADD COLUMN book_stock REAL DEFAULT 0;")
        added.append("book_stock")

    cur.execute(
        "UPDATE inventory_item SET book_stock = current_stock "
        "WHERE book_stock IS NULL OR (book_stock = 0 AND current_stock IS NOT NULL);"
    )

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in inventory_item: {', '.join(added)}")
    else:
        print("✔️ inventory_item OK")


def ensure_delivery_order_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_delivery_order_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(delivery_order)")
    cols = {row[1] for row in cur.fetchall()}
    added = []

    additions = [
        ("project_id", "INTEGER"),
        ("related_po_id", "INTEGER"),
        ("stage_id", "INTEGER"),
    ]
    for column, ctype in additions:
        if column not in cols:
            cur.execute(f"ALTER TABLE delivery_order ADD COLUMN {column} {ctype};")
            added.append(column)

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in delivery_order: {', '.join(added)}")
    else:
        print("✔️ delivery_order OK")


def ensure_delivery_order_item_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_delivery_order_item_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(delivery_order_item)")
    cols = {row[1] for row in cur.fetchall()}
    added = []

    if "item_code" not in cols:
        cur.execute("ALTER TABLE delivery_order_item ADD COLUMN item_code TEXT;")
        cur.execute("UPDATE delivery_order_item SET item_code = product_name WHERE item_code IS NULL;")
        added.append("item_code")
    if "reserved_qty" not in cols:
        cur.execute("ALTER TABLE delivery_order_item ADD COLUMN reserved_qty REAL DEFAULT 0;")
        cur.execute("UPDATE delivery_order_item SET reserved_qty = quantity WHERE reserved_qty = 0;")
        added.append("reserved_qty")
    if "delivered_qty_total" not in cols:
        cur.execute("ALTER TABLE delivery_order_item ADD COLUMN delivered_qty_total REAL DEFAULT 0;")
        added.append("delivered_qty_total")

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in delivery_order_item: {', '.join(added)}")
    else:
        print("✔️ delivery_order_item OK")


def ensure_delivery_challan_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_delivery_challan_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(dispatch)")
    dispatch_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    column_defs = [
        ("delivery_order_id", "INTEGER"),
        ("created_by_user_id", "INTEGER"),
        ("delivered_at", "DATETIME"),
        ("status", "TEXT"),
        ("created_at", "DATETIME"),
    ]

    for column_name, column_type in column_defs:
        if column_name not in dispatch_cols:
            cur.execute(f"ALTER TABLE dispatch ADD COLUMN {column_name} {column_type};")
            added_cols.append(column_name)

    if "is_completed" not in dispatch_cols:
        cur.execute("ALTER TABLE dispatch ADD COLUMN is_completed INTEGER DEFAULT 0;")
        added_cols.append("is_completed")

    if "completed_at" not in dispatch_cols:
        cur.execute("ALTER TABLE dispatch ADD COLUMN completed_at DATETIME;")
        added_cols.append("completed_at")

    cur.execute("PRAGMA table_info(dispatch_item)")
    item_cols = {row[1] for row in cur.fetchall()}
    item_added = []
    if "delivery_challan_id" not in item_cols:
        cur.execute("ALTER TABLE dispatch_item ADD COLUMN delivery_challan_id INTEGER;")
        item_added.append("delivery_challan_id")

        if "dispatch_id" in item_cols:
            cur.execute(
                "UPDATE dispatch_item SET delivery_challan_id = dispatch_id "
                "WHERE delivery_challan_id IS NULL;"
            )
    if "delivery_order_item_id" not in item_cols:
        cur.execute("ALTER TABLE dispatch_item ADD COLUMN delivery_order_item_id INTEGER;")
        item_added.append("delivery_order_item_id")

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in dispatch: {', '.join(added_cols)}")
    else:
        print("✔️ dispatch OK")
    if item_added:
        print(f"✅ Auto-added in dispatch_item: {', '.join(item_added)}")


def ensure_design_task_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_design_task_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='design_task'")
    exists = cur.fetchone() is not None

    if not exists:
        conn.close()
        print("ℹ️ design_task table does not exist; skipping ensure_design_task_columns.")
        return

    cur.execute("PRAGMA table_info(design_task)")
    design_task_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    if "subtype" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN subtype TEXT;")
        added_cols.append("subtype")

    if "task_name" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN task_name TEXT;")
        added_cols.append("task_name")

    if "origin_type" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN origin_type TEXT;")
        added_cols.append("origin_type")

    if "origin_id" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN origin_id INTEGER;")
        added_cols.append("origin_id")

    if "origin_reference" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN origin_reference TEXT;")
        added_cols.append("origin_reference")

    if "notes" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN notes TEXT;")
        added_cols.append("notes")
    if "attachment" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN attachment TEXT;")
        added_cols.append("attachment")
    if "parent_task_id" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN parent_task_id INTEGER;")
        added_cols.append("parent_task_id")
    if "project_task_id" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN project_task_id INTEGER;")
        added_cols.append("project_task_id")
    if "has_pending_inputs" not in design_task_cols:
        cur.execute("ALTER TABLE design_task ADD COLUMN has_pending_inputs INTEGER DEFAULT 1;")
        added_cols.append("has_pending_inputs")

    cur.execute(
        "UPDATE design_task SET status = 'In progress' WHERE status IS NULL OR TRIM(status) = '';"
    )
    cur.execute(
        "UPDATE design_task SET task_type = 'design' WHERE lower(trim(task_type)) IN ('drawing', 'bom', 'sales_query');"
    )
    cur.execute(
        "UPDATE design_task SET task_name = COALESCE(NULLIF(TRIM(task_name), ''), description, 'Untitled task');"
    )
    cur.execute(
        """
        UPDATE design_task
        SET has_pending_inputs = CASE
            WHEN EXISTS (
                SELECT 1
                FROM design_drawing
                WHERE design_drawing.design_task_id = design_task.id
            ) THEN 0
            ELSE 1
        END;
        """
    )

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in design_task: {', '.join(added_cols)}")
    else:
        print("✔️ design_task OK")


def ensure_design_drawing_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_design_drawing_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='design_drawing'")
    exists = cur.fetchone() is not None

    if not exists:
        conn.close()
        print("ℹ️ design_drawing table does not exist; skipping ensure_design_drawing_columns.")
        return

    cur.execute("PRAGMA table_info(design_drawing)")
    drawing_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    if "drawing_type" not in drawing_cols:
        cur.execute("ALTER TABLE design_drawing ADD COLUMN drawing_type TEXT DEFAULT 'Other';")
        added_cols.append("drawing_type")

    if "status" not in drawing_cols:
        cur.execute("ALTER TABLE design_drawing ADD COLUMN status TEXT DEFAULT 'Draft';")
        added_cols.append("status")

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in design_drawing: {', '.join(added_cols)}")
    else:
        print("✔️ design_drawing OK")


def ensure_drawing_status_log_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_drawing_status_log_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS drawing_status_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            drawing_site_id INTEGER,
            drawing_id INTEGER,
            old_status TEXT,
            new_status TEXT NOT NULL,
            changed_by_user_id INTEGER,
            changed_at DATETIME,
            remark TEXT
        );
        """
    )
    cur.execute(
        "CREATE INDEX IF NOT EXISTS ix_drawing_status_log_drawing_site_id ON drawing_status_log (drawing_site_id);"
    )
    cur.execute(
        "CREATE INDEX IF NOT EXISTS ix_drawing_status_log_drawing_id ON drawing_status_log (drawing_id);"
    )
    conn.commit()
    conn.close()
    print("✔️ drawing_status_log OK")


def ensure_project_task_backfill():
    created = 0
    order_map = {}

    def _next_order(project_id):
        if project_id not in order_map:
            current_max = (
                db.session.query(func.max(ProjectTask.order_index))
                .filter(ProjectTask.project_id == project_id)
                .scalar()
            )
            order_map[project_id] = (current_max or 0) + 1
        value = order_map[project_id]
        order_map[project_id] += 1
        return value

    for work in QCWork.query.filter(QCWork.project_id.isnot(None), QCWork.project_task_id.is_(None)).all():
        project_task = ProjectTask(
            project_id=work.project_id,
            template_task_id=work.template_task_id,
            name=work.name or work.display_title,
            description=work.description,
            order_index=_next_order(work.project_id),
            duration_days=work.planned_duration_days,
            module="qc",
            task_subtype="qc",
            assignee_id=work.assigned_to,
            linked_record_type="qc_task",
            linked_record_id=work.id,
        )
        db.session.add(project_task)
        db.session.flush()
        work.project_task_id = project_task.id
        created += 1

    for task in DesignTask.query.filter(DesignTask.project_id.isnot(None), DesignTask.project_task_id.is_(None)).all():
        subtype = (task.task_type or "drawing").lower()
        project_task = ProjectTask(
            project_id=task.project_id,
            template_task_id=None,
            name=task.description or task.project_label,
            description=task.description,
            order_index=_next_order(task.project_id),
            duration_days=None,
            module="design",
            task_subtype=subtype,
            assignee_id=task.assigned_to_user_id,
            linked_record_type="design_task",
            linked_record_id=task.id,
        )
        db.session.add(project_task)
        db.session.flush()
        task.project_task_id = project_task.id
        created += 1

    if created:
        db.session.commit()
        print(f"✅ Backfilled {created} project_tasks for legacy module tasks.")


def ensure_bom_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_bom_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(bill_of_materials)")
    bom_cols = {row[1] for row in cur.fetchall()}
    added_cols = []

    if "drawing_site_id" not in bom_cols:
        cur.execute(
            "ALTER TABLE bill_of_materials ADD COLUMN drawing_site_id INTEGER;"
        )
        added_cols.append("drawing_site_id")
    if "revision_number" not in bom_cols:
        cur.execute("ALTER TABLE bill_of_materials ADD COLUMN revision_number INTEGER DEFAULT 1;")
        added_cols.append("revision_number")
    if "last_modified_at" not in bom_cols:
        cur.execute("ALTER TABLE bill_of_materials ADD COLUMN last_modified_at DATETIME;")
        added_cols.append("last_modified_at")
    if "bom_type" not in bom_cols:
        cur.execute("ALTER TABLE bill_of_materials ADD COLUMN bom_type TEXT DEFAULT 'main';")
        added_cols.append("bom_type")

    if added_cols:
        cur.execute("CREATE INDEX IF NOT EXISTS ix_bill_of_materials_drawing_site_id ON bill_of_materials (drawing_site_id);")

    cur.execute("PRAGMA table_info(bom_item)")
    bom_item_cols = {row[1] for row in cur.fetchall()}

    if "bom_package_id" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN bom_package_id INTEGER;")
        added_cols.append("bom_package_id")
        cur.execute(
            "CREATE INDEX IF NOT EXISTS ix_bom_item_bom_package_id ON bom_item (bom_package_id);"
        )

    if "stage_id" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN stage_id INTEGER;")
        added_cols.append("stage_id")
        cur.execute(
            "CREATE INDEX IF NOT EXISTS ix_bom_item_stage_id ON bom_item (stage_id);"
        )

    if "stage" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN stage TEXT;")
        added_cols.append("stage")

    if "section_title" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN section_title TEXT;")
        added_cols.append("section_title")

    if "specification" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN specification TEXT;")
        added_cols.append("specification")

    if "part_class_id" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN part_class_id INTEGER;")
        added_cols.append("part_class_id")

    if "source_template_line_id" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN source_template_line_id INTEGER;")
        added_cols.append("source_template_line_id")

    if "source_ref_key" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN source_ref_key TEXT;")
        added_cols.append("source_ref_key")

    if "is_generated" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN is_generated INTEGER DEFAULT 0;")
        added_cols.append("is_generated")

    if "suggested_part_id" not in bom_item_cols:
        cur.execute("ALTER TABLE bom_item ADD COLUMN suggested_part_id INTEGER;")
        added_cols.append("suggested_part_id")

    cur.execute("PRAGMA table_info(purchase_order)")
    po_cols = {row[1] for row in cur.fetchall()}

    po_added = []
    if "bom_id" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN bom_id INTEGER;")
        po_added.append("bom_id")
    if "stage_id" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN stage_id INTEGER;")
        po_added.append("stage_id")
    if "po_date" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN po_date DATE;")
        po_added.append("po_date")
    if "expected_delivery" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN expected_delivery DATE;")
        po_added.append("expected_delivery")
    if "subtotal_amount" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN subtotal_amount REAL;")
        po_added.append("subtotal_amount")
    if "grand_total_amount" not in po_cols:
        cur.execute("ALTER TABLE purchase_order ADD COLUMN grand_total_amount REAL;")
        po_added.append("grand_total_amount")
    if "origin" not in po_cols:
        cur.execute(
            "ALTER TABLE purchase_order ADD COLUMN origin TEXT DEFAULT 'erp';"
        )
        po_added.append("origin")

    if po_added:
        cur.execute(
            "CREATE INDEX IF NOT EXISTS ix_purchase_order_bom_stage ON purchase_order (bom_id, stage_id);"
        )

    po_all_cols = po_cols.union(set(po_added))
    if "po_date" in po_all_cols and "order_date" in po_cols:
        cur.execute(
            "UPDATE purchase_order SET po_date = order_date WHERE po_date IS NULL AND order_date IS NOT NULL;"
        )
    if "expected_delivery" in po_all_cols and "expected_delivery_date" in po_cols:
        cur.execute(
            "UPDATE purchase_order SET expected_delivery = expected_delivery_date WHERE expected_delivery IS NULL AND expected_delivery_date IS NOT NULL;"
        )
    bom_all_cols = bom_cols.union(set(added_cols))
    if "revision_number" in bom_all_cols:
        cur.execute(
            "UPDATE bill_of_materials SET revision_number = 1 WHERE revision_number IS NULL OR revision_number < 1;"
        )
    if "bom_type" in bom_all_cols:
        cur.execute(
            "UPDATE bill_of_materials SET bom_type = 'main' WHERE bom_type IS NULL OR trim(bom_type) = '';"
        )

    conn.commit()
    conn.close()

    if added_cols:
        print(f"✅ Auto-added in bill_of_materials/bom_item: {', '.join(added_cols)}")
    if po_added:
        print(f"✅ Auto-added in purchase_order: {', '.join(po_added)}")
    if not added_cols and not po_added:
        print("✔️ bill_of_materials OK")


def ensure_bom_package_backfill():
    try:
        bom_count = BillOfMaterials.query.count()
    except Exception as exc:
        print(f"⚠️ Skipping BOM package backfill due to database error: {exc}")
        return

    if bom_count == 0:
        return

    created_packages = 0
    updated_items = 0

    for bom in BillOfMaterials.query.all():
        existing_packages = BOMPackage.query.filter_by(bom_id=bom.id).all()
        if not existing_packages:
            default_package = BOMPackage(
                bom_id=bom.id,
                name="Main Lift BOM",
                status="draft",
                created_at=datetime.datetime.utcnow(),
            )
            db.session.add(default_package)
            db.session.flush()
            existing_packages = [default_package]
            created_packages += 1

        default_package = existing_packages[0]
        items_to_update = (
            BOMItem.query.filter_by(bom_id=bom.id)
            .filter(BOMItem.bom_package_id.is_(None))
            .all()
        )
        for item in items_to_update:
            item.bom_package_id = default_package.id
            if item.is_generated is None:
                item.is_generated = False
            updated_items += 1

    if created_packages or updated_items:
        db.session.commit()
        if created_packages:
            print(f"✅ Auto-created {created_packages} BOM package(s) for legacy BOMs.")
        if updated_items:
            print(f"✅ Assigned {updated_items} BOM item(s) to default packages.")


def ensure_purchase_order_item_columns():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_purchase_order_item_columns: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute("PRAGMA table_info(purchase_order_item)")
    columns = cur.fetchall()
    if not columns:
        conn.close()
        return

    col_names = {row[1] for row in columns}
    col_info = {row[1]: row for row in columns}
    added = []

    if "part_name" not in col_names:
        cur.execute("ALTER TABLE purchase_order_item ADD COLUMN part_name TEXT DEFAULT '' NOT NULL;")
        added.append("part_name")
        col_names.add("part_name")
    if "part_id" not in col_names:
        cur.execute("ALTER TABLE purchase_order_item ADD COLUMN part_id INTEGER;")
        added.append("part_id")
        col_names.add("part_id")
    if "product_id" not in col_names:
        cur.execute("ALTER TABLE purchase_order_item ADD COLUMN product_id INTEGER;")
        added.append("product_id")
        col_names.add("product_id")
    if "item_code" not in col_names:
        cur.execute("ALTER TABLE purchase_order_item ADD COLUMN item_code TEXT;")
        added.append("item_code")
        col_names.add("item_code")
    if "is_out_of_sync" not in col_names:
        cur.execute("ALTER TABLE purchase_order_item ADD COLUMN is_out_of_sync INTEGER DEFAULT 0;")
        added.append("is_out_of_sync")
        col_names.add("is_out_of_sync")

    item_code_notnull = col_info.get("item_code", [None, None, None, 0])[3] == 1
    if item_code_notnull:
        cur.execute("PRAGMA foreign_keys=off;")
        cur.execute(
            """
            CREATE TABLE purchase_order_item_new (
                id INTEGER PRIMARY KEY,
                purchase_order_id INTEGER NOT NULL,
                bom_item_id INTEGER,
                product_id INTEGER,
                part_id INTEGER,
                part_name TEXT NOT NULL DEFAULT '',
                item_code TEXT,
                description TEXT,
                unit TEXT,
                quantity_ordered REAL NOT NULL DEFAULT 1,
                unit_price REAL,
                currency TEXT DEFAULT 'INR',
                total_amount REAL
            );
            """
        )
        part_name_expr = (
            "COALESCE(part_name, item_code, '')"
            if "part_name" in col_names
            else "COALESCE(item_code, '')"
        )
        product_id_expr = "product_id" if "product_id" in col_names else "NULL"
        part_id_expr = "part_id" if "part_id" in col_names else "NULL"
        item_code_expr = "item_code" if "item_code" in col_names else "NULL"
        cur.execute(
            f"""
            INSERT INTO purchase_order_item_new (
                id,
                purchase_order_id,
                bom_item_id,
                product_id,
                part_id,
                part_name,
                item_code,
                description,
                unit,
                quantity_ordered,
                unit_price,
                currency,
                total_amount
            )
            SELECT
                id,
                purchase_order_id,
                bom_item_id,
                {product_id_expr},
                {part_id_expr},
                {part_name_expr},
                {item_code_expr},
                description,
                unit,
                quantity_ordered,
                unit_price,
                currency,
                total_amount
            FROM purchase_order_item;
            """
        )
        cur.execute("DROP TABLE purchase_order_item;")
        cur.execute("ALTER TABLE purchase_order_item_new RENAME TO purchase_order_item;")
        cur.execute("PRAGMA foreign_keys=on;")

    conn.commit()
    conn.close()

    if added:
        print(f"✅ Auto-added in purchase_order_item: {', '.join(added)}")
    if not added and not item_code_notnull:
        print("✔️ purchase_order_item OK")


def ensure_bom_spec_change_request_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_bom_spec_change_request_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS bom_spec_change_requests (
            id INTEGER PRIMARY KEY,
            bom_line_id INTEGER NOT NULL,
            po_line_id INTEGER,
            requested_by INTEGER NOT NULL,
            requested_at DATETIME,
            reason TEXT NOT NULL,
            suggested_alternative TEXT,
            status TEXT NOT NULL DEFAULT 'Pending',
            resolved_by INTEGER,
            resolved_at DATETIME,
            resolution_notes TEXT
        );
        """
    )
    cur.execute(
        "CREATE INDEX IF NOT EXISTS ix_bom_spec_change_requests_bom_line_id ON bom_spec_change_requests (bom_line_id);"
    )
    cur.execute(
        "CREATE INDEX IF NOT EXISTS ix_bom_spec_change_requests_po_line_id ON bom_spec_change_requests (po_line_id);"
    )

    conn.commit()
    conn.close()


def ensure_vendor_product_rate_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_vendor_product_rate_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='vendor_product_rate';"
    )
    exists = cur.fetchone() is not None
    if not exists:
        cur.execute(
            """
            CREATE TABLE vendor_product_rate (
                id INTEGER PRIMARY KEY,
                vendor_id INTEGER NOT NULL,
                product_id INTEGER NOT NULL,
                unit_price REAL,
                currency TEXT DEFAULT 'INR',
                vendor_part_name TEXT,
                updated_by TEXT,
                updated_at DATETIME
            );
            """
        )
        print("✅ Created missing table: vendor_product_rate")
    else:
        columns = {
            row[1]: (row[2] or "").upper()
            for row in cur.execute("PRAGMA table_info(vendor_product_rate)")
        }
        if "vendor_part_name" not in columns:
            cur.execute("ALTER TABLE vendor_product_rate ADD COLUMN vendor_part_name TEXT;")
            print("✅ Added vendor_part_name to vendor_product_rate")
        if "updated_by" not in columns:
            cur.execute("ALTER TABLE vendor_product_rate ADD COLUMN updated_by TEXT;")
            print("✅ Added updated_by to vendor_product_rate")
        if "updated_at" not in columns:
            cur.execute("ALTER TABLE vendor_product_rate ADD COLUMN updated_at DATETIME;")
            print("✅ Added updated_at to vendor_product_rate")

    cur.execute(
        """
        CREATE UNIQUE INDEX IF NOT EXISTS
        uq_vendor_product_rate_vendor_product
        ON vendor_product_rate (vendor_id, product_id);
        """
    )

    conn.commit()
    conn.close()


def ensure_vendor_product_rate_history_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print(
            "⚠️ Skipping ensure_vendor_product_rate_history_table: database is not a SQLite file."
        )
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='vendor_product_rate_history';"
    )
    exists = cur.fetchone() is not None
    if not exists:
        cur.execute(
            """
            CREATE TABLE vendor_product_rate_history (
                id INTEGER PRIMARY KEY,
                vendor_id INTEGER NOT NULL,
                product_id INTEGER NOT NULL,
                old_unit_price REAL,
                new_unit_price REAL,
                currency TEXT DEFAULT 'INR',
                note TEXT,
                changed_at DATETIME,
                changed_by TEXT
            );
            """
        )
        print("✅ Created missing table: vendor_product_rate_history")

    conn.commit()
    conn.close()


def ensure_vendor_contact_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_vendor_contact_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='vendor_contact';"
    )
    exists = cur.fetchone() is not None
    if not exists:
        cur.execute(
            """
            CREATE TABLE vendor_contact (
                id INTEGER PRIMARY KEY,
                vendor_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                role TEXT,
                phone TEXT,
                email TEXT,
                priority INTEGER
            );
            """
        )
        print("✅ Created missing table: vendor_contact")
    else:
        cur.execute("PRAGMA table_info(vendor_contact)")
        contact_cols = [row[1] for row in cur.fetchall()]
        if "priority" not in contact_cols:
            cur.execute("ALTER TABLE vendor_contact ADD COLUMN priority INTEGER;")
            print("✅ Added missing column: vendor_contact.priority")

    conn.commit()
    conn.close()


def ensure_vendor_issue_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_vendor_issue_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='vendor_issue';"
    )
    exists = cur.fetchone() is not None
    if not exists:
        cur.execute(
            """
            CREATE TABLE vendor_issue (
                id INTEGER PRIMARY KEY,
                vendor_id INTEGER NOT NULL,
                product_id INTEGER,
                po_id INTEGER,
                project_id INTEGER,
                issue_type TEXT NOT NULL,
                source TEXT NOT NULL,
                description TEXT NOT NULL,
                status TEXT DEFAULT 'Open',
                created_at DATETIME,
                created_by TEXT
            );
            """
        )
        print("✅ Created missing table: vendor_issue")
    else:
        columns = {
            row[1]: (row[2] or "").upper()
            for row in cur.execute("PRAGMA table_info(vendor_issue)")
        }
        missing = []
        for column_name, column_type in [
            ("vendor_id", "INTEGER"),
            ("product_id", "INTEGER"),
            ("po_id", "INTEGER"),
            ("project_id", "INTEGER"),
            ("issue_type", "TEXT"),
            ("source", "TEXT"),
            ("description", "TEXT"),
            ("status", "TEXT"),
            ("created_at", "DATETIME"),
            ("created_by", "TEXT"),
        ]:
            if column_name not in columns:
                cur.execute(
                    f"ALTER TABLE vendor_issue ADD COLUMN {column_name} {column_type};"
                )
                missing.append(column_name)
        if missing:
            print(f"✅ Added missing columns to vendor_issue: {', '.join(missing)}")

    conn.commit()
    conn.close()


def ensure_vendor_complaint_table():
    conn, db_path = _connect_sqlite_db()
    if not conn:
        print("⚠️ Skipping ensure_vendor_complaint_table: database is not a SQLite file.")
        return

    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='vendor_complaint';"
    )
    exists = cur.fetchone() is not None
    if not exists:
        cur.execute(
            """
            CREATE TABLE vendor_complaint (
                id INTEGER PRIMARY KEY,
                vendor_id INTEGER NOT NULL,
                po_id INTEGER,
                description TEXT NOT NULL,
                status TEXT DEFAULT 'Open',
                created_at DATETIME
            );
            """
        )
        print("✅ Created missing table: vendor_complaint")

    conn.commit()
    conn.close()


def ensure_procurement_stage_seed():
    defaults = [
        ("Stage 1", "STAGE_1"),
        ("Stage 2", "STAGE_2"),
        ("Stage 3", "STAGE_3"),
        ("Structural", "STRUCTURAL"),
        ("Cladding", "CLADDING"),
        ("Scaffolding", "SCAFFOLDING"),
    ]

    added = []
    existing_names = {
        (stage.name or "").strip().lower(): stage
        for stage in ProcurementStage.query.all()
    }

    for idx, (name, code) in enumerate(defaults, start=1):
        key = (name or "").strip().lower()
        if key in existing_names:
            continue
        stage = ProcurementStage(
            name=name,
            code=code,
            sequence=idx * 10,
            is_active=True,
        )
        db.session.add(stage)
        added.append(name)

    if added:
        db.session.commit()
        print(f"✅ Seeded procurement stages: {', '.join(added)}")


def _get_active_procurement_stages(include_inactive=False):
    query = ProcurementStage.query
    if not include_inactive:
        query = query.filter(ProcurementStage.is_active.is_(True))
    return query.order_by(ProcurementStage.sequence.asc(), ProcurementStage.name.asc()).all()


def _get_default_procurement_stage():
    return (
        ProcurementStage.query.filter(func.lower(ProcurementStage.name) == "stage 1")
        .order_by(ProcurementStage.sequence.asc())
        .first()
    )


def migrate_plaintext_passwords():
    migrated = 0
    for user in User.query.all():
        if user.password and not _is_password_hashed(user.password):
            user.set_password(user.password)
            migrated += 1

    if migrated:
        db.session.commit()
        print(f"🔒 Migrated {migrated} plaintext password(s) to hashed storage.")


def bootstrap_db():
    ensure_tables()
    ensure_inventory_item_columns()
    ensure_user_columns()
    ensure_project_comment_table()
    ensure_project_columns()
    ensure_delivery_order_columns()
    ensure_delivery_order_item_columns()
    ensure_delivery_challan_columns()
    ensure_design_task_columns()
    ensure_design_drawing_columns()
    ensure_drawing_status_log_table()
    ensure_bom_columns()
    ensure_bom_package_table()
    ensure_bom_package_backfill()
    ensure_purchase_order_item_columns()
    ensure_bom_spec_change_request_table()
    ensure_vendor_product_rate_table()
    ensure_vendor_product_rate_history_table()
    ensure_vendor_contact_table()
    ensure_vendor_issue_table()
    ensure_vendor_complaint_table()
    ensure_qc_columns()    # adds missing columns safely
    ensure_project_task_backfill()
    ensure_lift_columns()
    ensure_service_route_columns()
    ensure_sales_client_columns()
    ensure_sales_task_columns()
    ensure_sales_opportunity_columns()
    ensure_sales_opportunity_item_columns()
    ensure_sales_opportunity_engagement_columns()
    ensure_sales_opportunity_file_columns()
    ensure_customer_columns()
    ensure_vendor_columns()
    ensure_product_columns()
    ensure_part_class_table()
    ensure_bom_template_table()
    ensure_bom_template_input_table()
    ensure_bom_template_stage_table()
    ensure_bom_template_section_table()
    ensure_bom_template_line_table()
    ensure_procurement_stage_seed()
    ensure_dropdown_options_seed()
    ensure_client_requirement_template_seed()
    seeded_org_structure = ensure_default_org_structure_seed()
    purge_legacy_demo_records()

    migrate_plaintext_passwords()

    admin_user = User.query.filter(func.lower(User.username) == "admin").first()
    if User.query.count() == 0:
        admin_password = os.environ.get("DEFAULT_ADMIN_PASSWORD")
        generated_password = False
        if not admin_password:
            admin_password = "".join(
                random.choices(string.ascii_letters + string.digits, k=16)
            )
            generated_password = True
        admin_user = User(username="admin", role="Admin", active=True)
        admin_user.set_password(admin_password)
        admin_user.issue_session_token()
        db.session.add(admin_user)
        db.session.flush()
        if generated_password:
            print(
                "🔑 Created default admin user with a generated password. "
                f"Username: admin, Password: {admin_password}"
            )
        else:
            print(
                "🔑 Created default admin user with password from DEFAULT_ADMIN_PASSWORD."
            )

    if admin_user and (admin_user.role or "").strip().lower() != "admin":
        admin_user.role = "Admin"

    # Ensure legacy accounts have activation flag and session tokens
    for user in User.query.filter(or_(User.session_token.is_(None), User.session_token == "")).all():
        user.issue_session_token()
    for user in User.query.filter(User.active.is_(None)).all():
        user.active = True
    for user in User.query.filter(or_(User.module_permissions_json.is_(None), User.module_permissions_json == "")).all():
        user.module_permissions_json = "{}"

    get_or_create_default_task_form()

    if not FormSchema.query.filter_by(name="QC - New Installation").first():
        sample_schema = [
            {"label": "Lift Cabin Condition", "type": "select", "required": True, "options": ["OK", "Not OK", "Need Client Input"], "photo_required_if_ng": True},
            {"label": "Machine Room Cleanliness", "type": "select", "required": True, "options": ["OK", "Not OK", "Need Client Input"], "photo_required_if_ng": True},
            {"label": "Lift Shaft Obstruction", "type": "select", "required": True, "options": ["OK", "Not OK", "Need Client Input"], "photo_required_if_ng": True},
            {"label": "General Remarks", "type": "textarea", "required": False},
        ]
        fs = FormSchema(
            name="QC - New Installation",
            schema_json=json.dumps(sample_schema, ensure_ascii=False),
            min_photos_if_all_good=0,
            stage="Template QC",
            lift_type="MRL"
        )
        db.session.add(fs)

    if not ProjectTemplate.query.filter_by(name="NI Project").first():
        ni_template = ProjectTemplate(
            name="NI Project",
            description="Baseline new installation delivery with sequential QC checks.",
            created_by=admin_user.id if admin_user else None
        )
        db.session.add(ni_template)

    if SalesClient.query.count() == 0:
        pass

    if ServiceRoute.query.count() == 0:
        default_routes = [
            ("Goa", "Goa"),
            ("Maharashtra", "Mumbai"),
            ("Karnataka", "Mumbai"),
        ]
        for state_name, branch_name in default_routes:
            db.session.add(ServiceRoute(state=state_name, branch=branch_name))
        db.session.flush()

    if Customer.query.count() == 0:
        pass

    if Lift.query.count() == 0:
        pass

    db.session.commit()
    if seeded_org_structure:
        backup_org_structure()
    synchronize_dependency_links()
# -----------------------------------------------------------------------


@app.route("/")
def index():
    if current_user.is_authenticated:
        return redirect(url_for("dashboard"))
    return render_template("index.html", category_label=None)


LOGIN_ATTEMPT_WINDOW = datetime.timedelta(minutes=15)
LOGIN_BLOCK_DURATION = datetime.timedelta(minutes=10)
MAX_FAILED_ATTEMPTS = 5


@dataclass
class LoginThrottle:
    failures: List[datetime_cls] = field(default_factory=list)
    blocked_until: Optional[datetime_cls] = None


_login_attempts: Dict[tuple, LoginThrottle] = {}


def _get_login_key(username: str) -> tuple:
    return (username.lower(), request.remote_addr or "unknown")


def _prune_attempts(attempt: LoginThrottle, *, now: datetime_cls) -> None:
    attempt.failures = [ts for ts in attempt.failures if now - ts <= LOGIN_ATTEMPT_WINDOW]
    if not attempt.failures and (not attempt.blocked_until or attempt.blocked_until <= now):
        attempt.blocked_until = None


def _is_blocked(attempt: LoginThrottle, *, now: datetime_cls) -> bool:
    if attempt.blocked_until and attempt.blocked_until > now:
        return True
    attempt.blocked_until = None
    return False


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        password = request.form.get("password", "").strip()
        now = datetime_cls.utcnow()
        key = _get_login_key(username)
        attempt = _login_attempts.setdefault(key, LoginThrottle())
        _prune_attempts(attempt, now=now)

        if _is_blocked(attempt, now=now):
            remaining = int((attempt.blocked_until - now).total_seconds() // 60) + 1
            flash(
                f"Too many failed attempts. Please try again in about {remaining} minutes.",
                "error",
            )
            return render_template("login.html", category_label=None)

        user = User.query.filter_by(username=username).first()
        if user and user.verify_password(password):
            if not user.is_active:
                flash("Your account is deactivated. Please contact an administrator.", "error")
            else:
                user.issue_session_token()
                db.session.commit()
                login_user(user)
                session["session_token"] = user.session_token
                session["admin_switch_allowed"] = bool(user.is_admin)
                attempt.failures.clear()
                attempt.blocked_until = None
                if key in _login_attempts and not attempt.failures:
                    _login_attempts.pop(key, None)
                flash("Welcome back!", "success")
                return redirect(url_for("dashboard"))
        else:
            attempt.failures.append(now)
            _prune_attempts(attempt, now=now)
            if len(attempt.failures) >= MAX_FAILED_ATTEMPTS:
                attempt.blocked_until = now + LOGIN_BLOCK_DURATION
                flash(
                    "Too many failed attempts. Please try again in a few minutes.",
                    "error",
                )
            else:
                flash("Invalid credentials", "error")
    return render_template("login.html", category_label=None)


@app.route("/logout")
@login_required
def logout():
    logout_user()
    session.pop("session_token", None)
    session.pop("admin_switch_allowed", None)
    flash("Logged out", "info")
    return redirect(url_for("index"))


@app.route("/switch-user", methods=["POST"])
@login_required
def switch_user():
    if not (current_user.is_admin or session.get("admin_switch_allowed")):
        abort(403)

    target_id = request.form.get("user_id")
    redirect_to = request.form.get("next") or request.referrer or url_for("dashboard")

    if not target_id:
        flash("Select a user to switch.", "error")
        return redirect(redirect_to)

    user = User.query.filter_by(id=target_id).first()
    if not user:
        flash("Unable to find the selected user.", "error")
        return redirect(redirect_to)

    if not user.is_active:
        flash("The selected user is deactivated.", "error")
        return redirect(redirect_to)

    user.issue_session_token()
    db.session.commit()

    login_user(user)
    session["session_token"] = user.session_token
    flash(f"Switched to {user.display_name}", "info")
    return redirect(redirect_to)


@app.route("/profile", methods=["GET", "POST"])
@login_required
def profile():
    if request.method == "POST":
        first_name = (request.form.get("first_name") or "").strip()
        last_name = (request.form.get("last_name") or "").strip()
        remove_avatar = request.form.get("remove_avatar") == "1"

        current_user.first_name = first_name or None
        current_user.last_name = last_name or None

        file = request.files.get("display_picture")
        if remove_avatar:
            current_user.display_picture = None
        elif file and file.filename:
            if not allowed_file(file.filename, kind="photo"):
                flash("Please upload a PNG, JPG, JPEG or WEBP image for the display picture.", "error")
                return redirect(url_for("profile"))
            fname = secure_filename(file.filename)
            dest_dir = os.path.join(app.config["UPLOAD_FOLDER"], "avatars")
            os.makedirs(dest_dir, exist_ok=True)
            dest_name = f"avatar_{current_user.id}_{int(datetime.datetime.utcnow().timestamp())}_{fname}"
            dest_path = os.path.join(dest_dir, dest_name)
            file.save(dest_path)
            rel_path = os.path.relpath(dest_path, "static")
            current_user.display_picture = rel_path.replace("\\", "/")

        db.session.commit()
        flash("Profile updated.", "success")
        return redirect(url_for("profile"))

    return render_template("profile.html")


@app.route("/settings")
@login_required
def settings():
    tab = (request.args.get("tab") or "admin").lower()
    allowed_tabs = {"admin", "account", "display", "modules"}
    active_tab = tab if tab in allowed_tabs else "admin"

    users = []
    departments = []
    positions = []
    department_options = []
    position_options = []

    admin_settings = _load_admin_settings()
    app.config["ADMIN_SETTINGS"] = admin_settings
    app.config["MAX_CONTENT_LENGTH"] = _get_max_upload_size_bytes(admin_settings)

    if current_user.is_admin:
        departments = sorted(
            Department.query.order_by(Department.name.asc()).all(),
            key=lambda d: (d.full_name or "").lower(),
        )
        positions = sorted(
            Position.query.order_by(Position.title.asc()).all(),
            key=lambda p: (p.display_label or "").lower(),
        )
        department_options = departments
        position_options = positions
        users = User.query.order_by(User.username.asc()).all()

    return render_template(
        "settings.html",
        active_tab=active_tab,
        allowed_tabs=sorted(allowed_tabs),
        users=users,
        departments=departments,
        department_options=department_options,
        department_branches=DEPARTMENT_BRANCHES,
        positions=positions,
        position_options=position_options,
        admin_settings=admin_settings,
    )


@app.route("/settings/admin/upload-limit", methods=["POST"])
@login_required
def settings_admin_upload_limit():
    if not current_user.is_admin:
        abort(403)

    raw_value = (request.form.get("max_upload_size_mb") or "").strip()
    try:
        parsed_value = float(raw_value)
    except ValueError:
        flash("Enter a valid number for the maximum upload size (in MB).", "error")
        return redirect(url_for("settings", tab="admin"))

    if parsed_value <= 0:
        flash("Upload size must be greater than 0 MB.", "error")
        return redirect(url_for("settings", tab="admin"))

    clamped_value = min(DEFAULT_MAX_UPLOAD_SIZE_MB, parsed_value)
    admin_settings = _save_admin_settings({"max_upload_size_mb": clamped_value})
    app.config["ADMIN_SETTINGS"] = admin_settings
    app.config["MAX_CONTENT_LENGTH"] = _get_max_upload_size_bytes(admin_settings)

    note = " (capped at 45 MB maximum)" if parsed_value > DEFAULT_MAX_UPLOAD_SIZE_MB else ""
    flash(
        f"Maximum upload size updated to {int(clamped_value)} MB{note}.", "success"
    )
    return redirect(url_for("settings", tab="admin"))


@app.route("/settings/service/routes/create", methods=["POST"])
@login_required
def settings_service_route_create():
    if not current_user.is_admin:
        abort(403)

    route_name = clean_str(request.form.get("route_name") or request.form.get("state"))
    if not route_name:
        flash("Route name is required to add a route.", "error")
        return redirect(url_for("service_settings"))

    branch_value, error = validate_branch(request.form.get("branch"), required=True)
    if error:
        flash(error, "error")
        return redirect(url_for("service_settings"))

    remark_value = clean_str(request.form.get("remark"))
    if remark_value and len(remark_value) > 255:
        remark_value = remark_value[:255]
        flash("Remark exceeded 255 characters and was truncated.", "warning")

    existing = ServiceRoute.query.filter(func.lower(ServiceRoute.state) == route_name.lower()).first()
    if existing:
        flash("A route with that name already exists.", "error")
        return redirect(url_for("service_settings"))

    db.session.add(ServiceRoute(state=route_name, branch=branch_value, remark=remark_value))
    db.session.commit()
    flash(f"Route '{route_name}' for branch {branch_value} added.", "success")
    return redirect(url_for("service_settings"))


@app.route("/settings/service/routes/<int:route_id>/update", methods=["POST"])
@login_required
def settings_service_route_update(route_id):
    if not current_user.is_admin:
        abort(403)

    route = db.session.get(ServiceRoute, route_id)
    if not route:
        flash("Route not found.", "error")
        return redirect(url_for("service_settings"))

    route_name = clean_str(request.form.get("route_name") or request.form.get("state"))
    if not route_name:
        flash("Route name cannot be empty.", "error")
        return redirect(url_for("service_settings"))

    branch_value, error = validate_branch(request.form.get("branch"), required=True)
    if error:
        flash(error, "error")
        return redirect(url_for("service_settings"))

    remark_value = clean_str(request.form.get("remark"))
    if remark_value and len(remark_value) > 255:
        remark_value = remark_value[:255]
        flash("Remark exceeded 255 characters and was truncated.", "warning")

    duplicate = (
        ServiceRoute.query.filter(func.lower(ServiceRoute.state) == route_name.lower(), ServiceRoute.id != route.id)
        .first()
    )
    if duplicate:
        flash("Another route already uses that name.", "error")
        return redirect(url_for("service_settings"))

    route.state = route_name
    route.branch = branch_value
    route.remark = remark_value
    db.session.commit()

    flash("Route updated.", "success")
    return redirect(url_for("service_settings"))


@app.route("/settings/service/routes/<int:route_id>/delete", methods=["POST"])
@login_required
def settings_service_route_delete(route_id):
    if not current_user.is_admin:
        abort(403)

    route = db.session.get(ServiceRoute, route_id)
    if not route:
        flash("Route not found.", "error")
        return redirect(url_for("service_settings"))

    db.session.delete(route)
    db.session.commit()
    flash(f"Route '{route.display_name}' removed.", "success")
    return redirect(url_for("service_settings"))


@app.route("/admin/reset-workspace", methods=["POST"])
@login_required
def admin_reset_workspace():
    if not current_user.is_admin:
        abort(403)

    redirect_target = url_for("settings", tab="account")
    password = (request.form.get("confirm_password") or "").strip()

    if not password:
        flash("Enter your password to confirm the workspace reset.", "error")
        return redirect(redirect_target)

    if not current_user.verify_password(password):
        flash("Password verification failed. Reset cancelled.", "error")
        return redirect(redirect_target)

    try:
        summary = reset_workspace_data()
        db.session.commit()
    except Exception:
        db.session.rollback()
        app.logger.exception("Workspace reset failed")
        flash("An unexpected error occurred while resetting the workspace.", "error")
        return redirect(redirect_target)

    removed_parts = []
    labels = [
        ("customers", "customer"),
        ("lifts", "lift"),
        ("opportunities", "opportunity"),
        ("sales_clients", "sales client"),
        ("projects", "project"),
        ("submissions", "submission"),
        ("qc_tasks", "QC task"),
        ("service_complaints", "complaint"),
        ("service_contracts", "contract"),
        ("service_parts_entries", "parts/material entry"),
        ("srt_sites", "SRT site"),
    ]

    for key, label in labels:
        count = summary.get(key, 0)
        if count:
            plural = "s" if count != 1 else ""
            removed_parts.append(f"{count} {label}{plural}")

    details = ", ".join(removed_parts) if removed_parts else "no records"
    flash(f"Workspace reset complete. Removed {details}.", "success")
    return redirect(redirect_target)


def _get_dropdown_definition_or_404(field_key):
    definition = DROPDOWN_FIELD_DEFINITIONS.get(field_key)
    if not definition:
        abort(404)
    return definition


@app.route("/settings/dropdowns/<field_key>/options", methods=["POST"])
@login_required
def settings_dropdown_option_create(field_key):
    if not current_user.is_admin:
        abort(403)
    definition = _get_dropdown_definition_or_404(field_key)
    label = clean_str(request.form.get("label"))
    value = clean_str(request.form.get("value")) if definition.get("value_editable") else None
    if not label:
        flash("Option label cannot be empty.", "error")
        return redirect(url_for("service_settings"))
    if not definition.get("value_editable"):
        value = label
    elif not value:
        value = label
    existing = (
        DropdownOption.query.filter(
            DropdownOption.field_key == field_key,
            func.lower(DropdownOption.label) == label.lower(),
        )
        .first()
    )
    if existing:
        flash("An option with that label already exists.", "error")
        return redirect(url_for("service_settings"))
    max_order = (
        db.session.query(func.coalesce(func.max(DropdownOption.order_index), -1))
        .filter(DropdownOption.field_key == field_key)
        .scalar()
    )
    option = DropdownOption(
        field_key=field_key,
        label=label,
        value=value,
        order_index=max_order + 1,
    )
    db.session.add(option)
    db.session.commit()
    flash("Dropdown option added.", "success")
    return redirect(url_for("service_settings"))


@app.route("/settings/dropdowns/<field_key>/options/<int:option_id>", methods=["POST"])
@login_required
def settings_dropdown_option_update(field_key, option_id):
    if not current_user.is_admin:
        abort(403)
    definition = _get_dropdown_definition_or_404(field_key)
    option = DropdownOption.query.filter_by(field_key=field_key, id=option_id).first()
    if not option:
        flash("Option not found.", "error")
        return redirect(url_for("service_settings"))
    label = clean_str(request.form.get("label"))
    value = clean_str(request.form.get("value")) if definition.get("value_editable") else option.label
    if not label:
        flash("Option label cannot be empty.", "error")
        return redirect(url_for("service_settings"))
    if not definition.get("value_editable") or not value:
        value = label
    duplicate = (
        DropdownOption.query.filter(
            DropdownOption.field_key == field_key,
            func.lower(DropdownOption.label) == label.lower(),
            DropdownOption.id != option.id,
        )
        .first()
    )
    if duplicate:
        flash("Another option already uses that label.", "error")
        return redirect(url_for("service_settings"))
    option.label = label
    option.value = value
    db.session.commit()
    flash("Option updated.", "success")
    return redirect(url_for("service_settings"))


@app.route("/settings/dropdowns/<field_key>/options/<int:option_id>/delete", methods=["POST"])
@login_required
def settings_dropdown_option_delete(field_key, option_id):
    if not current_user.is_admin:
        abort(403)
    _get_dropdown_definition_or_404(field_key)
    option = DropdownOption.query.filter_by(field_key=field_key, id=option_id).first()
    if not option:
        flash("Option not found.", "error")
        return redirect(url_for("service_settings"))
    db.session.delete(option)
    db.session.commit()
    flash("Option removed.", "success")
    return redirect(url_for("service_settings"))


@app.route("/settings/dropdowns/<field_key>/reorder", methods=["POST"])
@login_required
def settings_dropdown_option_reorder(field_key):
    if not current_user.is_admin:
        abort(403)
    _get_dropdown_definition_or_404(field_key)
    payload = request.get_json(silent=True) or {}
    order_ids = payload.get("order")
    if not isinstance(order_ids, list):
        return jsonify({"status": "error", "message": "Invalid payload."}), 400
    options = {
        option.id: option
        for option in DropdownOption.query.filter_by(field_key=field_key).all()
    }
    for index, option_id in enumerate(order_ids):
        try:
            option_id = int(option_id)
        except (TypeError, ValueError):
            continue
        option = options.get(option_id)
        if option:
            option.order_index = index
    db.session.commit()
    return jsonify({"status": "ok"})


@app.route("/sales")
@login_required
def sales_home():
    _module_visibility_required("sales")
    today = datetime.date.today()
    month_start = today.replace(day=1)
    next_month_start = (month_start + datetime.timedelta(days=32)).replace(day=1)

    duration = request.args.get("duration", "month")
    period_label = {
        "month": "This Month",
        "quarter": "This Quarter",
        "ytd": "Year to Date",
    }.get(duration, "This Month")
    period_descriptions = {
        "month": "Current month snapshot",
        "quarter": "Performance for the current quarter",
        "ytd": "Year-to-date performance overview",
    }

    if duration == "quarter":
        quarter_index = (today.month - 1) // 3
        start_month = quarter_index * 3 + 1
        period_start = today.replace(month=start_month, day=1)
        next_quarter_month = start_month + 3
        if next_quarter_month > 12:
            period_end = today.replace(year=today.year + 1, month=1, day=1)
        else:
            period_end = today.replace(month=next_quarter_month, day=1)
    elif duration == "ytd":
        period_start = today.replace(month=1, day=1)
        period_end = today.replace(year=today.year + 1, month=1, day=1)
    else:
        duration = "month"
        period_start = month_start
        period_end = next_month_start
    period_description = period_descriptions.get(duration, period_descriptions["month"])

    closed_won_clause = func.lower(SalesOpportunity.stage).like("closed won%")
    period_filters = [
        closed_won_clause,
        SalesOpportunity.updated_at >= period_start,
        SalesOpportunity.updated_at < period_end,
    ]

    won_count = SalesOpportunity.query.filter(*period_filters).count()
    won_value = (
        db.session.query(func.coalesce(func.sum(SalesOpportunity.amount), 0.0))
        .filter(*period_filters)
        .scalar()
        or 0.0
    )

    closed_lost_clause = func.lower(SalesOpportunity.stage).like("closed lost%")
    period_closed_total = (
        SalesOpportunity.query
        .filter(
            or_(closed_won_clause, closed_lost_clause),
            SalesOpportunity.updated_at >= period_start,
            SalesOpportunity.updated_at < period_end,
        )
        .count()
    )
    win_rate = (won_count / period_closed_total * 100) if period_closed_total else 0.0
    average_deal_value = (won_value / won_count) if won_count else 0.0

    open_pipeline_clause = ~func.lower(SalesOpportunity.stage).like("closed%")
    open_deals_count = SalesOpportunity.query.filter(open_pipeline_clause).count()
    open_pipeline_value = (
        db.session.query(func.coalesce(func.sum(SalesOpportunity.amount), 0.0))
        .filter(open_pipeline_clause)
        .scalar()
        or 0.0
    )

    stage_rows = (
        db.session.query(
            SalesOpportunity.stage,
            func.count(SalesOpportunity.id),
            func.coalesce(func.sum(SalesOpportunity.amount), 0.0),
        )
        .group_by(SalesOpportunity.stage)
        .order_by(func.count(SalesOpportunity.id).desc())
        .all()
    )
    stage_distribution = [
        {
            "stage": stage or "(No Stage)",
            "count": count,
            "value": float(total or 0.0),
        }
        for stage, count, total in stage_rows
    ]

    previous_months = []
    cursor = month_start
    for _ in range(3):
        cursor = (cursor - datetime.timedelta(days=1)).replace(day=1)
        next_cursor = (cursor + datetime.timedelta(days=32)).replace(day=1)
        total_value = (
            db.session.query(func.coalesce(func.sum(SalesOpportunity.amount), 0.0))
            .filter(
                closed_won_clause,
                SalesOpportunity.updated_at >= cursor,
                SalesOpportunity.updated_at < next_cursor,
            )
            .scalar()
            or 0.0
        )
        previous_months.append(
            {
                "label": cursor.strftime("%b %Y"),
                "total": float(total_value or 0.0),
            }
        )
    previous_months.reverse()

    team_rows = (
        db.session.query(
            SalesOpportunity.owner_id,
            func.count(SalesOpportunity.id),
            func.coalesce(func.sum(SalesOpportunity.amount), 0.0),
        )
        .filter(*period_filters)
        .group_by(SalesOpportunity.owner_id)
        .all()
    )

    team_breakdown = []
    owner_cache = {}
    for owner_id, deal_count, total_value in team_rows:
        if owner_id:
            owner = owner_cache.get(owner_id)
            if owner is None:
                owner = db.session.get(User, owner_id)
                owner_cache[owner_id] = owner
            owner_name = owner.display_name if owner else "Unknown"
        else:
            owner_name = "Unassigned"
        team_breakdown.append(
            {
                "owner": owner_name,
                "deals": deal_count,
                "value": float(total_value or 0.0),
            }
        )
    team_breakdown.sort(key=lambda row: row["value"], reverse=True)

    now = datetime.datetime.utcnow()
    open_status_clause = func.lower(func.coalesce(SalesOpportunityEngagement.status, "open")) == "open"
    due_activities = (
        SalesOpportunityEngagement.query
        .filter(
            SalesOpportunityEngagement.scheduled_for.isnot(None),
            SalesOpportunityEngagement.scheduled_for <= now,
            open_status_clause,
        )
        .order_by(SalesOpportunityEngagement.scheduled_for.asc())
        .limit(10)
        .all()
    )

    my_activities = []
    if getattr(current_user, "is_authenticated", False):
        my_activities = (
            SalesOpportunityEngagement.query.filter(
                SalesOpportunityEngagement.created_by_id == current_user.id,
                open_status_clause,
            )
            .order_by(
                case((SalesOpportunityEngagement.scheduled_for.is_(None), 2),
                     (SalesOpportunityEngagement.scheduled_for <= now, 0),
                     else_=1),
                SalesOpportunityEngagement.scheduled_for.asc(),
                SalesOpportunityEngagement.created_at.desc(),
            )
            .limit(15)
            .all()
        )

    return render_template(
        "sales/dashboard.html",
        won_count=won_count,
        won_value=won_value,
        win_rate=win_rate,
        average_deal_value=average_deal_value,
        open_deals_count=open_deals_count,
        open_pipeline_value=open_pipeline_value,
        stage_distribution=stage_distribution,
        previous_months=previous_months,
        team_breakdown=team_breakdown,
        due_activities=due_activities,
        my_activities=my_activities,
        format_currency=format_currency,
        selected_duration=duration,
        period_label=period_label,
        period_description=period_description,
        now=now,
    )


@app.route("/sales/tasks", methods=["GET", "POST"])
@login_required
def sales_tasks():
    _module_visibility_required("sales")
    today = datetime.date.today()
    active_tab = (request.form.get("active_tab") or request.args.get("tab") or "taskboard").lower()
    active_tab = active_tab if active_tab in {"taskboard", "calendar"} else "taskboard"

    month_param = request.args.get("month")
    try:
        calendar_month = datetime.datetime.strptime(month_param, "%Y-%m").date().replace(day=1) if month_param else today.replace(day=1)
    except ValueError:
        calendar_month = today.replace(day=1)

    if request.method == "POST":
        form_action = request.form.get("form_action") or "create"
        if form_action == "create":
            title = (request.form.get("title") or "").strip()
            if not title:
                flash("Task title is required.", "error")
                return redirect(url_for("sales_tasks", tab=active_tab))

            due_date_raw = request.form.get("due_date") or today.isoformat()
            try:
                due_date = datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date()
            except ValueError:
                due_date = today

            related_ref = (request.form.get("related_ref") or "general").strip().lower()
            related_type = "general"
            opportunity_id = None
            client_id = None
            if related_ref.startswith("opportunity:"):
                related_type = "opportunity"
                try:
                    opportunity_id = int(related_ref.split(":", 1)[1])
                except (ValueError, IndexError):
                    opportunity_id = None
            elif related_ref.startswith("client:"):
                related_type = "client"
                try:
                    client_id = int(related_ref.split(":", 1)[1])
                except (ValueError, IndexError):
                    client_id = None
            else:
                related_type = "general"

            owner_user = current_user if getattr(current_user, "is_authenticated", False) else None
            if owner_user and not owner_user.can_be_assigned_module("sales"):
                flash("You cannot be set as owner for sales tasks.", "error")
                return redirect(url_for("sales_tasks", tab=active_tab))

            assignee_users = []
            seen_assignee_ids = set()
            assignee_ids = request.form.getlist("assignee_ids") or request.form.getlist("assignee_id")
            for raw_id in assignee_ids:
                try:
                    assignee_id = int(raw_id)
                except (TypeError, ValueError):
                    continue
                if assignee_id in seen_assignee_ids:
                    continue
                assignee_user = db.session.get(User, assignee_id)
                if not assignee_user or not assignee_user.can_be_assigned_module("sales"):
                    flash("Choose assignees who can work on sales tasks.", "error")
                    return redirect(url_for("sales_tasks", tab=active_tab))
                seen_assignee_ids.add(assignee_id)
                assignee_users.append(assignee_user)

            if not assignee_users and owner_user:
                assignee_users.append(owner_user)
            elif not assignee_users and getattr(current_user, "is_authenticated", False):
                assignee_users.append(current_user)

            task = SalesTask(
                title=title,
                category=(request.form.get("category") or "task").strip() or "task",
                due_date=due_date,
                description=(request.form.get("description") or "").strip() or None,
                related_type=related_type,
                opportunity_id=opportunity_id,
                client_id=client_id,
                owner=owner_user or current_user,
                assignee=assignee_users[0] if assignee_users else None,
                assignees=assignee_users,
                creator=current_user,
            )
            db.session.add(task)
            db.session.commit()
            flash("Task created.", "success")
        return redirect(url_for("sales_tasks", tab=active_tab))

    tasks = (
        SalesTask.query
        .options(
            joinedload(SalesTask.opportunity).joinedload(SalesOpportunity.client),
            joinedload(SalesTask.client),
            joinedload(SalesTask.owner),
            joinedload(SalesTask.assignees),
        )
        .order_by(SalesTask.due_date.asc(), SalesTask.created_at.asc())
        .all()
    )
    tasks_today = [task for task in tasks if task.due_date == today and not task.is_completed]

    category_board = defaultdict(list)
    for task in tasks:
        category_board.setdefault(task.category or "task", []).append(task)

    tasks_by_date = defaultdict(list)
    for task in tasks:
        if task.due_date:
            tasks_by_date[task.due_date.isoformat()].append(task)

    month_start = calendar_month
    _, month_days = calendar.monthrange(month_start.year, month_start.month)
    grid_start = month_start - datetime.timedelta(days=month_start.weekday())
    calendar_days = []
    for offset in range(42):
        day = grid_start + datetime.timedelta(days=offset)
        calendar_days.append({
            "date": day,
            "in_month": day.month == month_start.month,
        })

    tasks_by_date_json = {
        date_key: [
            {
                "id": task.id,
                "title": task.title,
                "category": task.category_label,
                "status": task.status,
                "description": task.description or "",
                "related": task.related_display,
            }
            for task in items
        ]
        for date_key, items in tasks_by_date.items()
    }

    opportunities = (
        SalesOpportunity.query.options(joinedload(SalesOpportunity.client))
        .order_by(func.lower(SalesOpportunity.title))
        .all()
    )
    assignable_sales_users = [
        user
        for user in User.query.filter(User.active.is_(True))
        .order_by(User.first_name.asc(), User.last_name.asc(), User.username.asc())
        .all()
        if user.can_be_assigned_module("sales")
    ]
    clients = SalesClient.query.order_by(func.lower(SalesClient.display_name)).all()

    previous_month = (month_start - datetime.timedelta(days=1)).replace(day=1)
    next_month = (month_start + datetime.timedelta(days=month_days)).replace(day=1)
    calendar_weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday"]

    return render_template(
        "sales/tasks.html",
        tasks=tasks,
        tasks_today=tasks_today,
        category_board=category_board,
        calendar_days=calendar_days,
        today=today,
        active_tab=active_tab,
        task_categories=SALES_TASK_CATEGORIES,
        tasks_by_date_json=tasks_by_date_json,
        tasks_by_date=tasks_by_date,
        calendar_month_label=month_start.strftime("%B %Y"),
        opportunities=opportunities,
        sales_users=assignable_sales_users,
        clients=clients,
        calendar_prev_month=previous_month.strftime("%Y-%m"),
        calendar_next_month=next_month.strftime("%Y-%m"),
        calendar_weekdays=calendar_weekdays,
    )


@app.route("/sales/tasks/<int:task_id>", methods=["GET", "POST"])
@login_required
def sales_task_detail(task_id):
    task = db.session.get(SalesTask, task_id)
    if not task:
        flash("Task not found.", "error")
        return redirect(url_for("sales_tasks"))

    assignee_ids = [user.id for user in task.assignees if getattr(user, "id", None)]
    if task.owner_id:
        assignee_ids.append(task.owner_id)

    _module_visibility_required("sales", owner_user_ids=assignee_ids)

    if request.method == "POST":
        if not task.is_completed:
            task.status = "Completed"
            task.completed_at = datetime.datetime.utcnow()
            db.session.commit()
            flash("Task marked complete.", "success")
        return redirect(url_for("sales_task_detail", task_id=task.id))

    client_requirement_form = None
    latest_quotation_file = None
    if task.opportunity_id:
        client_requirement_form = (
            ClientRequirementForm.query.filter_by(opportunity_id=task.opportunity_id)
            .order_by(
                ClientRequirementForm.version.desc(),
                ClientRequirementForm.updated_at.desc(),
            )
            .first()
        )
        latest_quotation_file = (
            SalesOpportunityFile.query.filter(
                SalesOpportunityFile.opportunity_id == task.opportunity_id,
                or_(
                    SalesOpportunityFile.original_filename.ilike("%quotation%"),
                    SalesOpportunityFile.original_filename.ilike("%quote%"),
                ),
            )
            .order_by(SalesOpportunityFile.created_at.desc())
            .first()
        )

    return render_template(
        "sales/task_detail.html",
        task=task,
        category_label="Sales",
        category_url=url_for("sales_tasks"),
        client_requirement_form=client_requirement_form,
        latest_quotation_file=latest_quotation_file,
    )


@app.route("/sales/tasks/<int:task_id>/toggle", methods=["POST"])
@login_required
def sales_task_toggle(task_id):
    task = db.session.get(SalesTask, task_id)
    if not task:
        flash("Task not found.", "error")
        return redirect(url_for("sales_tasks"))

    assignee_ids = [user.id for user in task.assignees if getattr(user, "id", None)]
    if task.owner_id:
        assignee_ids.append(task.owner_id)

    _module_visibility_required("sales", owner_user_ids=assignee_ids)

    if task.is_completed:
        task.status = "Pending"
        task.completed_at = None
        message = "Task reopened."
    else:
        task.status = "Completed"
        task.completed_at = datetime.datetime.utcnow()
        message = "Task marked complete."

    db.session.commit()
    flash(message, "success")
    return redirect(url_for("sales_tasks", tab=request.form.get("active_tab") or "taskboard"))


@app.route("/sales/client-requirement-forms/<int:form_id>")
@login_required
def sales_client_requirement_form_detail(form_id):
    form = db.session.get(ClientRequirementForm, form_id)
    if not form:
        flash("Client Requirements form not found.", "error")
        return redirect(url_for("sales_tasks"))

    opportunity = form.opportunity
    owner_id = getattr(opportunity, "owner_id", None) if opportunity else None
    _module_visibility_required("sales", owner_user_id=owner_id)

    sales_data_json = json.dumps(form.sales_data, indent=2, ensure_ascii=False)
    design_data_json = json.dumps(form.design_data, indent=2, ensure_ascii=False)

    return render_template(
        "sales/client_requirement_form_detail.html",
        form=form,
        opportunity=opportunity,
        sales_data_json=sales_data_json,
        design_data_json=design_data_json,
    )


def _form_bool(value):
    if value is None:
        return False
    return str(value).strip().lower() in {"1", "true", "yes", "on", "y", "t"}


def _guarantee_primary_crf_template():
    """Ensure a single active primary Client Requirements template exists."""

    active_primary = (
        FormTemplate.query.filter_by(
            type="client_requirements", is_primary=True, is_active=True
        )
        .order_by(FormTemplate.updated_at.desc())
        .first()
    )
    if active_primary:
        return

    fallback = (
        FormTemplate.query.filter_by(type="client_requirements", is_active=True)
        .order_by(FormTemplate.updated_at.desc())
        .first()
    )
    if fallback:
        fallback.is_primary = True
        db.session.commit()
        return

    ensure_client_requirement_template_seed()


@app.route("/sales/settings", methods=["GET", "POST"])
@login_required
def sales_settings():
    _module_visibility_required("sales")

    templates = (
        FormTemplate.query.filter_by(type="client_requirements")
        .order_by(FormTemplate.updated_at.desc())
        .all()
    )
    active_tab = request.args.get("tab") or "form-templates"

    if request.method == "POST":
        action = (request.form.get("action") or "").strip().lower()
        template_id_raw = request.form.get("template_id")
        name = (request.form.get("name") or "").strip()
        slug = (request.form.get("slug") or "").strip()
        is_primary_flag = _form_bool(request.form.get("is_primary"))
        is_active_flag = _form_bool(request.form.get("is_active", True))
        schema_payload = request.form.get("schema_json")

        if action in {"create", "update"}:
            if not name:
                flash("Template name is required.", "error")
                return redirect(url_for("sales_settings", tab="form-templates"))

            if not slug:
                slug = slugify(name)

            try:
                parsed_schema = (
                    json.loads(schema_payload)
                    if schema_payload
                    else _default_client_requirement_schema()
                )
                if not isinstance(parsed_schema, dict):
                    raise ValueError
            except ValueError:
                flash("Provide a valid JSON schema for the template.", "error")
                return redirect(url_for("sales_settings", tab="form-templates"))

            if action == "create":
                slug_candidate = slug
                suffix = 1
                while FormTemplate.query.filter_by(
                    slug=slug_candidate, type="client_requirements"
                ).first():
                    slug_candidate = f"{slug}-{suffix}"
                    suffix += 1

                template = FormTemplate(
                    name=name,
                    slug=slug_candidate,
                    type="client_requirements",
                    is_primary=is_primary_flag,
                    is_active=is_active_flag,
                    schema_json=json.dumps(parsed_schema, indent=2),
                )
                db.session.add(template)
                flash("Template created.", "success")
            else:
                template = FormTemplate.query.get(template_id_raw)
                if not template:
                    flash("Template not found.", "error")
                    return redirect(url_for("sales_settings", tab="form-templates"))

                if template.type != "client_requirements":
                    flash("Only Client Requirements templates can be edited here.", "error")
                    return redirect(url_for("sales_settings", tab="form-templates"))

                existing_slug_owner = FormTemplate.query.filter_by(
                    slug=slug, type="client_requirements"
                ).first()
                if existing_slug_owner and existing_slug_owner.id != template.id:
                    flash("Slug is already in use for another template.", "error")
                    return redirect(url_for("sales_settings", tab="form-templates"))

                template.name = name
                template.slug = slug
                template.is_active = is_active_flag
                template.is_primary = is_primary_flag if is_active_flag else False
                template.schema_json = json.dumps(parsed_schema, indent=2)
                flash("Template updated.", "success")

            if is_primary_flag and is_active_flag:
                for tpl in templates:
                    if tpl.id != getattr(template, "id", None):
                        tpl.is_primary = False

            db.session.commit()
            _guarantee_primary_crf_template()
            return redirect(url_for("sales_settings", tab="form-templates"))

        elif action == "set_primary":
            template = FormTemplate.query.get(template_id_raw)
            if not template:
                flash("Template not found.", "error")
                return redirect(url_for("sales_settings", tab="form-templates"))

            if template.type != "client_requirements":
                flash("Only Client Requirements templates can be managed here.", "error")
                return redirect(url_for("sales_settings", tab="form-templates"))

            template.is_active = True
            template.is_primary = True
            for tpl in templates:
                if tpl.id != template.id:
                    tpl.is_primary = False
            db.session.commit()
            flash("Template marked as primary.", "success")
            _guarantee_primary_crf_template()
            return redirect(url_for("sales_settings", tab="form-templates"))

        elif action == "toggle_active":
            template = FormTemplate.query.get(template_id_raw)
            if not template:
                flash("Template not found.", "error")
                return redirect(url_for("sales_settings", tab="form-templates"))

            desired_state = _form_bool(request.form.get("desired_state"))
            if not desired_state and template.is_primary:
                alternative = (
                    FormTemplate.query.filter(
                        FormTemplate.type == "client_requirements",
                        FormTemplate.is_active == True,  # noqa: E712
                        FormTemplate.id != template.id,
                    )
                    .order_by(FormTemplate.updated_at.desc())
                    .first()
                )
                if not alternative:
                    flash(
                        "Set another template as primary before deactivating this one.",
                        "error",
                    )
                    return redirect(url_for("sales_settings", tab="form-templates"))

            template.is_active = desired_state
            if not desired_state:
                template.is_primary = False
            db.session.commit()
            flash(
                "Template activated." if desired_state else "Template deactivated.",
                "success",
            )
            _guarantee_primary_crf_template()
            return redirect(url_for("sales_settings", tab="form-templates"))

    primary_template = next((tpl for tpl in templates if tpl.is_primary and tpl.is_active), None)
    default_schema = json.dumps(_default_client_requirement_schema(), indent=2)

    return render_template(
        "sales_settings.html",
        templates=templates,
        active_tab=active_tab,
        primary_template=primary_template,
        default_crf_schema=default_schema,
    )


@app.route("/sales/clients")
@login_required
def sales_clients():
    _module_visibility_required("sales")
    clients = (
        SalesClient.query
        .order_by(SalesClient.display_name.asc())
        .all()
    )
    companies = SalesCompany.query.order_by(func.lower(SalesCompany.name)).all()
    return render_template(
        "sales/clients_list.html",
        clients=clients,
        companies=companies,
        pipeline_map=SALES_PIPELINES,
        temperature_choices=SALES_TEMPERATURES,
    )


@app.route("/sales/clients/export")
@login_required
def sales_clients_export():
    _module_visibility_required("sales")

    clients = SalesClient.query.order_by(SalesClient.display_name.asc()).all()
    timestamp = datetime.datetime.utcnow().strftime("%Y%m%d")
    filename = f"sales_clients_{timestamp}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_sales_client_export_workbook(clients)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_rows = [_sales_client_upload_row(client) for client in clients]
    csv_output = _build_csv_output(SALES_CLIENT_UPLOAD_HEADERS, csv_rows)
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/sales/clients/upload-template")
@login_required
def sales_clients_upload_template():
    _module_visibility_required("sales")

    filename = f"sales_clients_template_{datetime.datetime.utcnow():%Y%m%d}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_sales_client_upload_workbook()
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_output = _build_csv_output(
        SALES_CLIENT_UPLOAD_HEADERS,
        [["" for _ in SALES_CLIENT_UPLOAD_HEADERS]],
    )
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/sales/clients/upload", methods=["POST"])
@login_required
def sales_clients_upload():
    _module_visibility_required("sales")

    upload = request.files.get("client_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(url_for("sales_clients"))

    try:
        header_cells, data_rows = _extract_tabular_upload(
            upload, sheet_name=SALES_CLIENT_TEMPLATE_SHEET_NAME
        )
    except MissingDependencyError:
        flash(OPENPYXL_MISSING_MESSAGE, "error")
        return redirect(url_for("sales_clients"))
    except ValueError:
        flash("Upload a .xlsx or .csv file exported from the clients template.", "error")
        return redirect(url_for("sales_clients"))
    except UploadStageTimeoutError as exc:
        flash(str(exc), "error")
        return redirect(url_for("sales_clients"))
    except Exception:
        flash("Could not read the uploaded file. Ensure it is a valid spreadsheet.", "error")
        return redirect(url_for("sales_clients"))

    header_map = {}
    for idx, header in enumerate(header_cells or []):
        header_label = stringify_cell(header)
        if header_label:
            header_map[header_label] = idx

    if "Display Name" not in header_map:
        flash("The uploaded sheet must include the 'Display Name' column.", "error")
        return redirect(url_for("sales_clients"))

    users = User.query.all()
    user_lookup = {}
    for user in users:
        email_value = clean_str(getattr(user, "email", None))
        if email_value:
            user_lookup[email_value.lower()] = user

    companies = SalesCompany.query.all()
    company_lookup = {
        (company.name or "").strip().lower(): company
        for company in companies
        if company.name
    }

    existing_clients = SalesClient.query.all()
    client_lookup = {
        (client.display_name or "").strip().lower(): client
        for client in existing_clients
        if client.display_name
    }

    created = 0
    updated = 0
    skipped = 0
    errors = []

    for row_index, row in enumerate(data_rows, start=2):
        row_data = {}
        for header, column_index in header_map.items():
            if column_index < len(row):
                row_data[header] = stringify_cell(row[column_index])
            else:
                row_data[header] = None

        name = clean_str(row_data.get("Display Name"))
        if not name:
            skipped += 1
            continue

        email = clean_str(row_data.get("Email"))
        phone = clean_str(row_data.get("Phone"))
        email_opt_out_value = normalize_email_opt_out(row_data.get("Email Opt Out"))
        company_name_value = clean_str(row_data.get("Company Name"))
        tag = clean_str(row_data.get("Tag"))
        category = clean_str(row_data.get("Category")) or "Individual"
        lifecycle = clean_str(row_data.get("Lifecycle Stage"))
        description = clean_str(row_data.get("Description"))
        owner_email = clean_str(row_data.get("Owner Email"))

        row_errors = []
        owner_user = None
        if owner_email:
            candidate = user_lookup.get(owner_email.lower())
            if not candidate or not candidate.can_be_assigned_module("sales"):
                row_errors.append(
                    f"Row {row_index}: Owner email '{owner_email}' is not linked to a sales user."
                )
            else:
                owner_user = candidate

        if lifecycle and lifecycle not in SALES_CLIENT_LIFECYCLE_STAGES:
            row_errors.append(
                f"Row {row_index}: Lifecycle Stage '{lifecycle}' is not valid."
            )

        if row_errors:
            errors.extend(row_errors)
            skipped += 1
            continue

        client = client_lookup.get(name.lower())
        is_new = client is None
        if is_new:
            client = SalesClient(display_name=name)
            client.lifecycle_stage = lifecycle or (
                SALES_CLIENT_LIFECYCLE_STAGES[0]
                if SALES_CLIENT_LIFECYCLE_STAGES
                else None
            )
            client.owner = owner_user or current_user
            db.session.add(client)
            db.session.flush()
            log_sales_activity(
                "client",
                client.id,
                "Client created via bulk upload",
                actor=current_user,
            )
            client_lookup[name.lower()] = client
            created += 1
        else:
            updated += 1

        if company_name_value:
            company_key = company_name_value.lower()
            company = company_lookup.get(company_key)
            if not company:
                company = SalesCompany(name=company_name_value)
                db.session.add(company)
                db.session.flush()
                company_lookup[company_key] = company
            client.company = company
            client.company_name = company.name
        else:
            client.company = None
            client.company_name = None
        client.email = email
        client.phone = phone
        client.email_opt_out = email_opt_out_value
        client.tag = tag
        client.category = category
        if owner_user:
            client.owner = owner_user
        if lifecycle:
            client.lifecycle_stage = lifecycle
        client.description = description

    if created or updated:
        try:
            db.session.commit()
        except Exception:
            db.session.rollback()
            flash("Could not save the uploaded clients due to a database error.", "error")
            return redirect(url_for("sales_clients"))

    summary_bits = []
    if created:
        summary_bits.append(f"{created} created")
    if updated:
        summary_bits.append(f"{updated} updated")
    if skipped:
        summary_bits.append(f"{skipped} skipped")

    if summary_bits:
        flash("Client import complete: " + ", ".join(summary_bits) + ".", "success")
    else:
        flash("No client rows were imported.", "warning")

    if errors:
        preview = errors[:5]
        more = len(errors) - len(preview)
        message = "\n".join(preview)
        if more > 0:
            message += f"\n…and {more} more issue(s)."
        flash(message, "warning")

    return redirect(url_for("sales_clients"))


@app.route("/sales/clients/create", methods=["POST"])
@login_required
def sales_clients_create():
    _module_visibility_required("sales")
    name = (request.form.get("display_name") or "").strip()
    if not name:
        flash("Client name is required.", "error")
        return redirect(url_for("sales_clients"))

    lifecycle_value = normalize_lifecycle_stage(request.form.get("lifecycle_stage"))
    if lifecycle_value is None and SALES_CLIENT_LIFECYCLE_STAGES:
        lifecycle_value = SALES_CLIENT_LIFECYCLE_STAGES[0]

    company_name_raw = (request.form.get("company_name") or "").strip() or None
    company_id_raw = request.form.get("company_id")
    selected_company = None
    if company_id_raw:
        try:
            selected_company = db.session.get(SalesCompany, int(company_id_raw))
        except (TypeError, ValueError):
            selected_company = None

    if not selected_company and company_name_raw:
        existing_company = (
            SalesCompany.query.filter(
                func.lower(SalesCompany.name) == company_name_raw.lower()
            ).first()
        )
        if existing_company:
            selected_company = existing_company
        else:
            selected_company = SalesCompany(name=company_name_raw)
            db.session.add(selected_company)
            db.session.flush()

    client = SalesClient(
        display_name=name,
        company_name=selected_company.name if selected_company else company_name_raw,
        company=selected_company,
        email=(request.form.get("email") or "").strip() or None,
        phone=(request.form.get("phone") or "").strip() or None,
        email_opt_out=normalize_email_opt_out(request.form.get("email_opt_out")),
        category=(request.form.get("category") or "Individual").strip() or "Individual",
        description=(request.form.get("description") or "").strip() or None,
    )

    client.lifecycle_stage = lifecycle_value
    client.owner = current_user

    db.session.add(client)
    db.session.flush()
    log_sales_activity("client", client.id, "Client created")
    db.session.commit()
    flash(f"Client '{client.display_name}' created.", "success")
    return redirect(url_for("sales_client_detail", client_id=client.id))


@app.route("/sales/companies/create", methods=["POST"])
@login_required
def sales_companies_create():
    _module_visibility_required("sales")
    company_name = (request.form.get("company_name") or "").strip()
    if not company_name:
        return jsonify({"success": False, "message": "Company Name is required."}), 400

    company = (
        SalesCompany.query.filter(func.lower(SalesCompany.name) == company_name.lower())
        .first()
    )
    if not company:
        company = SalesCompany(name=company_name)
        db.session.add(company)

    company.projects_per_year = parse_optional_int(request.form.get("projects_per_year"))
    company.contact_person_name = (request.form.get("contact_person_name") or "").strip() or None
    company.contact_person_designation = (request.form.get("contact_person_designation") or "").strip() or None
    company.contact_person_number = (request.form.get("contact_person_number") or "").strip() or None
    company.contact_person_email = (request.form.get("contact_person_email") or "").strip() or None
    company.purchase_manager_name = (request.form.get("purchase_manager_name") or "").strip() or None
    company.purchase_manager_number = (request.form.get("purchase_manager_number") or "").strip() or None
    company.purchase_manager_email = (request.form.get("purchase_manager_email") or "").strip() or None
    company.notes = (request.form.get("company_notes") or "").strip() or None
    company.blacklisted = (request.form.get("blacklisted") or "").lower() == "yes"

    db.session.commit()
    return jsonify(
        {
            "success": True,
            "company": {
                "id": company.id,
                "name": company.display_label,
                "blacklisted": bool(company.blacklisted),
            },
        }
    )


@app.route("/sales/clients/<int:client_id>", methods=["GET", "POST"])
@login_required
def sales_client_detail(client_id):
    client = db.session.get(SalesClient, client_id)
    if not client:
        flash("Client not found.", "error")
        return redirect(url_for("sales_clients"))

    _module_visibility_required("sales", owner_user_id=client.owner_id)

    if request.method == "POST":
        action = request.form.get("form_action") or "update"
        if action == "update":
            client.display_name = (request.form.get("display_name") or "").strip() or client.display_name
            company_name_value = request.form.get("company_name")
            if company_name_value is not None:
                client.company_name = (company_name_value or "").strip() or client.company_name
            client.email = (request.form.get("email") or "").strip() or None
            client.phone = (request.form.get("phone") or "").strip() or None
            client.email_opt_out = normalize_email_opt_out(request.form.get("email_opt_out"))
            client.category = (request.form.get("category") or "").strip() or "Individual"
            lifecycle_value = normalize_lifecycle_stage(request.form.get("lifecycle_stage"))
            client.lifecycle_stage = lifecycle_value
            client.description = (request.form.get("description") or "").strip() or None

            owner_id_raw = request.form.get("owner_id")
            if owner_id_raw:
                try:
                    owner_candidate = db.session.get(User, int(owner_id_raw))
                except (TypeError, ValueError):
                    owner_candidate = None
                if owner_candidate and not owner_candidate.can_be_assigned_module("sales"):
                    flash("The selected owner cannot be assigned to Sales records.", "error")
                    return redirect(url_for("sales_client_detail", client_id=client.id))
                client.owner = owner_candidate
            else:
                client.owner = None

            log_sales_activity("client", client.id, "Client updated", actor=current_user)
            db.session.commit()
            flash("Client details updated.", "success")
            return redirect(url_for("sales_client_detail", client_id=client.id))

        elif action == "update_company":
            company_id_raw = request.form.get("company_id")
            company_name = (request.form.get("company_name") or "").strip()
            company = None
            if company_id_raw:
                try:
                    company = db.session.get(SalesCompany, int(company_id_raw))
                except (TypeError, ValueError):
                    company = None
            if not company and company_name:
                company = (
                    SalesCompany.query.filter(
                        func.lower(SalesCompany.name) == company_name.lower()
                    ).first()
                )
                if not company:
                    company = SalesCompany(name=company_name)
                    db.session.add(company)
                    db.session.flush()

            if company:
                company.projects_per_year = parse_optional_int(request.form.get("projects_per_year"))
                company.contact_person_name = (request.form.get("contact_person_name") or "").strip() or None
                company.contact_person_designation = (request.form.get("contact_person_designation") or "").strip() or None
                company.contact_person_number = (request.form.get("contact_person_number") or "").strip() or None
                company.contact_person_email = (request.form.get("contact_person_email") or "").strip() or None
                company.purchase_manager_name = (request.form.get("purchase_manager_name") or "").strip() or None
                company.purchase_manager_number = (request.form.get("purchase_manager_number") or "").strip() or None
                company.purchase_manager_email = (request.form.get("purchase_manager_email") or "").strip() or None
                company.notes = (request.form.get("company_notes") or "").strip() or None
                company.blacklisted = (request.form.get("blacklisted") or "").lower() == "yes"

            client.company = company
            client.company_name = company.name if company else None

            log_sales_activity("client", client.id, "Company details updated", actor=current_user)
            db.session.commit()
            flash("Company details updated.", "success")
            return redirect(url_for("sales_client_detail", client_id=client.id))

        elif action == "add_note":
            note_title = (request.form.get("note_title") or "").strip() or "Timeline update"
            note_body = (request.form.get("note_body") or "").strip() or None
            log_sales_activity("client", client.id, note_title, notes=note_body)
            db.session.commit()
            flash("Timeline note added.", "success")
            return redirect(url_for("sales_client_detail", client_id=client.id))

    activities = (
        SalesActivity.query
        .filter_by(parent_type="client", parent_id=client.id)
        .order_by(SalesActivity.created_at.desc())
        .all()
    )
    owners = get_assignable_users_for_module("sales", order_by="name")
    open_opportunities = [opp for opp in client.opportunities if not opp.is_closed]
    all_clients = SalesClient.query.order_by(SalesClient.display_name.asc()).all()
    companies = SalesCompany.query.order_by(func.lower(SalesCompany.name)).all()
    return render_template(
        "sales/client_detail.html",
        client=client,
        owners=owners,
        activities=activities,
        open_opportunities=open_opportunities,
        pipeline_map=SALES_PIPELINES,
        opportunity_clients=all_clients,
        temperature_choices=SALES_TEMPERATURES,
        companies=companies,
    )


@app.route("/sales/clients/<int:client_id>/inline-update", methods=["POST"])
@login_required
def sales_client_inline_update(client_id):
    client = db.session.get(SalesClient, client_id)
    if not client:
        return jsonify({"success": False, "message": "Client not found."}), 404

    _module_visibility_required("sales", owner_user_id=client.owner_id)

    display_name = (request.form.get("display_name") or "").strip()
    if not display_name:
        return jsonify({"success": False, "message": "Client name is required."}), 400

    client.display_name = display_name
    client.email = (request.form.get("email") or "").strip() or None
    client.phone = (request.form.get("phone") or "").strip() or None
    client.description = (request.form.get("description") or "").strip() or None

    log_sales_activity(
        "client",
        client.id,
        "Client updated from opportunity view",
        actor=current_user if current_user.is_authenticated else None,
    )
    db.session.commit()

    return jsonify(
        {
            "success": True,
            "client": {
                "id": client.id,
                "display_name": client.display_name,
                "email": client.email,
                "phone": client.phone,
                "description": client.description,
            },
        }
    )


@app.route("/sales/clients/<int:client_id>/summary")
@login_required
def sales_client_summary(client_id):
    client = db.session.get(SalesClient, client_id)
    if not client:
        return jsonify({"success": False, "message": "Client not found."}), 404

    _module_visibility_required("sales", owner_user_id=client.owner_id)

    contact_person = client.company.contact_person_name if client.company else None
    city_value = getattr(client.company, "office_city", None) or getattr(client.company, "city", None)
    state_value = getattr(client.company, "office_state", None) or getattr(client.company, "state", None)

    return jsonify(
        {
            "success": True,
            "client": {
                "id": client.id,
                "display_name": client.display_name,
                "contact_person": contact_person,
                "phone": client.phone,
                "mobile": client.phone,
                "email": client.email,
                "address": None,
                "city": city_value,
                "state": state_value,
                "gst": None,
                "pan": None,
                "created_at": client.created_at.isoformat() if client.created_at else None,
                "remarks": client.description,
                "description": client.description,
            },
        }
    )


@app.route("/sales/opportunities/<pipeline_key>")
@login_required
def sales_opportunities_pipeline(pipeline_key):
    _module_visibility_required("sales")
    pipeline_key = (pipeline_key or "lift").lower()
    if pipeline_key not in SALES_PIPELINES:
        pipeline_key = "lift"
    config = get_pipeline_config(pipeline_key)
    stages = list(config["stages"])
    opportunities = (
        SalesOpportunity.query
        .filter(SalesOpportunity.pipeline == pipeline_key)
        .order_by(SalesOpportunity.stage.asc(), SalesOpportunity.updated_at.desc())
        .all()
    )

    grouped = {stage: [] for stage in stages}
    for opp in opportunities:
        grouped.setdefault(opp.stage, []).append(opp)

    for stage_list in grouped.values():
        stage_list.sort(key=lambda o: o.updated_at or o.created_at, reverse=True)

    owners = get_assignable_users_for_module("sales", order_by="name")
    clients = SalesClient.query.order_by(SalesClient.display_name.asc()).all()
    temperature_choices = SALES_TEMPERATURES
    total_opportunities = sum(len(items) for items in grouped.values())

    stage_totals_raw = {}
    stage_currencies = {}
    stage_totals_display = {}
    for stage in stages:
        opportunities_in_stage = grouped.get(stage, [])
        total_amount = sum(opp.amount for opp in opportunities_in_stage if opp.amount is not None)
        currency = next((opp.currency for opp in opportunities_in_stage if opp.currency), "₹")
        stage_totals_raw[stage] = total_amount
        stage_currencies[stage] = currency
        stage_totals_display[stage] = format_currency(total_amount if opportunities_in_stage else 0, currency)

    return render_template(
        "sales/opportunity_board.html",
        pipeline_key=pipeline_key,
        pipeline_config=config,
        stages=stages,
        grouped=grouped,
        owners=owners,
        clients=clients,
        temperature_choices=temperature_choices,
        pipeline_map=SALES_PIPELINES,
        total_opportunities=total_opportunities,
        stage_totals=stage_totals_display,
        stage_totals_raw=stage_totals_raw,
        stage_currencies=stage_currencies,
    )


@app.route("/sales/opportunities/<pipeline_key>/export")
@login_required
def sales_opportunities_export(pipeline_key):
    _module_visibility_required("sales")

    pipeline_key = (pipeline_key or "lift").lower()
    if pipeline_key not in SALES_PIPELINES:
        pipeline_key = "lift"

    opportunities = (
        SalesOpportunity.query
        .filter(SalesOpportunity.pipeline == pipeline_key)
        .order_by(SalesOpportunity.stage.asc(), SalesOpportunity.updated_at.desc())
        .all()
    )

    timestamp = datetime.datetime.utcnow().strftime("%Y%m%d")
    filename = f"sales_opportunities_{pipeline_key}_{timestamp}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_sales_opportunity_export_workbook(opportunities)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_rows = [_sales_opportunity_upload_row(opp) for opp in opportunities]
    csv_output = _build_csv_output(SALES_OPPORTUNITY_UPLOAD_HEADERS, csv_rows)
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/sales/opportunities/<pipeline_key>/upload-template")
@login_required
def sales_opportunities_upload_template(pipeline_key):
    _module_visibility_required("sales")

    pipeline_key = (pipeline_key or "lift").lower()
    if pipeline_key not in SALES_PIPELINES:
        pipeline_key = "lift"

    filename = f"sales_opportunities_template_{pipeline_key}_{datetime.datetime.utcnow():%Y%m%d}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_sales_opportunity_upload_workbook(pipeline_key)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_output = _build_csv_output(
        SALES_OPPORTUNITY_UPLOAD_HEADERS,
        [["" for _ in SALES_OPPORTUNITY_UPLOAD_HEADERS]],
    )
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/sales/opportunities/upload", methods=["POST"])
@login_required
def sales_opportunities_upload():
    _module_visibility_required("sales")

    default_pipeline = (request.form.get("pipeline") or "lift").lower()
    if default_pipeline not in SALES_PIPELINES:
        default_pipeline = "lift"

    redirect_url = url_for("sales_opportunities_pipeline", pipeline_key=default_pipeline)

    upload = request.files.get("opportunity_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(redirect_url)

    try:
        header_cells, data_rows = _extract_tabular_upload(
            upload, sheet_name=SALES_OPPORTUNITY_TEMPLATE_SHEET_NAME
        )
    except MissingDependencyError:
        flash(OPENPYXL_MISSING_MESSAGE, "error")
        return redirect(redirect_url)
    except ValueError:
        flash("Upload a .xlsx or .csv file exported from the opportunity template.", "error")
        return redirect(redirect_url)
    except UploadStageTimeoutError as exc:
        flash(str(exc), "error")
        return redirect(redirect_url)
    except Exception:
        flash("Could not read the uploaded file. Ensure it is a valid spreadsheet.", "error")
        return redirect(redirect_url)

    header_map = {}
    for idx, header in enumerate(header_cells or []):
        header_label = stringify_cell(header)
        if header_label:
            header_map[header_label] = idx

    if "Title" not in header_map:
        flash("The uploaded sheet must include the 'Title' column.", "error")
        return redirect(redirect_url)

    allowed_temperatures = {value for value, _ in SALES_TEMPERATURES}

    users = User.query.all()
    user_lookup = {}
    for user in users:
        email_value = clean_str(getattr(user, "email", None))
        if email_value:
            user_lookup[email_value.lower()] = user

    existing_clients = SalesClient.query.all()
    client_lookup = {
        (client.display_name or "").strip().lower(): client
        for client in existing_clients
        if client.display_name
    }

    created = 0
    updated = 0
    skipped = 0
    created_clients = 0
    errors = []

    for row_index, row in enumerate(data_rows, start=2):
        row_data = {}
        for header, column_index in header_map.items():
            if column_index < len(row):
                row_data[header] = stringify_cell(row[column_index])
            else:
                row_data[header] = None

        title = clean_str(row_data.get("Title"))
        if not title:
            skipped += 1
            continue

        pipeline_value = clean_str(row_data.get("Pipeline")) or default_pipeline
        pipeline_key = (pipeline_value or "lift").lower()
        if pipeline_key not in SALES_PIPELINES:
            pipeline_key = default_pipeline
        config = get_pipeline_config(pipeline_key)
        stages = config.get("stages", [])

        stage_value = clean_str(row_data.get("Stage")) or (stages[0] if stages else None)
        if stage_value and stage_value not in stages:
            errors.append(
                f"Row {row_index}: Stage '{stage_value}' is not valid for the {config['label']} pipeline."
            )
            skipped += 1
            continue

        status_value = clean_str(row_data.get("Status")) or "Open"
        temperature_raw = clean_str(row_data.get("Temperature"))
        temperature_value = None
        if temperature_raw:
            lowered = temperature_raw.lower()
            if lowered not in allowed_temperatures:
                errors.append(
                    f"Row {row_index}: Temperature '{temperature_raw}' is not valid."
                )
                skipped += 1
                continue
            temperature_value = lowered

        amount_value, amount_error = parse_float_field(row_data.get("Amount"), "Amount")
        if amount_error:
            errors.append(f"Row {row_index}: {amount_error}")
            skipped += 1
            continue

        currency_value = clean_str(row_data.get("Currency")) or "₹"

        expected_close_value, date_error = parse_date_field(
            row_data.get("Expected Close Date"), "Expected Close Date"
        )
        if date_error:
            errors.append(f"Row {row_index}: {date_error}")
            skipped += 1
            continue

        probability_value, probability_error = parse_int_field(
            row_data.get("Probability"), "Probability"
        )
        if probability_error:
            errors.append(f"Row {row_index}: {probability_error}")
            skipped += 1
            continue
        if probability_value is not None and not (0 <= probability_value <= 100):
            errors.append(
                f"Row {row_index}: Probability '{probability_value}' must be between 0 and 100."
            )
            skipped += 1
            continue

        owner_email = clean_str(row_data.get("Owner Email"))
        owner_user = None
        if owner_email:
            candidate = user_lookup.get(owner_email.lower())
            if not candidate or not candidate.can_be_assigned_module("sales"):
                errors.append(
                    f"Row {row_index}: Owner email '{owner_email}' is not linked to a sales user."
                )
                skipped += 1
                continue
            owner_user = candidate

        client_name = clean_str(row_data.get("Client Name"))
        related_project = clean_str(row_data.get("Related Project"))
        description = clean_str(row_data.get("Description"))

        client = None
        if client_name:
            client = client_lookup.get(client_name.lower())
            if not client:
                client = SalesClient(
                    display_name=client_name,
                    owner=owner_user or current_user,
                    lifecycle_stage=(
                        SALES_CLIENT_LIFECYCLE_STAGES[0]
                        if SALES_CLIENT_LIFECYCLE_STAGES
                        else None
                    ),
                )
                db.session.add(client)
                db.session.flush()
                log_sales_activity(
                    "client",
                    client.id,
                    "Client created via opportunity upload",
                    actor=current_user,
                )
                client_lookup[client_name.lower()] = client
                created_clients += 1

        query = (
            SalesOpportunity.query
            .filter(func.lower(SalesOpportunity.title) == title.lower())
            .filter(SalesOpportunity.pipeline == pipeline_key)
        )
        if client:
            query = query.filter(SalesOpportunity.client_id == client.id)
        else:
            query = query.filter(SalesOpportunity.client_id.is_(None))

        opportunity = query.first()
        is_new = opportunity is None
        if is_new:
            opportunity = SalesOpportunity(title=title, pipeline=pipeline_key)
            db.session.add(opportunity)
            created += 1
        else:
            updated += 1

        opportunity.stage = stage_value or opportunity.stage
        opportunity.status = status_value
        opportunity.temperature = temperature_value
        opportunity.amount = amount_value
        opportunity.currency = currency_value
        opportunity.expected_close_date = expected_close_value
        opportunity.probability = probability_value
        if owner_user:
            opportunity.owner = owner_user
        elif is_new and not opportunity.owner:
            opportunity.owner = current_user
        if client:
            opportunity.client = client
        opportunity.related_project = related_project
        opportunity.description = description

        if is_new:
            db.session.flush()
            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Opportunity imported via bulk upload",
                actor=current_user,
            )

    if created or updated or created_clients:
        try:
            db.session.commit()
        except Exception:
            db.session.rollback()
            flash("Could not save the uploaded opportunities due to a database error.", "error")
            return redirect(redirect_url)

    summary_bits = []
    if created:
        summary_bits.append(f"{created} created")
    if updated:
        summary_bits.append(f"{updated} updated")
    if created_clients:
        summary_bits.append(f"{created_clients} client(s) created")
    if skipped:
        summary_bits.append(f"{skipped} skipped")

    if summary_bits:
        flash("Opportunity import complete: " + ", ".join(summary_bits) + ".", "success")
    else:
        flash("No opportunity rows were imported.", "warning")

    if errors:
        preview = errors[:5]
        more = len(errors) - len(preview)
        message = "\n".join(preview)
        if more > 0:
            message += f"\n…and {more} more issue(s)."
        flash(message, "warning")

    return redirect(redirect_url)


@app.route("/sales/opportunities/create", methods=["POST"])
@login_required
def sales_opportunities_create():
    _module_visibility_required("sales")
    title = (request.form.get("title") or "").strip()
    pipeline_key = (request.form.get("pipeline") or "lift").lower()
    config = get_pipeline_config(pipeline_key)

    if not title:
        flash("Opportunity title is required.", "error")
        return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

    stage_value = (request.form.get("stage") or config["stages"][0]).strip()
    if stage_value not in config["stages"]:
        stage_value = config["stages"][0]

    amount_raw = (request.form.get("amount") or "").strip()
    amount_value = None
    if amount_raw:
        try:
            amount_value = float(amount_raw)
        except ValueError:
            flash("Amount must be a valid number.", "error")
            return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

    opportunity = SalesOpportunity(
        title=title,
        pipeline=pipeline_key,
        stage=stage_value,
        temperature=(request.form.get("temperature") or "").strip() or None,
        amount=amount_value,
        description=(request.form.get("description") or "").strip() or None,
    )

    opportunity.owner = current_user

    client_id_raw = request.form.get("client_id")
    if client_id_raw:
        try:
            opportunity.client = db.session.get(SalesClient, int(client_id_raw))
        except (TypeError, ValueError):
            opportunity.client = None

    db.session.add(opportunity)
    db.session.flush()
    log_sales_activity("opportunity", opportunity.id, "Opportunity created")
    db.session.commit()
    flash("Opportunity created.", "success")
    return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))


@app.route("/sales/opportunities/<int:opportunity_id>", methods=["GET", "POST"])
@login_required
def sales_opportunity_detail(opportunity_id):
    opportunity = db.session.get(SalesOpportunity, opportunity_id)
    if not opportunity:
        flash("Opportunity not found.", "error")
        return redirect(url_for("sales_opportunities_pipeline", pipeline_key="lift"))

    _module_visibility_required("sales", owner_user_id=opportunity.owner_id)

    pipeline_key = opportunity.pipeline
    stages = get_pipeline_stages(pipeline_key)
    pipeline_config = get_pipeline_config(pipeline_key)
    current_stage_index = stages.index(opportunity.stage) if opportunity.stage in stages else 0

    if request.method == "POST":
        action = request.form.get("form_action") or "update"
        if action == "update":
            opportunity.title = (request.form.get("title") or "").strip() or opportunity.title
            stage_value = (request.form.get("stage") or stages[0]).strip()
            if stage_value not in stages:
                stage_value = stages[0]
            opportunity.stage = stage_value
            opportunity.temperature = (request.form.get("temperature") or "").strip() or None
            amount_raw = (request.form.get("amount") or "").strip()
            if amount_raw:
                try:
                    opportunity.amount = float(amount_raw)
                except ValueError:
                    flash("Amount must be a valid number.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            else:
                opportunity.amount = None
            probability_raw = (request.form.get("probability") or "").strip()
            if probability_raw:
                try:
                    opportunity.probability = int(probability_raw)
                except ValueError:
                    flash("Probability must be a whole number.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            else:
                opportunity.probability = None
            expected_close_raw = (request.form.get("expected_close_date") or "").strip()
            if expected_close_raw:
                try:
                    opportunity.expected_close_date = datetime.datetime.strptime(expected_close_raw, "%Y-%m-%d").date()
                except ValueError:
                    flash("Expected close date must be YYYY-MM-DD.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            else:
                opportunity.expected_close_date = None
            opportunity.related_project = (request.form.get("related_project") or "").strip() or None
            opportunity.description = (request.form.get("description") or "").strip() or None

            client_id_raw = request.form.get("client_id")
            if client_id_raw:
                try:
                    opportunity.client = db.session.get(SalesClient, int(client_id_raw))
                except (TypeError, ValueError):
                    opportunity.client = None
            else:
                opportunity.client = None

            owner_id_raw = request.form.get("owner_id")
            if owner_id_raw:
                try:
                    owner_candidate = db.session.get(User, int(owner_id_raw))
                except (TypeError, ValueError):
                    owner_candidate = None
                if owner_candidate and not owner_candidate.can_be_assigned_module("sales"):
                    flash("The selected owner cannot be assigned to Sales opportunities.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
                opportunity.owner = owner_candidate
            else:
                opportunity.owner = None

            log_sales_activity("opportunity", opportunity.id, "Opportunity updated", actor=current_user)
            db.session.commit()
            flash("Opportunity updated.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "add_note":
            note_title = (request.form.get("note_title") or "").strip() or "Timeline update"
            note_body = (request.form.get("note_body") or "").strip() or None
            log_sales_activity("opportunity", opportunity.id, note_title, notes=note_body)
            db.session.commit()
            flash("Timeline note added.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "add_comment":
            body = (request.form.get("comment_body") or "").strip()
            if not body:
                flash("Comment cannot be empty.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            comment = SalesOpportunityComment(
                opportunity=opportunity,
                body=body,
                author=current_user if current_user.is_authenticated else None,
            )
            db.session.add(comment)

            snippet = body if len(body) <= 120 else f"{body[:117]}..."
            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Comment added",
                notes=snippet,
                actor=current_user,
            )
            db.session.commit()
            flash("Comment saved.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "link_client_requirement":
            can_manage_docs = (
                current_user.is_admin
                or opportunity.owner_id is None
                or opportunity.owner_id == current_user.id
            )
            if not can_manage_docs:
                flash("Only the opportunity owner can link Client Requirements.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            link_mode = (request.form.get("link_mode") or "existing").strip()
            if link_mode == "existing":
                try:
                    existing_id = int(request.form.get("existing_form_id") or "0")
                except (TypeError, ValueError):
                    existing_id = 0

                if not existing_id:
                    flash("Select a Client Requirements form to link.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

                form = db.session.get(ClientRequirementForm, existing_id)
                if not form:
                    flash("Selected Client Requirements form not found.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

                existing_client_id = getattr(getattr(form, "opportunity", None), "client_id", None)
                if opportunity.client_id and existing_client_id and existing_client_id != opportunity.client_id:
                    flash("You can only link forms that belong to the same client.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

                if form.opportunity_id == opportunity.id:
                    flash("This Client Requirements form is already linked.", "info")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

                form.opportunity = opportunity
                form.project_id = opportunity.project_id
                db.session.commit()

                log_sales_activity(
                    "opportunity",
                    opportunity.id,
                    "Client Requirements linked",
                    notes=f"Linked form #{form.id} to opportunity.",
                    actor=current_user,
                )
                flash("Client Requirements form linked.", "success")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            _guarantee_primary_crf_template()
            template = (
                FormTemplate.query.filter_by(type="client_requirements", is_primary=True)
                .order_by(FormTemplate.updated_at.desc())
                .first()
            )
            if not template:
                flash("No active Client Requirements template found.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            latest_form = (
                ClientRequirementForm.query.filter_by(opportunity_id=opportunity.id)
                .order_by(ClientRequirementForm.version.desc())
                .first()
            )
            next_version = (latest_form.version if latest_form else 0) + 1

            sales_defaults = {
                "opportunity_title": opportunity.title,
                "opportunity_id": opportunity.id,
                "client_id": opportunity.client_id,
                "client_name": getattr(opportunity.client, "display_name", None),
                "sales_owner": getattr(opportunity.owner, "display_name", None),
            }

            new_form = ClientRequirementForm(
                opportunity=opportunity,
                template=template,
                version=next_version,
                status="draft",
                sales_section_data=json.dumps(sales_defaults, ensure_ascii=False),
                created_by_sales=current_user if current_user.is_authenticated else None,
                project_id=opportunity.project_id,
            )
            db.session.add(new_form)
            db.session.commit()

            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Client Requirements created",
                notes=f"Draft created (v{next_version}).",
                actor=current_user,
            )
            flash("New Client Requirements form created.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "upload_file":
            uploaded_file = request.files.get("attachment")
            if not uploaded_file or not uploaded_file.filename:
                flash("Select a file to upload.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            safe_name = secure_filename(uploaded_file.filename)
            if not safe_name:
                flash("The selected file name is not valid.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            upload_root = os.path.join(app.config["UPLOAD_FOLDER"], "opportunities", str(opportunity.id))
            os.makedirs(upload_root, exist_ok=True)

            unique_name = f"{uuid.uuid4().hex}_{safe_name}"
            destination_path = os.path.join(upload_root, unique_name)
            uploaded_file.save(destination_path)

            static_root = os.path.join(BASE_DIR, "static")
            stored_relative = os.path.relpath(destination_path, static_root).replace(os.sep, "/")

            record = SalesOpportunityFile(
                opportunity=opportunity,
                original_filename=uploaded_file.filename,
                stored_path=stored_relative,
                content_type=uploaded_file.mimetype,
                file_size=os.path.getsize(destination_path),
                uploaded_by=current_user if current_user.is_authenticated else None,
            )
            db.session.add(record)

            log_sales_activity(
                "opportunity",
                opportunity.id,
                "File uploaded",
                notes=uploaded_file.filename,
                actor=current_user,
            )
            db.session.commit()
            flash("File uploaded.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "upload_quotation":
            can_manage_docs = (
                current_user.is_admin
                or opportunity.owner_id is None
                or opportunity.owner_id == current_user.id
            )
            if not can_manage_docs:
                flash("Only the opportunity owner can upload quotations.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            uploaded_file = request.files.get("quotation_file")
            if not uploaded_file or not uploaded_file.filename:
                flash("Select a quotation file to upload.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            safe_name = secure_filename(uploaded_file.filename)
            if not safe_name:
                flash("The selected file name is not valid.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            quote_root = os.path.join(
                app.config["UPLOAD_FOLDER"], "opportunities", str(opportunity.id), "quotations"
            )
            os.makedirs(quote_root, exist_ok=True)

            request_id_raw = (request.form.get("quotation_request_id") or "").strip()
            linked_request = None
            if request_id_raw:
                try:
                    linked_request = (
                        SalesQuotationRequest.query.filter_by(
                            id=int(request_id_raw), opportunity_id=opportunity.id
                        ).first()
                    )
                except (TypeError, ValueError):
                    linked_request = None
                if not linked_request:
                    flash("Selected quotation request not found for this opportunity.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            existing_quotes = (
                SalesOpportunityFile.query.filter(
                    SalesOpportunityFile.opportunity_id == opportunity.id,
                    or_(
                        SalesOpportunityFile.stored_path.ilike("%/quotations/%"),
                        SalesOpportunityFile.original_filename.ilike("%quotation%"),
                        SalesOpportunityFile.original_filename.ilike("%quote%"),
                    ),
                )
                .order_by(SalesOpportunityFile.created_at.desc())
                .all()
            )
            next_version = len(existing_quotes) + 1

            unique_name = f"{uuid.uuid4().hex}_{safe_name}"
            destination_path = os.path.join(quote_root, unique_name)
            uploaded_file.save(destination_path)

            static_root = os.path.join(BASE_DIR, "static")
            stored_relative = os.path.relpath(destination_path, static_root).replace(os.sep, "/")
            versioned_name = f"Quotation V{next_version} – {uploaded_file.filename}"

            record = SalesOpportunityFile(
                opportunity=opportunity,
                quotation_request=linked_request,
                original_filename=versioned_name,
                stored_path=stored_relative,
                content_type=uploaded_file.mimetype,
                file_size=os.path.getsize(destination_path),
                uploaded_by=current_user if current_user.is_authenticated else None,
            )
            db.session.add(record)

            log_sales_activity(
                "opportunity",
                opportunity.id,
                f"Quotation uploaded (V{next_version})",
                notes=uploaded_file.filename,
                actor=current_user,
            )
            db.session.commit()
            flash("Quotation uploaded.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "create_quotation_request":
            can_manage_docs = (
                current_user.is_admin
                or opportunity.owner_id is None
                or opportunity.owner_id == current_user.id
            )
            if not can_manage_docs:
                flash("Only the opportunity owner can create quotation requests.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            selected_items = request.form.getlist("quotation_request_items")
            if not selected_items:
                flash("Select at least one item to request a quotation for.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            try:
                item_ids = [int(item_id) for item_id in selected_items]
            except (TypeError, ValueError):
                flash("Invalid item selection.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            valid_items = (
                SalesOpportunityItem.query.filter(
                    SalesOpportunityItem.id.in_(item_ids),
                    SalesOpportunityItem.opportunity_id == opportunity.id,
                ).all()
            )
            if len(valid_items) != len(item_ids):
                flash("One or more selected items do not belong to this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            linked_crf_id_raw = (request.form.get("linked_crf_id") or "").strip()
            linked_crf = None
            if linked_crf_id_raw:
                try:
                    linked_crf = ClientRequirementForm.query.filter_by(
                        id=int(linked_crf_id_raw), opportunity_id=opportunity.id
                    ).first()
                except (TypeError, ValueError):
                    linked_crf = None
                if not linked_crf:
                    flash("Selected Client Requirements form not found for this opportunity.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            notes = (request.form.get("quotation_request_notes") or "").strip() or None
            request_record = SalesQuotationRequest(
                opportunity=opportunity,
                status="requested",
                requested_by=current_user if current_user.is_authenticated else None,
                requested_at=datetime.datetime.utcnow(),
                linked_crf=linked_crf,
                notes=notes,
            )
            db.session.add(request_record)
            db.session.flush()

            for item in valid_items:
                link = SalesQuotationRequestItem(request=request_record, opportunity_item=item)
                db.session.add(link)

            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Quotation request created",
                notes=f"Request #{request_record.id} for {len(valid_items)} item(s).",
                actor=current_user,
            )
            db.session.commit()
            flash("Quotation request submitted.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "update_quotation_request_status":
            can_manage_docs = (
                current_user.is_admin
                or opportunity.owner_id is None
                or opportunity.owner_id == current_user.id
            )
            if not can_manage_docs:
                flash("Only the opportunity owner can update quotation requests.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            request_id_raw = (request.form.get("quotation_request_id") or "").strip()
            target_status = (request.form.get("target_status") or "").strip().lower()
            allowed_statuses = {
                "requested",
                "in_progress",
                "shared",
                "revised",
                "finalized",
                "cancelled",
            }
            if target_status not in allowed_statuses:
                flash("Invalid status selected.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            try:
                request_record = (
                    SalesQuotationRequest.query.filter_by(
                        id=int(request_id_raw), opportunity_id=opportunity.id
                    ).first()
                )
            except (TypeError, ValueError):
                request_record = None
            if not request_record:
                flash("Quotation request not found.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            request_record.status = target_status
            request_record.updated_at = datetime.datetime.utcnow()
            log_sales_activity(
                "opportunity",
                opportunity.id,
                f"Quotation request {request_record.id} marked {request_record.status_label}",
                actor=current_user,
            )
            db.session.commit()
            flash("Quotation request updated.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "quotation_request_negotiation":
            can_manage_docs = (
                current_user.is_admin
                or opportunity.owner_id is None
                or opportunity.owner_id == current_user.id
            )
            if not can_manage_docs:
                flash("Only the opportunity owner can request negotiation.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            request_id_raw = (request.form.get("quotation_request_id") or "").strip()
            reason = (request.form.get("negotiation_reason") or "").strip() or None
            suggest_stage = request.form.get("move_to_negotiation") == "on"
            try:
                request_record = (
                    SalesQuotationRequest.query.filter_by(
                        id=int(request_id_raw), opportunity_id=opportunity.id
                    ).first()
                )
            except (TypeError, ValueError):
                request_record = None

            if not request_record:
                flash("Quotation request not found.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            log_entry = SalesQuotationNegotiationLog(
                request=request_record,
                created_by=current_user if current_user.is_authenticated else None,
                reason=reason,
                suggested_stage="Negotiation",
            )
            db.session.add(log_entry)

            stage_changed = False
            if suggest_stage and "Negotiation" in stages and opportunity.stage != "Negotiation":
                opportunity.stage = "Negotiation"
                stage_changed = True

            log_sales_activity(
                "opportunity",
                opportunity.id,
                f"Negotiation requested for quotation request #{request_record.id}",
                notes=reason,
                actor=current_user,
            )
            db.session.commit()

            if stage_changed:
                flash("Negotiation log added and stage moved to Negotiation.", "success")
            else:
                flash("Negotiation log added. Consider moving the stage to Negotiation.", "info")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action in {"add_item", "create_item", "update_item"}:
            def parse_item_form():
                qty_raw = (request.form.get("item_quantity") or "1").strip()
                try:
                    qty_value = int(qty_raw or 1)
                    if qty_value < 1:
                        raise ValueError
                except ValueError:
                    flash("Quantity must be at least 1.", "error")
                    return None

                lift_type_value = (request.form.get("lift_type") or "").strip() or None
                door_type_value = (request.form.get("door_type") or "").strip() or None
                floors_value = (request.form.get("floors") or "").strip() or None
                cabin_finish_value = (request.form.get("cabin_finish") or "").strip() or None
                details_value = (request.form.get("details") or "").strip() or None
                structure_required_value = bool(request.form.get("structure_required"))

                item_value_raw = (request.form.get("item_value") or "").strip()
                item_value = None
                if item_value_raw:
                    try:
                        item_value = Decimal(item_value_raw)
                        if item_value < 0:
                            raise ValueError
                    except (InvalidOperation, ValueError):
                        flash("Item value must be zero or greater.", "error")
                        return None

                return {
                    "lift_type": lift_type_value,
                    "door_type": door_type_value,
                    "floors": floors_value,
                    "cabin_finish": cabin_finish_value,
                    "details": details_value,
                    "quantity": qty_value,
                    "structure_required": structure_required_value,
                    "item_value": item_value,
                }

            item_data = parse_item_form()
            if not item_data:
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            if action in {"add_item", "create_item"}:
                item = SalesOpportunityItem(
                    opportunity=opportunity,
                    lift_type=item_data["lift_type"],
                    door_type=item_data["door_type"],
                    floors=item_data["floors"],
                    cabin_finish=item_data["cabin_finish"],
                    details=item_data["details"],
                    quantity=item_data["quantity"],
                    item_value=item_data["item_value"],
                    structure_required=item_data["structure_required"],
                )
                db.session.add(item)
                summary_bits = [
                    f"Qty: {item.quantity}",
                    f"Structure: {item.structure_label}",
                ]
                if item.item_value is not None:
                    summary_bits.append(f"Value: {item.item_value}")
                log_sales_activity(
                    "opportunity",
                    opportunity.id,
                    "Item added",
                    notes="; ".join(summary_bits) or None,
                    actor=current_user,
                )
                db.session.commit()
                flash("Opportunity item added.", "success")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            item_id_raw = request.form.get("item_id")
            try:
                item_id = int(item_id_raw)
            except (TypeError, ValueError):
                flash("Invalid item selected for update.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            item = db.session.get(SalesOpportunityItem, item_id)
            if not item or item.opportunity_id != opportunity.id:
                flash("Item not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            item.lift_type = item_data["lift_type"]
            item.door_type = item_data["door_type"]
            item.floors = item_data["floors"]
            item.cabin_finish = item_data["cabin_finish"]
            item.details = item_data["details"]
            item.quantity = item_data["quantity"]
            item.item_value = item_data["item_value"]
            item.structure_required = item_data["structure_required"]

            summary_bits = [f"Qty: {item.quantity}", f"Structure: {item.structure_label}"]
            if item.item_value is not None:
                summary_bits.append(f"Value: {item.item_value}")

            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Item updated",
                notes="; ".join(summary_bits) or None,
                actor=current_user,
            )
            db.session.commit()
            flash("Opportunity item updated.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "delete_item":
            item_id_raw = request.form.get("item_id")
            try:
                item_id = int(item_id_raw)
            except (TypeError, ValueError):
                flash("Invalid item selected for deletion.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            item = db.session.get(SalesOpportunityItem, item_id)
            if not item or item.opportunity_id != opportunity.id:
                flash("Item not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            db.session.delete(item)
            log_sales_activity(
                "opportunity",
                opportunity.id,
                "Item removed",
                notes=item.lift_type or item.details or f"Item #{item.id}",
                actor=current_user,
            )
            db.session.commit()
            flash("Opportunity item deleted.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action in {"schedule_activity", "update_activity"}:
            is_update = action == "update_activity"
            engagement = None
            if is_update:
                engagement_id_raw = request.form.get("engagement_id")
                try:
                    engagement_id = int(engagement_id_raw)
                except (TypeError, ValueError):
                    flash("Invalid activity selected for update.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

                engagement = db.session.get(SalesOpportunityEngagement, engagement_id)
                if not engagement or engagement.opportunity_id != opportunity.id:
                    flash("Activity not found for this opportunity.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
                if (engagement.status or "open").lower() != "open":
                    flash("Only open activities can be edited.", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            activity_type = (request.form.get("activity_type") or "meeting").strip().lower()
            if activity_type not in OPPORTUNITY_ACTIVITY_TYPES:
                activity_type = "meeting"

            subject = (request.form.get("activity_subject") or "").strip()
            activity_date_raw = (request.form.get("activity_date") or "").strip()
            activity_time_raw = (request.form.get("activity_time") or "").strip()
            reminder_option = (request.form.get("reminder_option") or "").strip()
            if reminder_option not in OPPORTUNITY_REMINDER_VALUES:
                reminder_option = ""
            additional_notes = (request.form.get("activity_notes") or "").strip()

            scheduled_parts = []
            if activity_date_raw:
                try:
                    scheduled_date = datetime.datetime.strptime(activity_date_raw, "%Y-%m-%d").date()
                    scheduled_parts.append(scheduled_date.strftime("%d %b %Y"))
                except ValueError:
                    flash("Provide a valid date for the activity (YYYY-MM-DD).", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            else:
                scheduled_date = None

            if activity_time_raw:
                try:
                    scheduled_time = datetime.datetime.strptime(activity_time_raw, "%H:%M").time()
                    scheduled_parts.append(scheduled_time.strftime("%I:%M %p"))
                except ValueError:
                    flash("Provide a valid time for the activity (HH:MM).", "error")
                    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            else:
                scheduled_time = None

            scheduled_for = None
            if scheduled_date and scheduled_time:
                scheduled_for = datetime.datetime.combine(scheduled_date, scheduled_time)
            elif scheduled_date:
                scheduled_for = datetime.datetime.combine(scheduled_date, datetime.time())
            elif scheduled_time:
                scheduled_for = datetime.datetime.combine(datetime.date.today(), scheduled_time)

            details = []
            if scheduled_parts:
                details.append(f"Scheduled for {' '.join(scheduled_parts)}.")
            elif not subject:
                details.append("Scheduled without a specific date. Update when confirmed.")

            reminder_label = REMINDER_OPTION_LABELS.get(reminder_option or "", "No reminder")
            if reminder_option:
                details.append(f"Reminder set: {reminder_label}.")

            if additional_notes:
                details.append(additional_notes)

            activity_label = OPPORTUNITY_ACTIVITY_LABELS.get(activity_type, activity_type.title())
            notes_value = "\n\n".join(details) if details else None
            if is_update and engagement:
                engagement.activity_type = activity_type
                engagement.subject = subject or None
                engagement.scheduled_for = scheduled_for
                engagement.reminder_option = reminder_option or None
                engagement.notes = additional_notes or None
                engagement.status = "open"
                title = subject or f"Updated {activity_label}"
                log_sales_activity(
                    "opportunity",
                    opportunity.id,
                    title,
                    notes=notes_value,
                    actor=current_user,
                )
                db.session.commit()
                flash("Activity updated.", "success")
            else:
                engagement = SalesOpportunityEngagement(
                    opportunity=opportunity,
                    activity_type=activity_type,
                    subject=subject or None,
                    scheduled_for=scheduled_for,
                    reminder_option=reminder_option or None,
                    notes=additional_notes or None,
                    created_by=current_user if current_user.is_authenticated else None,
                )
                db.session.add(engagement)

                title = subject or f"Scheduled {activity_label}"
                log_sales_activity(
                    "opportunity",
                    opportunity.id,
                    title,
                    notes=notes_value,
                    actor=current_user,
                )
                db.session.commit()
                flash("Activity scheduled.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "log_activity":
            engagement_id_raw = request.form.get("engagement_id")
            try:
                engagement_id = int(engagement_id_raw)
            except (TypeError, ValueError):
                flash("Invalid activity selected for logging.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            engagement = db.session.get(SalesOpportunityEngagement, engagement_id)
            if not engagement or engagement.opportunity_id != opportunity.id:
                flash("Activity not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            if (engagement.status or "open").lower() != "open":
                flash("Only open activities can be logged/closed.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            outcome = (request.form.get("outcome") or "").strip()
            valid_outcomes = {value for value, _ in OPPORTUNITY_ACTIVITY_OUTCOMES}
            if outcome not in valid_outcomes:
                flash("Select an outcome before logging the activity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            next_action_type = (request.form.get("next_action_type") or "").strip().lower()
            if next_action_type and next_action_type not in OPPORTUNITY_ACTIVITY_TYPES:
                next_action_type = ""
            next_action_subject = (request.form.get("next_action_subject") or "").strip()
            next_action_date_raw = (request.form.get("next_action_date") or "").strip()
            next_action_time_raw = (request.form.get("next_action_time") or "").strip()
            next_action_reminder = (request.form.get("next_action_reminder") or "").strip()
            if next_action_reminder not in OPPORTUNITY_REMINDER_VALUES:
                next_action_reminder = ""
            next_action_notes = (request.form.get("next_action_notes") or "").strip()

            next_action_schedule_parts = []
            next_action_scheduled_for = None
            if next_action_type:
                if next_action_date_raw:
                    try:
                        next_action_date = datetime.datetime.strptime(next_action_date_raw, "%Y-%m-%d").date()
                        next_action_schedule_parts.append(next_action_date.strftime("%d %b %Y"))
                    except ValueError:
                        flash("Provide a valid date for the next action (YYYY-MM-DD).", "error")
                        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
                else:
                    next_action_date = None

                if next_action_time_raw:
                    try:
                        next_action_time = datetime.datetime.strptime(next_action_time_raw, "%H:%M").time()
                        next_action_schedule_parts.append(next_action_time.strftime("%I:%M %p"))
                    except ValueError:
                        flash("Provide a valid time for the next action (HH:MM).", "error")
                        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
                else:
                    next_action_time = None

                if next_action_date and next_action_time:
                    next_action_scheduled_for = datetime.datetime.combine(next_action_date, next_action_time)
                elif next_action_date:
                    next_action_scheduled_for = datetime.datetime.combine(next_action_date, datetime.time())
                elif next_action_time:
                    next_action_scheduled_for = datetime.datetime.combine(datetime.date.today(), next_action_time)

            log_details = (request.form.get("log_details") or "").strip() or None
            engagement.status = "done"
            engagement.outcome = outcome
            engagement.log_details = log_details
            engagement.completed_at = datetime.datetime.utcnow()
            engagement.completed_by = current_user if current_user.is_authenticated else None

            outcome_label = dict(OPPORTUNITY_ACTIVITY_OUTCOMES).get(outcome, outcome.replace("_", " ").title())
            title = engagement.subject or f"Completed {engagement.display_activity_type}"
            detail_lines = [f"Outcome: {outcome_label}"]
            if log_details:
                detail_lines.append(log_details)
            next_action_label = None
            if next_action_type:
                next_action_label = OPPORTUNITY_ACTIVITY_LABELS.get(next_action_type, next_action_type.title())
                schedule_suffix = f" scheduled for {' '.join(next_action_schedule_parts)}" if next_action_schedule_parts else ""
                detail_lines.append(f"Next action: {next_action_label}{schedule_suffix}.")
            log_sales_activity(
                "opportunity",
                opportunity.id,
                title,
                notes="\n\n".join(detail_lines),
                actor=current_user,
            )

            next_action_created = False
            if next_action_type and next_action_label:
                next_engagement = SalesOpportunityEngagement(
                    opportunity=opportunity,
                    activity_type=next_action_type,
                    subject=next_action_subject or f"{next_action_label} follow-up",
                    scheduled_for=next_action_scheduled_for,
                    reminder_option=next_action_reminder or None,
                    notes=next_action_notes or None,
                    created_by=current_user if current_user.is_authenticated else None,
                )
                db.session.add(next_engagement)

                next_action_notes_lines = []
                if next_action_schedule_parts:
                    next_action_notes_lines.append(f"Scheduled for {' '.join(next_action_schedule_parts)}.")
                if next_action_reminder:
                    next_action_notes_lines.append(f"Reminder set: {REMINDER_OPTION_LABELS.get(next_action_reminder, 'No reminder')}.")
                if next_action_notes:
                    next_action_notes_lines.append(next_action_notes)

                log_sales_activity(
                    "opportunity",
                    opportunity.id,
                    f"Next action created: {next_action_label}",
                    notes="\n\n".join(next_action_notes_lines) if next_action_notes_lines else None,
                    actor=current_user,
                )
                next_action_created = True
            db.session.commit()
            flash_message = "Activity logged and closed."
            if next_action_created and next_action_label:
                flash_message = f"Activity logged. Next {next_action_label.lower()} created."
            flash(flash_message, "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "cancel_activity":
            engagement_id_raw = request.form.get("engagement_id")
            try:
                engagement_id = int(engagement_id_raw)
            except (TypeError, ValueError):
                flash("Invalid activity selected for cancellation.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            engagement = db.session.get(SalesOpportunityEngagement, engagement_id)
            if not engagement or engagement.opportunity_id != opportunity.id:
                flash("Activity not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            if (engagement.status or "open").lower() != "open":
                flash("Only open activities can be cancelled.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            cancel_reason = (request.form.get("cancel_reason") or "").strip() or None
            engagement.status = "cancelled"
            engagement.completed_at = datetime.datetime.utcnow()
            engagement.completed_by = current_user if current_user.is_authenticated else None
            if cancel_reason:
                engagement.log_details = cancel_reason

            title = engagement.subject or f"Cancelled {engagement.display_activity_type}"
            log_sales_activity(
                "opportunity",
                opportunity.id,
                title,
                notes=cancel_reason,
                actor=current_user,
            )
            db.session.commit()
            flash("Activity cancelled.", "info")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        elif action == "delete_activity":
            engagement_id_raw = request.form.get("engagement_id")
            try:
                engagement_id = int(engagement_id_raw)
            except (TypeError, ValueError):
                flash("Invalid activity selected for deletion.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            engagement = db.session.get(SalesOpportunityEngagement, engagement_id)
            if not engagement or engagement.opportunity_id != opportunity.id:
                flash("Activity not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

            db.session.delete(engagement)
            removal_label = engagement.subject or OPPORTUNITY_ACTIVITY_LABELS.get(engagement.activity_type, "Activity")
            log_sales_activity(
                "opportunity",
                opportunity.id,
                f"Activity removed: {removal_label}",
                actor=current_user,
            )
            db.session.commit()
            flash("Activity removed.", "success")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    activities = (
        SalesActivity.query
        .filter_by(parent_type="opportunity", parent_id=opportunity.id)
        .order_by(SalesActivity.created_at.desc())
        .all()
    )
    comments = (
        SalesOpportunityComment.query
        .filter_by(opportunity_id=opportunity.id)
        .order_by(SalesOpportunityComment.created_at.desc())
        .all()
    )
    files = (
        SalesOpportunityFile.query
        .filter_by(opportunity_id=opportunity.id)
        .order_by(SalesOpportunityFile.created_at.desc())
        .all()
    )
    open_engagements = (
        SalesOpportunityEngagement.query.filter(
            SalesOpportunityEngagement.opportunity_id == opportunity.id,
            func.lower(func.coalesce(SalesOpportunityEngagement.status, "open")) == "open",
        )
        .order_by(
            case((SalesOpportunityEngagement.scheduled_for.is_(None), 1), else_=0),
            SalesOpportunityEngagement.scheduled_for.asc(),
            SalesOpportunityEngagement.created_at.desc(),
        )
        .all()
    )
    now = datetime.datetime.utcnow()
    for engagement in open_engagements:
        engagement.is_overdue = bool(engagement.scheduled_for and engagement.scheduled_for < now)

    logged_engagements = (
        SalesOpportunityEngagement.query.filter(
            SalesOpportunityEngagement.opportunity_id == opportunity.id,
            func.lower(func.coalesce(SalesOpportunityEngagement.status, "open")) != "open",
        )
        .order_by(
            case((SalesOpportunityEngagement.completed_at.is_(None), 1), else_=0),
            SalesOpportunityEngagement.completed_at.desc(),
            SalesOpportunityEngagement.created_at.desc(),
        )
        .all()
    )
    items = (
        SalesOpportunityItem.query
        .filter_by(opportunity_id=opportunity.id)
        .order_by(SalesOpportunityItem.created_at.desc())
        .all()
    )
    quotation_requests = (
        SalesQuotationRequest.query.options(
            joinedload(SalesQuotationRequest.items).joinedload(SalesQuotationRequestItem.opportunity_item),
            joinedload(SalesQuotationRequest.linked_crf).joinedload(ClientRequirementForm.template),
            joinedload(SalesQuotationRequest.requested_by),
            joinedload(SalesQuotationRequest.files).joinedload(SalesOpportunityFile.uploaded_by),
            joinedload(SalesQuotationRequest.negotiation_logs).joinedload(SalesQuotationNegotiationLog.created_by),
        )
        .filter(SalesQuotationRequest.opportunity_id == opportunity.id)
        .order_by(SalesQuotationRequest.created_at.desc())
        .all()
    )
    client_requirement_forms = (
        ClientRequirementForm.query.filter_by(opportunity_id=opportunity.id)
        .order_by(
            ClientRequirementForm.updated_at.desc(),
            ClientRequirementForm.version.desc(),
        )
        .all()
    )
    available_client_forms = []
    if opportunity.client_id:
        available_client_forms = (
            ClientRequirementForm.query.join(
                SalesOpportunity,
                ClientRequirementForm.opportunity_id == SalesOpportunity.id,
            )
            .filter(SalesOpportunity.client_id == opportunity.client_id)
            .order_by(ClientRequirementForm.updated_at.desc())
            .all()
        )
        available_client_forms = [
            form for form in available_client_forms if form.opportunity_id != opportunity.id
        ]

    quotation_files = (
        SalesOpportunityFile.query.filter(
            SalesOpportunityFile.opportunity_id == opportunity.id,
            or_(
                SalesOpportunityFile.stored_path.ilike("%/quotations/%"),
                SalesOpportunityFile.original_filename.ilike("%quotation%"),
                SalesOpportunityFile.original_filename.ilike("%quote%"),
            ),
        )
        .order_by(SalesOpportunityFile.created_at.desc())
        .all()
    )
    if quotation_files:
        total_versions = len(quotation_files)
        for idx, file in enumerate(quotation_files):
            setattr(file, "computed_version", total_versions - idx)
    can_manage_opportunity_docs = (
        current_user.is_admin
        or opportunity.owner_id is None
        or opportunity.owner_id == current_user.id
    )
    quotation_options = []
    seen_quotation_ids = set()
    for quotation_request in quotation_requests:
        latest_file = quotation_request.files[0] if quotation_request.files else None
        if latest_file and latest_file.id not in seen_quotation_ids:
            quotation_options.append({"file": latest_file, "request": quotation_request})
            seen_quotation_ids.add(latest_file.id)
    for file in quotation_files:
        if file.id in seen_quotation_ids:
            continue
        quotation_options.append({"file": file, "request": None})
        seen_quotation_ids.add(file.id)
    design_task_filters = [
        and_(DesignTask.origin_type == "sales", DesignTask.origin_id == opportunity.id)
    ]
    if opportunity.project_id:
        design_task_filters.append(DesignTask.project_id == opportunity.project_id)
    if opportunity.related_project:
        design_task_filters.append(
            DesignTask.project_name.ilike(f"%{opportunity.related_project}%")
        )
    if opportunity.project and opportunity.project.name:
        design_task_filters.append(
            DesignTask.project_name.ilike(f"%{opportunity.project.name}%")
        )

    design_tasks = (
        DesignTask.query.filter(or_(*design_task_filters))
        .order_by(DesignTask.created_at.desc())
        .all()
    )
    open_design_tasks = [
        task
        for task in design_tasks
        if (task.status or "").lower() in {"new", "in_progress", "waiting_info"}
    ]
    design_projects = Project.query.order_by(Project.name).all()
    design_users = User.query.order_by(User.first_name, User.username).all()
    owners = get_assignable_users_for_module("sales", order_by="name")
    clients = SalesClient.query.order_by(SalesClient.display_name.asc()).all()
    amount_value, amount_source = opportunity.calculated_amount_info

    return render_template(
        "sales/opportunity_detail.html",
        opportunity=opportunity,
        pipeline_key=pipeline_key,
        pipeline_config=pipeline_config,
        stages=stages,
        current_stage_index=current_stage_index,
        owners=owners,
        clients=clients,
        activities=activities,
        comments=comments,
        files=files,
        open_engagements=open_engagements,
        logged_engagements=logged_engagements,
        items=items,
        design_tasks=design_tasks,
        open_design_tasks=open_design_tasks,
        design_projects=design_projects,
        design_users=design_users,
        reminder_options=OPPORTUNITY_REMINDER_OPTIONS,
        activity_outcomes=OPPORTUNITY_ACTIVITY_OUTCOMES,
        lift_types=LIFT_TYPES,
        temperature_choices=SALES_TEMPERATURES,
        pipeline_map=SALES_PIPELINES,
        client_requirement_forms=client_requirement_forms,
        final_crf=opportunity.final_crf if getattr(opportunity, "final_crf_id", None) else None,
        final_quotation_file=opportunity.final_quotation_file if getattr(opportunity, "final_quotation_file_id", None) else None,
        final_crf_options=sorted(
            client_requirement_forms,
            key=lambda form: (
                0 if (form.status or "").lower() == "design_confirmed" else 1,
                -(form.version or 0),
                form.updated_at or datetime.datetime.min,
            ),
        ),
        final_quotation_options=quotation_options,
        linked_ticket=_get_linked_ticket_for_opportunity(opportunity.id),
        available_client_forms=available_client_forms,
        quotation_files=quotation_files,
        quotation_requests=quotation_requests,
        can_manage_opportunity_docs=can_manage_opportunity_docs,
        amount_value=amount_value,
        amount_source=amount_source,
    )


def convert_opportunity_to_project(opportunity: "SalesOpportunity") -> "Project":
    """
    Create or return a linked Project from a SalesOpportunity.

    - If opportunity.project already exists, returns it.
    - Otherwise:
      - Builds a Project using opportunity + items + client details
      - Links project_id on the opportunity
    """
    if opportunity.project is not None:
        project = opportunity.project
    else:
        client_name = None
        if opportunity.client:
            client_name = opportunity.client.display_name or opportunity.client.company_name
        if not client_name:
            client_name = getattr(opportunity, "client_name", None) or opportunity.title

        base_name = (opportunity.related_project or "").strip()
        if not base_name:
            if client_name:
                base_name = f"{opportunity.title} – {client_name}"
            else:
                base_name = opportunity.title

        project = Project(
            name=base_name,
            customer_name=client_name,
        )

        first_item = None
        try:
            if opportunity.items:
                first_item = opportunity.items[0]
        except Exception:
            first_item = None

        if first_item is not None:
            project.lift_type = getattr(first_item, "lift_type", None)
            project.floors = getattr(first_item, "floors", None)
            project.stops = getattr(first_item, "stops", None)
            project.opening_type = getattr(first_item, "opening_type", None)
            project.location = getattr(first_item, "location", None)
            project.structure_type = getattr(first_item, "structure_type", None)
            project.cladding_type = getattr(first_item, "cladding_type", None)
            project.cabin_finish = getattr(first_item, "cabin_finish", None)
            project.door_operation_type = getattr(first_item, "door_operation_type", None)
            project.door_finish = getattr(first_item, "door_finish", None)

        db.session.add(project)
        db.session.flush()

        opportunity.project_id = project.id
        if not opportunity.related_project:
            opportunity.related_project = project.name

    if not project.sales_won_at:
        project.sales_won_at = datetime.datetime.utcnow()
    if current_user and getattr(current_user, "is_authenticated", False):
        project.sales_executive_name = current_user.display_name or current_user.email

    db.session.commit()
    return project


def _project_name_from_item(opportunity: "SalesOpportunity", item: "SalesOpportunityItem", index: int, client_name: Optional[str]) -> str:
    client_label = client_name or getattr(opportunity, "client_name", None) or ""
    type_label = (getattr(item, "lift_type", None) or getattr(item, "details", None) or "Item").strip()
    return f"{client_label} - {opportunity.title} - Item {index} ({type_label})" if client_label else f"{opportunity.title} - Item {index} ({type_label})"


def convert_opportunity_to_projects(opportunity_id, final_crf_id=None, final_quotation_file_id=None):
    """
    Create or return linked Projects from a SalesOpportunity.

    - If an item's project already exists, it is reused.
    - Otherwise, creates one Project per opportunity item.
    - Links the created projects back to the opportunity and items.
    """
    opportunity = (
        opportunity_id
        if isinstance(opportunity_id, SalesOpportunity)
        else db.session.get(SalesOpportunity, opportunity_id)
    )
    if opportunity is None:
        raise ValueError("Opportunity not found for project conversion.")

    client_name = None
    if opportunity.client:
        client_name = opportunity.client.display_name or opportunity.client.company_name
    if not client_name:
        client_name = getattr(opportunity, "client_name", None) or opportunity.title

    created_projects: List[Project] = []
    items = list(opportunity.items or [])

    if not items:
        base_name = (opportunity.related_project or "").strip()
        if not base_name:
            if client_name:
                base_name = f"{opportunity.title} – {client_name}"
            else:
                base_name = opportunity.title
        project = Project(
            name=base_name,
            customer_name=client_name,
            opportunity_id=opportunity.id,
        )
        if not project.sales_won_at:
            project.sales_won_at = datetime.datetime.utcnow()
        if current_user and getattr(current_user, "is_authenticated", False):
            project.sales_executive_name = current_user.display_name or current_user.email
        db.session.add(project)
        db.session.flush()
        created_projects.append(project)
    else:
        for idx, item in enumerate(items, start=1):
            project = item.project
            if project is None:
                project_name = _project_name_from_item(opportunity, item, idx, client_name)
                project = Project(
                    name=project_name,
                    customer_name=client_name,
                    lift_type=getattr(item, "lift_type", None),
                    floors=getattr(item, "floors", None),
                    stops=getattr(item, "stops", None),
                    opening_type=getattr(item, "opening_type", None),
                    location=getattr(item, "location", None),
                    structure_type=getattr(item, "structure_type", None),
                    cladding_type=getattr(item, "cladding_type", None),
                    cabin_finish=getattr(item, "cabin_finish", None),
                    door_operation_type=getattr(item, "door_operation_type", None) or getattr(item, "door_type", None),
                    door_finish=getattr(item, "door_finish", None),
                    opportunity_id=opportunity.id,
                )
                db.session.add(project)
                db.session.flush()
                item.project_id = project.id

            if not project.sales_won_at:
                project.sales_won_at = datetime.datetime.utcnow()
            if current_user and getattr(current_user, "is_authenticated", False) and not project.sales_executive_name:
                project.sales_executive_name = current_user.display_name or current_user.email
            if not project.opportunity_id:
                project.opportunity_id = opportunity.id

            created_projects.append(project)

    if created_projects and not opportunity.project_id:
        opportunity.project_id = created_projects[0].id
    if created_projects and not opportunity.related_project:
        opportunity.related_project = created_projects[0].name

    if final_crf_id:
        final_form = db.session.get(ClientRequirementForm, final_crf_id)
        if final_form and not final_form.project_id and created_projects:
            final_form.project_id = created_projects[0].id

    if created_projects and not opportunity.closed_at:
        opportunity.closed_at = datetime.datetime.utcnow()

    db.session.commit()
    return created_projects


def convert_opportunity_to_project(opportunity: "SalesOpportunity") -> Optional["Project"]:
    projects = convert_opportunity_to_projects(opportunity, opportunity.final_crf_id, opportunity.final_quotation_file_id)
    return projects[0] if projects else None


@app.route("/sales/opportunities/<int:opportunity_id>/convert-to-project", methods=["POST"])
@login_required
def sales_opportunity_convert_to_project(opportunity_id):
    _module_visibility_required("sales")

    opportunity = SalesOpportunity.query.get_or_404(opportunity_id)

    if (opportunity.stage or "").lower() != "closed won":
        flash("Only Closed Won opportunities can be converted to projects.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    if not current_user.can_view_module("operations"):
        flash("You do not have Operations access to create projects.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    projects = convert_opportunity_to_projects(opportunity, opportunity.final_crf_id, opportunity.final_quotation_file_id)
    if not projects:
        flash("No projects were created. Add items to the opportunity and try again.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    primary_project = projects[0]
    flash(f"Project{'s' if len(projects) > 1 else ''} created/linked successfully.", "success")
    return redirect(url_for("project_detail", project_id=primary_project.id))


@app.route("/sales/opportunities/<int:opportunity_id>/close", methods=["POST"])
@login_required
def sales_opportunity_close(opportunity_id):
    _module_visibility_required("sales")
    opportunity = SalesOpportunity.query.get_or_404(opportunity_id)

    outcome = (request.form.get("closing_outcome") or "").strip().lower()
    if outcome not in {"won", "lost"}:
        flash("Choose whether the opportunity is Closed Won or Closed Lost.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    final_crf_id_raw = request.form.get("final_crf_id") or ""
    final_crf = None
    if final_crf_id_raw:
        try:
            final_crf = ClientRequirementForm.query.filter_by(
                id=int(final_crf_id_raw), opportunity_id=opportunity.id
            ).first()
        except (TypeError, ValueError):
            final_crf = None
        if not final_crf:
            flash("Select a valid Client Requirements Form for this opportunity.", "error")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
    elif outcome == "won":
        flash("Select the final Client Requirements Form before closing as Won.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    if final_crf and (final_crf.status or "").lower() != "design_confirmed":
        flash("The final Client Requirements Form must be confirmed.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    quotation_mode = (request.form.get("final_quotation_mode") or "existing").strip().lower()
    final_quotation_file_id = None

    if quotation_mode == "existing":
        try:
            selected_quote_id = int(request.form.get("final_quotation_file_id") or "0")
        except (TypeError, ValueError):
            selected_quote_id = 0
        if selected_quote_id:
            final_quotation = SalesOpportunityFile.query.filter_by(
                id=selected_quote_id, opportunity_id=opportunity.id
            ).first()
            if not final_quotation:
                flash("Choose a valid quotation uploaded for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
            final_quotation_file_id = final_quotation.id
        else:
            flash("Select a quotation file to close the opportunity.", "error")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))
    elif quotation_mode == "upload":
        uploaded_file = request.files.get("final_quotation_upload")
        if not uploaded_file or not uploaded_file.filename:
            flash("Upload a final quotation file to continue.", "error")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        safe_name = secure_filename(uploaded_file.filename)
        if not safe_name:
            flash("The selected file name is not valid.", "error")
            return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        quote_root = os.path.join(
            app.config["UPLOAD_FOLDER"], "opportunities", str(opportunity.id), "quotations"
        )
        os.makedirs(quote_root, exist_ok=True)

        request_id_raw = (request.form.get("final_quotation_request_id") or "").strip()
        linked_request = None
        if request_id_raw:
            try:
                linked_request = (
                    SalesQuotationRequest.query.filter_by(
                        id=int(request_id_raw), opportunity_id=opportunity.id
                    ).first()
                )
            except (TypeError, ValueError):
                linked_request = None
            if not linked_request:
                flash("Selected quotation request not found for this opportunity.", "error")
                return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

        existing_quotes = (
            SalesOpportunityFile.query.filter(
                SalesOpportunityFile.opportunity_id == opportunity.id,
                or_(
                    SalesOpportunityFile.stored_path.ilike("%/quotations/%"),
                    SalesOpportunityFile.original_filename.ilike("%quotation%"),
                    SalesOpportunityFile.original_filename.ilike("%quote%"),
                ),
            )
            .order_by(SalesOpportunityFile.created_at.desc())
            .all()
        )
        next_version = len(existing_quotes) + 1

        unique_name = f"{uuid.uuid4().hex}_{safe_name}"
        destination_path = os.path.join(quote_root, unique_name)
        uploaded_file.save(destination_path)

        static_root = os.path.join(BASE_DIR, "static")
        stored_relative = os.path.relpath(destination_path, static_root).replace(os.sep, "/")
        versioned_name = f"Quotation V{next_version} – {uploaded_file.filename}"

        record = SalesOpportunityFile(
            opportunity=opportunity,
            quotation_request=linked_request,
            original_filename=versioned_name,
            stored_path=stored_relative,
            content_type=uploaded_file.mimetype,
            file_size=os.path.getsize(destination_path),
            uploaded_by=current_user if current_user.is_authenticated else None,
        )
        db.session.add(record)
        db.session.flush()
        final_quotation_file_id = record.id
        log_sales_activity(
            "opportunity",
            opportunity.id,
            f"Quotation uploaded (V{next_version})",
            notes=uploaded_file.filename,
            actor=current_user,
        )
    else:
        flash("Choose how to attach the final quotation.", "error")
        return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))

    lost_reason = (request.form.get("lost_reason") or "").strip() or None
    close_ticket_flag = request.form.get("close_linked_ticket") == "1"
    ticket_close_notes = (request.form.get("ticket_close_notes") or lost_reason or "").strip()
    create_projects_flag = request.form.get("create_projects_per_item") == "1"
    now = datetime.datetime.utcnow()

    opportunity.final_crf_id = final_crf.id if final_crf else None
    opportunity.final_quotation_file_id = final_quotation_file_id
    opportunity.closed_status = outcome
    opportunity.closed_at = now
    opportunity.closed_reason = lost_reason if outcome == "lost" else None
    opportunity.stage = "Closed Won" if outcome == "won" else "Closed Lost"
    opportunity.status = "Closed"

    db.session.flush()

    projects = []
    if outcome == "won" and create_projects_flag:
        projects = convert_opportunity_to_projects(
            opportunity, opportunity.final_crf_id, opportunity.final_quotation_file_id
        )
    else:
        db.session.commit()

    notes = []
    if final_quotation_file_id:
        notes.append(f"Final quotation file #{final_quotation_file_id}")
    if final_crf:
        notes.append(f"Final CRF v{final_crf.version}")
    log_sales_activity(
        "opportunity",
        opportunity.id,
        f"Opportunity marked Closed {'Won' if outcome == 'won' else 'Lost'}",
        notes="; ".join(notes) if notes else None,
        actor=current_user,
    )
    db.session.commit()

    linked_ticket = _get_linked_ticket_for_opportunity(opportunity.id)
    ticket_closed = False
    if linked_ticket and close_ticket_flag:
        if _ticket_has_open_linked_tasks(linked_ticket):
            flash("Linked ticket still has open tasks and was not closed.", "warning")
        else:
            linked_ticket["status"] = "Closed"
            linked_ticket["updated_at"] = now
            actor_info = timeline_actor_context()
            detail_parts = [
                f"Opportunity {opportunity.title} closed as {'Won' if outcome == 'won' else 'Lost'}."
            ]
            if ticket_close_notes:
                detail_parts.append(ticket_close_notes)
            linked_ticket.setdefault("timeline", []).append(
                {
                    "timestamp": now,
                    "type": "status",
                    "label": "Linked sales opportunity closed",
                    "visibility": "internal",
                    "detail": " ".join(detail_parts),
                    **actor_info,
                }
            )
            _save_customer_support_state()
            ticket_closed = True

    if projects:
        flash(
            f"Opportunity closed as {'Won' if outcome == 'won' else 'Lost'}. "
            f"Created {len(projects)} project(s){' and closed linked ticket' if ticket_closed else ''}.",
            "success",
        )
    else:
        flash(
            f"Opportunity closed as {'Won' if outcome == 'won' else 'Lost'}"
            f"{' and linked ticket closed.' if ticket_closed else '.'}",
            "success",
        )
    return redirect(url_for("sales_opportunity_detail", opportunity_id=opportunity.id))


def _missing_confirmed_client_requirement_forms(opportunity: SalesOpportunity):
    """Return list of lift labels missing a confirmed CRF."""

    if not opportunity or not getattr(opportunity, "items", None):
        return []
    try:
        if opportunity.final_crf_id:
            final_form = db.session.get(ClientRequirementForm, opportunity.final_crf_id)
            if final_form and (final_form.status or "").lower() == "design_confirmed":
                return []
    except Exception:
        pass

    confirmed_crfs = (
        ClientRequirementForm.query.filter_by(
            opportunity_id=opportunity.id, status="design_confirmed"
        )
        .all()
    )
    confirmed_by_lift = {form.lift_id for form in confirmed_crfs if form.lift_id}
    has_unassigned_confirmed = any(form.lift_id is None for form in confirmed_crfs)
    total_lifts = len(opportunity.items)

    missing_labels = []
    for idx, lift in enumerate(opportunity.items, start=1):
        if lift.id in confirmed_by_lift:
            continue
        if total_lifts == 1 and has_unassigned_confirmed:
            continue

        label = getattr(lift, "details", None) or getattr(lift, "lift_type", None)
        if not label:
            label = f"Lift {idx}"
        missing_labels.append(label)

    return missing_labels


@app.route("/sales/opportunities/<int:opportunity_id>/stage", methods=["POST"])
@login_required
def sales_opportunity_stage(opportunity_id):
    _module_visibility_required("sales")
    opportunity = db.session.get(SalesOpportunity, opportunity_id)
    accepts = request.accept_mimetypes.best
    wants_json = request.headers.get("X-Requested-With") == "XMLHttpRequest" or accepts == "application/json"
    if not opportunity:
        if wants_json:
            return jsonify({"success": False, "message": "Opportunity not found."}), 404
        flash("Opportunity not found.", "error")
        return redirect(url_for("sales_opportunities_pipeline", pipeline_key="lift"))

    pipeline_key = opportunity.pipeline
    stage = (request.form.get("stage") or "").strip()
    stages = get_pipeline_stages(pipeline_key)
    if stage not in stages:
        if wants_json:
            return jsonify({"success": False, "message": "Invalid stage selected."}), 400
        flash("Invalid stage selected.", "error")
        return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

    normalized_stage = (stage or "").strip().lower()
    closing_won = normalized_stage == "closed won"
    closing_lost = normalized_stage == "closed lost"
    if normalized_stage in {"quote submission", "closed won"}:
        missing_lifts = _missing_confirmed_client_requirement_forms(opportunity)
        if missing_lifts:
            stage_label = "Quote Submission" if normalized_stage == "quote submission" else "Closed Won"
            missing_text = ", ".join(missing_lifts)
            message = (
                f"Cannot move to {stage_label}. The following lifts are missing a confirmed "
                f"Client Requirements Form: {missing_text}."
            )
            if wants_json:
                return jsonify({"success": False, "message": message}), 400
            flash(message, "error")
            return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))
        if closing_won and not opportunity.final_crf_id:
            message = "Select a final Client Requirements Form using Close Opportunity before marking Closed Won."
            if wants_json:
                return jsonify({"success": False, "message": message}), 400
            flash(message, "error")
            return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

    if closing_won or closing_lost:
        if not opportunity.final_quotation_file_id:
            message = "Choose a final quotation before closing this opportunity."
            if wants_json:
                return jsonify({"success": False, "message": message}), 400
            flash(message, "error")
            return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

    opportunity.stage = stage
    log_sales_activity("opportunity", opportunity.id, f"Stage moved to {stage}", actor=current_user)
    if closing_won or closing_lost:
        opportunity.closed_status = "won" if closing_won else "lost"
        if not opportunity.closed_at:
            opportunity.closed_at = datetime.datetime.utcnow()
    else:
        opportunity.closed_status = None
        opportunity.closed_at = None
    db.session.commit()

    conversion_url = None
    if closing_won and not opportunity.project_id and current_user.can_view_module("operations"):
        conversion_url = url_for("sales_opportunity_convert_to_project", opportunity_id=opportunity.id)
        if not wants_json:
            flash(
                "Stage moved to Closed Won. Convert this opportunity into a project.",
                "info",
            )

    response_payload = {
        "success": True,
        "stage": stage,
        "pipeline": pipeline_key,
        "has_project": bool(opportunity.project_id),
    }
    if conversion_url:
        response_payload["convert_url"] = conversion_url

    if wants_json:
        return jsonify(response_payload)

    flash("Opportunity stage updated.", "success")
    return redirect(url_for("sales_opportunities_pipeline", pipeline_key=pipeline_key))

def _require_admin():
    if not current_user.is_admin:
        abort(403)


def _load_ui_utility_classes():
    base_template_path = os.path.join(BASE_DIR, "templates", "base.html")
    try:
        with open(base_template_path, "r", encoding="utf-8") as handle:
            css_source = handle.read()
    except OSError:
        return set()
    class_pattern = re.compile(
        r"\\.(text|bg|border)-(slate|gray|zinc|neutral)-(\\d{2,3})\\b"
    )
    return {
        f"{prefix}-{palette}-{shade}"
        for prefix, palette, shade in class_pattern.findall(css_source)
    }


def _form_truthy(value):
    if value is None:
        return False
    return str(value).strip().lower() in {"1", "true", "on", "yes"}


def _department_cycle(department, candidate_parent):
    current = candidate_parent
    while current is not None:
        if current.id == department.id:
            return True
        current = current.parent
    return False


def _position_cycle(position, candidate_manager):
    current = candidate_manager
    while current is not None:
        if current.id == position.id:
            return True
        current = current.reports_to
    return False


def _normalize_header(value):
    return (value or "").strip().lower()


def _column_index(header, *candidates):
    mapping = {_normalize_header(col): idx for idx, col in enumerate(header or []) if col is not None}
    for candidate in candidates:
        key = _normalize_header(candidate)
        if key in mapping:
            return mapping[key]
    return None


def _org_upload_template(kind: str):
    _ensure_openpyxl()

    workbook = Workbook()
    sheet = workbook.active

    if kind == "departments":
        sheet.title = "Departments"
        sheet.append(["Name", "Branch", "Description", "Parent", "Active (Yes/No)"])
        existing = (
            Department.query.options(joinedload(Department.parent))
            .order_by(Department.name.asc())
            .all()
        )
        for dept in existing:
            sheet.append(
                [
                    dept.name,
                    dept.branch,
                    dept.description or "",
                    dept.parent.name if dept.parent else "",
                    "Yes" if dept.active else "No",
                ]
            )
    else:
        sheet.title = "Positions"
        sheet.append(["Title", "Department", "Reports To", "Active (Yes/No)"])
        existing = (
            Position.query.options(joinedload(Position.department), joinedload(Position.reports_to))
            .order_by(Position.title.asc())
            .all()
        )
        for pos in existing:
            sheet.append(
                [
                    pos.title,
                    pos.department.name if pos.department else "",
                    pos.reports_to.title if pos.reports_to else "",
                    "Yes" if pos.active else "No",
                ]
            )

    # Improve readability
    header_font = Font(bold=True)
    for cell in sheet[1]:
        cell.font = header_font
        cell.alignment = Alignment(horizontal="center")

    stream = BytesIO()
    workbook.save(stream)
    stream.seek(0)
    return send_file(
        stream,
        mimetype=(
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        ),
        as_attachment=True,
        download_name=f"{kind}_upload_template.xlsx",
    )


# ---------------------- ADMINISTRATION ----------------------
def _admin_users_context(create_defaults=None, show_create=False):
    admin_settings = _load_admin_settings()
    departments = sorted(
        Department.query.options(joinedload(Department.parent)).order_by(Department.name.asc()).all(),
        key=lambda d: (d.full_name or "").lower(),
    )
    positions = sorted(
        Position.query.options(joinedload(Position.department)).order_by(Position.title.asc()).all(),
        key=lambda p: (p.display_label or "").lower(),
    )
    defaults = dict(create_defaults or {})
    defaults.setdefault("active", "1")

    return dict(
        users=User.query.order_by(User.username.asc()).all(),
        departments=departments,
        department_options=departments,
        department_branches=DEPARTMENT_BRANCHES,
        positions=positions,
        position_options=positions,
        category_label="Admin",
        category_url=url_for("admin_users"),
        create_user_defaults=defaults,
        show_create_user_form=show_create,
        admin_settings=admin_settings,
    )


@app.route("/admin/users")
@login_required
def admin_users():
    _require_admin()

    return render_template("admin_users.html", **_admin_users_context())


@app.route("/admin/ui_audit")
@login_required
def admin_ui_audit():
    _require_admin()
    template_root = os.path.join(BASE_DIR, "templates")
    class_pattern = re.compile(
        r"\\b(text|bg|border)-(slate|gray|zinc|neutral)-(\\d{2,3})\\b"
    )
    supported_classes = _load_ui_utility_classes()
    report_rows = []

    for root, _, files in os.walk(template_root):
        for filename in sorted(file for file in files if file.endswith(".html")):
            path = os.path.join(root, filename)
            try:
                with open(path, "r", encoding="utf-8") as handle:
                    content = handle.read()
            except OSError:
                continue
            matches = {
                f"{prefix}-{palette}-{shade}"
                for prefix, palette, shade in class_pattern.findall(content)
            }
            if not matches:
                continue
            unsupported = sorted(match for match in matches if match not in supported_classes)
            report_rows.append(
                {
                    "template": os.path.relpath(path, template_root),
                    "classes": sorted(matches),
                    "unsupported": unsupported,
                }
            )

    html_rows = []
    for row in report_rows:
        unsupported_markup = (
            "None"
            if not row["unsupported"]
            else ", ".join(
                f"<span class=\"bad\">{html.escape(item)}</span>"
                for item in row["unsupported"]
            )
        )
        html_rows.append(
            "<tr>"
            f"<td>{html.escape(row['template'])}</td>"
            f"<td>{', '.join(html.escape(item) for item in row['classes'])}</td>"
            f"<td>{unsupported_markup}</td>"
            "</tr>"
        )

    table_body = "\n".join(html_rows) if html_rows else "<tr><td colspan=\"3\">No matching utility classes found.</td></tr>"
    return (
        "<!doctype html>"
        "<html lang=\"en\">"
        "<head>"
        "<meta charset=\"utf-8\">"
        "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
        "<title>UI Utility Audit</title>"
        "<style>"
        "body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;"
        "background:#0f172a;color:#e2e8f0;margin:0;padding:24px;}"
        "h1{font-size:20px;margin-bottom:16px;}"
        "table{width:100%;border-collapse:collapse;font-size:14px;}"
        "th,td{border:1px solid rgba(148,163,184,0.3);padding:10px;vertical-align:top;}"
        "th{background:rgba(15,23,42,0.8);text-align:left;}"
        "tr:nth-child(even){background:rgba(15,23,42,0.5);}"
        ".bad{color:#fca5a5;font-weight:600;}"
        "</style>"
        "</head>"
        "<body>"
        "<h1>UI Utility Audit</h1>"
        "<table>"
        "<thead><tr><th>Template</th><th>Utility Classes Found</th><th>Unsupported</th></tr></thead>"
        "<tbody>"
        f"{table_body}"
        "</tbody>"
        "</table>"
        "</body>"
        "</html>"
    )


@app.route("/admin/departments/template")
@login_required
def admin_departments_template():
    _require_admin()
    try:
        return _org_upload_template("departments")
    except MissingDependencyError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#departments")


@app.route("/admin/positions/template")
@login_required
def admin_positions_template():
    _require_admin()
    try:
        return _org_upload_template("positions")
    except MissingDependencyError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#positions")


@app.route("/admin/users/create", methods=["POST"])
@login_required
def admin_users_create():
    _require_admin()

    username = (request.form.get("username") or "").strip()
    password = (request.form.get("password") or "").strip()
    first_name = (request.form.get("first_name") or "").strip()
    last_name = (request.form.get("last_name") or "").strip()
    email = (request.form.get("email") or "").strip()
    mobile_number = (request.form.get("mobile_number") or "").strip()
    department_id_raw = request.form.get("department_id")
    position_id_raw = request.form.get("position_id")
    active_flag = _form_truthy(request.form.get("active", "1"))

    if not username or not password:
        flash("Username and password are required to create a user.", "error")
        create_defaults = request.form.to_dict(flat=True)
        if "active" not in create_defaults:
            create_defaults["active"] = ""
        return render_template(
            "admin_users.html",
            **_admin_users_context(
                create_defaults=create_defaults,
                show_create=True,
            ),
        )

    existing = (
        User.query.filter(func.lower(User.username) == username.lower()).first()
        if username
        else None
    )
    if existing:
        flash("A user with that username already exists.", "error")
        create_defaults = request.form.to_dict(flat=True)
        if "active" not in create_defaults:
            create_defaults["active"] = ""
        return render_template(
            "admin_users.html",
            **_admin_users_context(
                create_defaults=create_defaults,
                show_create=True,
            ),
        )

    department = None
    if department_id_raw:
        try:
            department = db.session.get(Department, int(department_id_raw))
        except (TypeError, ValueError):
            department = None

    position = None
    if position_id_raw:
        try:
            position = db.session.get(Position, int(position_id_raw))
        except (TypeError, ValueError):
            position = None

    user = User(
        username=username,
        first_name=first_name or None,
        last_name=last_name or None,
        email=email or None,
        mobile_number=mobile_number or None,
        department=department.name if department else None,
        active=active_flag,
    )
    user.set_password(password)
    user.set_module_permissions(
        {
            module["key"]: {
                "visibility": False,
                "assignment": False,
            }
            for module in WORKSPACE_MODULES
        }
    )
    if position:
        user.position = position
        if not user.department and position.department:
            user.department = position.department.name

    user.issue_session_token()
    db.session.add(user)
    db.session.commit()

    flash(f"User '{username}' created successfully.", "success")
    return redirect(url_for("admin_users") + f"#user-{user.id}")


@app.route("/admin/users/<int:user_id>/update", methods=["POST"])
@login_required
def admin_users_update(user_id):
    _require_admin()

    user = db.session.get(User, user_id)
    if not user:
        flash("User not found.", "error")
        return redirect(url_for("admin_users"))

    action = request.form.get("action") or "update"
    if action == "reset_sessions":
        user.issue_session_token()
        db.session.commit()
        flash(f"All active sessions for '{user.username}' have been revoked.", "success")
        if user.id == current_user.id:
            session.pop("session_token", None)
            logout_user()
            flash("You signed yourself out of all sessions.", "info")
            return redirect(url_for("login"))
        return redirect(url_for("admin_users") + f"#user-{user.id}")

    username = (request.form.get("username") or "").strip()
    first_name = (request.form.get("first_name") or "").strip()
    last_name = (request.form.get("last_name") or "").strip()
    email = (request.form.get("email") or "").strip()
    mobile_number = (request.form.get("mobile_number") or "").strip()
    department_id_raw = request.form.get("department_id")
    position_id_raw = request.form.get("position_id")
    active_flag = _form_truthy(request.form.get("active"))
    password = (request.form.get("password") or "").strip()

    if not username:
        flash("Username is required.", "error")
        return redirect(url_for("admin_users") + f"#user-{user.id}")

    if username.lower() != user.username.lower():
        existing = (
            User.query.filter(func.lower(User.username) == username.lower(), User.id != user.id).first()
        )
        if existing:
            flash("Another user already uses that username.", "error")
            return redirect(url_for("admin_users") + f"#user-{user.id}")

    department = None
    if department_id_raw:
        try:
            department = db.session.get(Department, int(department_id_raw))
        except (TypeError, ValueError):
            department = None

    position = None
    if position_id_raw:
        try:
            position = db.session.get(Position, int(position_id_raw))
        except (TypeError, ValueError):
            position = None

    if user.id == current_user.id and not active_flag:
        flash("You cannot deactivate your own account while logged in.", "error")
        return redirect(url_for("admin_users") + f"#user-{user.id}")

    user.username = username
    user.first_name = first_name or None
    user.last_name = last_name or None
    user.email = email or None
    user.mobile_number = mobile_number or None
    user.department = department.name if department else None
    user.active = active_flag
    user.position = position
    if not user.department and position and position.department:
        user.department = position.department.name

    if password:
        user.set_password(password)

    permissions_payload = {}
    for module in WORKSPACE_MODULES:
        module_key = module["key"]
        visibility_flag = _form_truthy(request.form.get(f"module_{module_key}_visibility"))
        assignment_flag = _form_truthy(request.form.get(f"module_{module_key}_assignment"))
        permissions_payload[module_key] = {
            "visibility": visibility_flag,
            "assignment": assignment_flag,
        }
    user.set_module_permissions(permissions_payload)

    db.session.commit()
    flash(f"User '{user.username}' updated.", "success")
    return redirect(url_for("admin_users") + "#users")


@app.post("/admin/users/<int:user_id>/toggle-service-manager")
@login_required
def admin_user_toggle_service_manager(user_id: int):
    _require_admin()

    user = User.query.get_or_404(user_id)
    is_checked = request.form.get("is_service_manager") == "1"
    user.is_service_manager = is_checked
    db.session.commit()
    flash("Service I/C flag updated.", "success")
    return redirect(url_for("admin_users"))


@app.route("/admin/departments/create", methods=["POST"])
@login_required
def admin_departments_create():
    _require_admin()

    name = (request.form.get("name") or "").strip()
    branch = (request.form.get("branch") or "").strip()
    description = (request.form.get("description") or "").strip()
    parent_id_raw = request.form.get("parent_id")
    active_flag = _form_truthy(request.form.get("active", "1"))

    if not name:
        flash("Department name is required.", "error")
        return redirect(url_for("admin_users") + "#departments")

    if branch not in DEPARTMENT_BRANCHES:
        branch = DEPARTMENT_BRANCHES[0]

    existing = Department.query.filter(func.lower(Department.name) == name.lower()).first()
    if existing:
        flash("A department with that name already exists.", "error")
        return redirect(url_for("admin_users") + "#departments")

    parent = None
    if parent_id_raw:
        try:
            parent = db.session.get(Department, int(parent_id_raw))
        except (TypeError, ValueError):
            parent = None

    department = Department(
        name=name,
        branch=branch,
        description=description or None,
        active=active_flag,
    )
    if parent:
        department.parent = parent

    db.session.add(department)
    db.session.commit()
    backup_org_structure()

    flash(f"Department '{department.full_name}' created.", "success")
    return redirect(url_for("admin_users") + f"#department-{department.id}")


@app.route("/admin/departments/<int:department_id>/update", methods=["POST"])
@login_required
def admin_departments_update(department_id):
    _require_admin()

    department = db.session.get(Department, department_id)
    if not department:
        flash("Department not found.", "error")
        return redirect(url_for("admin_users") + "#departments")

    name = (request.form.get("name") or "").strip()
    branch = (request.form.get("branch") or "").strip()
    description = (request.form.get("description") or "").strip()
    parent_id_raw = request.form.get("parent_id")
    active_flag = _form_truthy(request.form.get("active"))

    if not name:
        flash("Department name is required.", "error")
        return redirect(url_for("admin_users") + f"#department-{department.id}")

    if branch not in DEPARTMENT_BRANCHES:
        branch = DEPARTMENT_BRANCHES[0]

    if name.lower() != department.name.lower():
        existing = Department.query.filter(
            func.lower(Department.name) == name.lower(),
            Department.id != department.id,
        ).first()
        if existing:
            flash("Another department already uses that name.", "error")
            return redirect(url_for("admin_users") + f"#department-{department.id}")

    parent = None
    if parent_id_raw:
        try:
            parent = db.session.get(Department, int(parent_id_raw))
        except (TypeError, ValueError):
            parent = None
    if parent and _department_cycle(department, parent):
        flash("Cannot assign a department to one of its descendants.", "error")
        return redirect(url_for("admin_users") + f"#department-{department.id}")

    department.name = name
    department.branch = branch
    department.description = description or None
    department.active = active_flag
    department.parent = parent

    db.session.commit()
    backup_org_structure()
    flash(f"Department '{department.full_name}' updated.", "success")
    return redirect(url_for("admin_users") + f"#department-{department.id}")


@app.route("/admin/departments/<int:department_id>/delete", methods=["POST"])
@login_required
def admin_departments_delete(department_id):
    _require_admin()

    department = db.session.get(Department, department_id)
    if not department:
        flash("Department not found.", "error")
        return redirect(url_for("admin_users") + "#departments")

    for child in list(department.children or []):
        child.parent = None
    for position in list(department.positions or []):
        position.department = None

    db.session.delete(department)
    db.session.commit()
    backup_org_structure()

    flash(f"Department '{department.name}' deleted.", "success")
    return redirect(url_for("admin_users") + "#departments")


@app.route("/admin/departments/upload", methods=["POST"])
@login_required
def admin_departments_upload():
    _require_admin()

    upload = request.files.get("upload")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#departments")

    try:
        header, rows = _extract_tabular_upload(upload)
    except MissingDependencyError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#departments")
    except Exception as exc:  # pragma: no cover - defensive guard
        flash(f"Could not read the uploaded file: {exc}", "error")
        return redirect(url_for("admin_users") + "#departments")

    name_idx = _column_index(header, "name", "department", "department name")
    if name_idx is None:
        flash("The upload must include a 'Name' column for departments.", "error")
        return redirect(url_for("admin_users") + "#departments")

    branch_idx = _column_index(header, "branch")
    description_idx = _column_index(header, "description")
    parent_idx = _column_index(header, "parent")
    active_idx = _column_index(header, "active", "active (yes/no)")

    created, skipped = 0, []
    seen_names = set()
    for row_number, row in enumerate(rows, start=2):
        cells = list(row or [])
        name_value = cells[name_idx] if len(cells) > name_idx else None
        name = str(name_value).strip() if name_value is not None else ""
        if not name:
            continue

        key = name.lower()
        if key in seen_names:
            skipped.append(name)
            continue

        existing = Department.query.filter(func.lower(Department.name) == key).first()
        if existing:
            skipped.append(name)
            continue

        seen_names.add(key)

        branch_value = cells[branch_idx] if branch_idx is not None and len(cells) > branch_idx else None
        branch = str(branch_value).strip() if branch_value else DEPARTMENT_BRANCHES[0]
        if branch not in DEPARTMENT_BRANCHES:
            branch = DEPARTMENT_BRANCHES[0]

        description_value = cells[description_idx] if description_idx is not None and len(cells) > description_idx else None
        description = str(description_value).strip() if description_value else None

        parent_value = cells[parent_idx] if parent_idx is not None and len(cells) > parent_idx else None
        parent_name = str(parent_value).strip() if parent_value else None
        parent = (
            Department.query.filter(func.lower(Department.name) == parent_name.lower()).first()
            if parent_name
            else None
        )

        active_flag = (
            _parse_boolean_cell(cells[active_idx])
            if active_idx is not None and len(cells) > active_idx
            else True
        )

        department = Department(
            name=name,
            branch=branch,
            description=description or None,
            active=active_flag,
        )
        if parent:
            department.parent = parent

        db.session.add(department)
        created += 1

    db.session.commit()
    backup_org_structure()
    flash(
        f"Imported {created} departments. {len(skipped)} existing names were skipped.",
        "success",
    )
    return redirect(url_for("admin_users") + "#departments")


@app.route("/admin/positions/create", methods=["POST"])
@login_required
def admin_positions_create():
    _require_admin()

    title = (request.form.get("title") or "").strip()
    department_id_raw = request.form.get("department_id")
    reports_to_id_raw = request.form.get("reports_to_id")
    active_flag = _form_truthy(request.form.get("active", "1"))

    if not title:
        flash("Position title is required.", "error")
        return redirect(url_for("admin_users") + "#positions")

    department = None
    if department_id_raw:
        try:
            department = db.session.get(Department, int(department_id_raw))
        except (TypeError, ValueError):
            department = None

    manager = None
    if reports_to_id_raw:
        try:
            manager = db.session.get(Position, int(reports_to_id_raw))
        except (TypeError, ValueError):
            manager = None

    position = Position(
        title=title,
        department=department,
        reports_to=manager,
        active=active_flag,
    )
    db.session.add(position)
    db.session.commit()
    backup_org_structure()

    flash(f"Position '{position.display_label}' created.", "success")
    return redirect(url_for("admin_users") + f"#position-{position.id}")


@app.route("/admin/positions/<int:position_id>/update", methods=["POST"])
@login_required
def admin_positions_update(position_id):
    _require_admin()

    position = db.session.get(Position, position_id)
    if not position:
        flash("Position not found.", "error")
        return redirect(url_for("admin_users") + "#positions")

    title = (request.form.get("title") or "").strip()
    department_id_raw = request.form.get("department_id")
    reports_to_id_raw = request.form.get("reports_to_id")
    active_flag = _form_truthy(request.form.get("active"))

    if not title:
        flash("Position title is required.", "error")
        return redirect(url_for("admin_users") + f"#position-{position.id}")

    department = None
    if department_id_raw:
        try:
            department = db.session.get(Department, int(department_id_raw))
        except (TypeError, ValueError):
            department = None

    manager = None
    if reports_to_id_raw:
        try:
            manager = db.session.get(Position, int(reports_to_id_raw))
        except (TypeError, ValueError):
            manager = None

    if manager and _position_cycle(position, manager):
        flash("Cannot assign a position to report to itself or its descendants.", "error")
        return redirect(url_for("admin_users") + f"#position-{position.id}")

    position.title = title
    position.department = department
    position.reports_to = manager
    position.active = active_flag

    db.session.commit()
    backup_org_structure()
    flash(f"Position '{position.display_label}' updated.", "success")
    return redirect(url_for("admin_users") + f"#position-{position.id}")


@app.route("/admin/positions/<int:position_id>/delete", methods=["POST"])
@login_required
def admin_positions_delete(position_id):
    _require_admin()

    position = db.session.get(Position, position_id)
    if not position:
        flash("Position not found.", "error")
        return redirect(url_for("admin_users") + "#positions")

    for report in list(position.direct_reports or []):
        report.reports_to = None

    db.session.delete(position)
    db.session.commit()
    backup_org_structure()

    flash(f"Position '{position.title}' deleted.", "success")
    return redirect(url_for("admin_users") + "#positions")


@app.route("/admin/positions/upload", methods=["POST"])
@login_required
def admin_positions_upload():
    _require_admin()

    upload = request.files.get("upload")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#positions")

    try:
        header, rows = _extract_tabular_upload(upload)
    except MissingDependencyError as exc:
        flash(str(exc), "error")
        return redirect(url_for("admin_users") + "#positions")
    except Exception as exc:  # pragma: no cover - defensive guard
        flash(f"Could not read the uploaded file: {exc}", "error")
        return redirect(url_for("admin_users") + "#positions")

    title_idx = _column_index(header, "title", "position", "position title")
    if title_idx is None:
        flash("The upload must include a 'Title' column for positions.", "error")
        return redirect(url_for("admin_users") + "#positions")

    department_idx = _column_index(header, "department")
    manager_idx = _column_index(header, "reports to", "reports_to", "manager")
    active_idx = _column_index(header, "active", "active (yes/no)")

    existing_positions = {}
    title_lookup = {}
    for pos in Position.query.options(joinedload(Position.department)).all():
        title_key = (pos.title or "").strip().lower()
        dept_key = (pos.department.name.strip().lower() if pos.department and pos.department.name else None)
        existing_positions[(title_key, dept_key)] = pos
        title_lookup.setdefault(title_key, pos)
    manager_refs = {}
    created, skipped = 0, []

    for row in rows:
        cells = list(row or [])
        title_value = cells[title_idx] if len(cells) > title_idx else None
        title = str(title_value).strip() if title_value is not None else ""
        if not title:
            continue

        department_value = cells[department_idx] if department_idx is not None and len(cells) > department_idx else None
        department_name = str(department_value).strip() if department_value else None
        department = None
        dept_key = None
        if department_name:
            department = Department.query.filter(func.lower(Department.name) == department_name.lower()).first()
            dept_key = (department.name.strip().lower() if department and department.name else department_name.lower())

        key = (title.lower(), dept_key)
        if key in existing_positions:
            skipped.append(title)
            continue

        manager_value = cells[manager_idx] if manager_idx is not None and len(cells) > manager_idx else None
        manager_name = str(manager_value).strip() if manager_value else None

        active_flag = (
            _parse_boolean_cell(cells[active_idx])
            if active_idx is not None and len(cells) > active_idx
            else True
        )

        position = Position(title=title, department=department, active=active_flag)
        db.session.add(position)
        db.session.flush()

        existing_positions[key] = position
        title_lookup.setdefault(title.lower(), position)
        if manager_name:
            manager_refs[key] = {"manager": manager_name.lower(), "dept_key": dept_key}

        created += 1

    for key, manager_info in manager_refs.items():
        position = existing_positions.get(key)
        manager_key = manager_info.get("manager") if isinstance(manager_info, dict) else manager_info
        dept_key = manager_info.get("dept_key") if isinstance(manager_info, dict) else None
        manager = existing_positions.get((manager_key, dept_key)) or title_lookup.get(manager_key)
        if position and manager and not _position_cycle(position, manager):
            position.reports_to = manager

    db.session.commit()
    backup_org_structure()
    flash(
        f"Imported {created} positions. {len(skipped)} existing titles were skipped.",
        "success",
    )
    return redirect(url_for("admin_users") + "#positions")


def _build_task_overview(viewing_user: "User"):
    def _describe_due_date(target_date, now):
        if not target_date:
            return None, None, "none"
        if isinstance(target_date, datetime.date) and not isinstance(target_date, datetime.datetime):
            target_dt = datetime.datetime.combine(target_date, datetime.time.min)
        else:
            target_dt = target_date
        delta_days = (target_dt.date() - now.date()).days
        display = target_dt.strftime("%d %b %Y")
        if delta_days < 0:
            days = abs(delta_days)
            label = f"Overdue by {days} day{'s' if days != 1 else ''}"
            variant = "overdue"
        elif delta_days == 0:
            label = "Due today"
            variant = "today"
        elif delta_days == 1:
            label = "Due tomorrow"
            variant = "upcoming"
        else:
            label = f"Due in {delta_days} days"
            variant = "upcoming"
        return label, display, variant

    def _status_badge_class(key):
        mapping = {
            "open": "bg-amber-500/20 text-amber-100 border border-amber-500/40",
            "in_progress": "bg-sky-500/20 text-sky-100 border border-sky-500/40",
            "blocked": "bg-rose-500/20 text-rose-100 border border-rose-500/40",
            "scheduled": "bg-sky-500/20 text-sky-100 border border-sky-500/40",
            "overdue": "bg-rose-500/20 text-rose-100 border border-rose-500/40",
        }
        return mapping.get(key, "bg-slate-800/60 text-slate-200 border border-slate-700/60")

    def _due_badge_class(variant):
        mapping = {
            "overdue": "bg-rose-500/20 text-rose-100 border border-rose-500/40",
            "today": "bg-amber-500/20 text-amber-100 border border-amber-500/40",
            "upcoming": "bg-slate-800/60 text-slate-200 border border-slate-700/60",
        }
        return mapping.get(variant, "bg-slate-800/60 text-slate-200 border border-slate-700/60")

    def _ensure_module(modules_map, order, label, empty_message, description=None):
        module = modules_map.get(label)
        if module is None:
            module = {
                "module": label,
                "items": [],
                "empty_message": empty_message,
                "description": description,
            }
            modules_map[label] = module
            order.append(label)
        else:
            if description and not module.get("description"):
                module["description"] = description
        return module

    def _status_key(status):
        key = (status or "").strip().lower()
        if key == "in progress":
            return "in_progress"
        if key == "blocked":
            return "blocked"
        if key == "closed":
            return "closed"
        if key == "overdue":
            return "overdue"
        if key == "scheduled":
            return "scheduled"
        return "open"

    def _pending_support_tickets_for_users(user_ids, *, include_other_department=False):
        if not user_ids:
            return []

        allowed_ids = {uid for uid in user_ids if uid}
        allowed_users = {
            user.id: user
            for user in User.query.filter(User.id.in_(allowed_ids)).all()
            if user and user.is_active
        }
        allowed_display_names = {
            (user.display_name or "").strip().lower(): user
            for user in allowed_users.values()
            if (user.display_name or "").strip()
        }
        allowed_usernames = {
            (user.username or "").strip().lower(): user
            for user in allowed_users.values()
            if (user.username or "").strip()
        }

        pending_tickets = []
        for ticket in CUSTOMER_SUPPORT_TICKETS:
            if _ticket_is_other_department(ticket) and not include_other_department:
                continue
            status_value = (ticket.get("status") or "").strip().lower()
            if status_value in {"resolved", "closed"}:
                continue

            # Always resolve the assignee without enforcing module assignment
            # permissions so that tickets remain visible to the person they were
            # assigned to, even if their permissions have been restricted.
            assignee_user = _resolve_ticket_assignee_user(ticket, module_key=None)
            if assignee_user and assignee_user.id in allowed_ids and assignee_user.is_active:
                pending_tickets.append(ticket)
                continue

            assignee_name = (ticket.get("assignee") or "").strip().lower()
            if not assignee_user and assignee_name:
                matched_user = (
                    allowed_display_names.get(assignee_name)
                    or allowed_usernames.get(assignee_name)
                )
                if matched_user:
                    ticket.setdefault("assignee_user_id", matched_user.id)
                    if not ticket.get("assignee"):
                        ticket["assignee"] = matched_user.display_name
                    pending_tickets.append(ticket)

        return pending_tickets

    def _build_pending_modules(
        viewing_user,
        open_tasks,
        now,
        assignee_lookup=None,
        sales_user_ids=None,
        support_tickets=None,
        *,
        sales_filter_mode="owner_or_creator",
        module_visibility_override=None,
        include_sales_tasks=True,
    ):
        modules_map = OrderedDict()
        module_order = []
        pending_total = 0

        module_visibility_override = module_visibility_override or {}

        has_project_tasks = any(task.project for task in open_tasks)
        has_qc_tasks = any(not task.project for task in open_tasks)

        sales_filters = []
        sales_user_id_set = set()
        if sales_user_ids is None:
            if viewing_user:
                sales_user_id_set = {viewing_user.id}
        else:
            allowed_ids = {uid for uid in set(sales_user_ids) if uid}
            if allowed_ids:
                sales_user_id_set = allowed_ids

        if sales_user_id_set:
            sales_filter_mode = (sales_filter_mode or "owner_or_creator").strip().lower()
            if sales_filter_mode == "owner_only":
                sales_filters = [SalesOpportunity.owner_id.in_(sales_user_id_set)]
            elif sales_filter_mode == "creator_only":
                sales_filters = [SalesOpportunityEngagement.created_by_id.in_(sales_user_id_set)]
            else:
                sales_filters = [
                    SalesOpportunity.owner_id.in_(sales_user_id_set),
                    SalesOpportunityEngagement.created_by_id.in_(sales_user_id_set),
                ]

        task_owner_ids = set()
        if assignee_lookup:
            task_owner_ids = {uid for uid in assignee_lookup.keys() if uid}
        elif viewing_user and getattr(viewing_user, "id", None):
            task_owner_ids = {viewing_user.id}
        sales_items = []
        if sales_filters:
            sales_items = (
                SalesOpportunityEngagement.query
                .join(SalesOpportunity, SalesOpportunity.id == SalesOpportunityEngagement.opportunity_id)
                .filter(SalesOpportunityEngagement.scheduled_for.isnot(None))
                .filter(or_(*sales_filters))
                .filter(func.lower(SalesOpportunity.status) != "closed")
                .order_by(
                    SalesOpportunityEngagement.scheduled_for.asc(),
                    SalesOpportunityEngagement.id.asc(),
                )
                .limit(50)
                .all()
            )

        sales_tasks = []
        if include_sales_tasks and task_owner_ids:
            sales_tasks = (
                SalesTask.query
                .options(
                    joinedload(SalesTask.opportunity).joinedload(SalesOpportunity.client),
                    joinedload(SalesTask.client),
                    joinedload(SalesTask.owner),
                    joinedload(SalesTask.assignees),
                )
                .filter(
                    or_(
                        SalesTask.assignees.any(User.id.in_(task_owner_ids)),
                        and_(
                            ~SalesTask.assignees.any(),
                            SalesTask.owner_id.in_(task_owner_ids),
                        ),
                    )
                )
                .filter(SalesTask.due_date.isnot(None))
                .filter(or_(SalesTask.status.is_(None), func.lower(SalesTask.status) != "completed"))
                .order_by(SalesTask.due_date.asc(), SalesTask.id.asc())
                .all()
            )

        show_projects = (
            viewing_user.can_view_module("operations") if viewing_user else True
        ) or has_project_tasks
        show_qc = (viewing_user.can_view_module("qc") if viewing_user else True) or has_qc_tasks
        show_sales = (
            viewing_user.can_view_module("sales") if viewing_user else True
        ) or bool(sales_items) or bool(sales_tasks)
        show_customer_support = (
            viewing_user.can_view_module("customer_support") if viewing_user else True
        ) or bool(support_tickets)

        if "Projects" in module_visibility_override:
            show_projects = bool(module_visibility_override["Projects"])
        if "Quality Control" in module_visibility_override:
            show_qc = bool(module_visibility_override["Quality Control"])
        if "Sales" in module_visibility_override:
            show_sales = bool(module_visibility_override["Sales"])
        if "Customer Support" in module_visibility_override:
            show_customer_support = bool(module_visibility_override["Customer Support"])

        if show_projects:
            _ensure_module(
                modules_map,
                module_order,
                "Projects",
                "No pending project tasks.",
                "Tasks from active projects assigned to you.",
            )
        if show_sales:
            _ensure_module(
                modules_map,
                module_order,
                "Sales",
                "No pending sales activities.",
                "Upcoming and overdue sales engagements and tasks on your opportunities.",
            )
        if show_customer_support:
            _ensure_module(
                modules_map,
                module_order,
                "Customer Support",
                "No open support tickets.",
                "Support tickets assigned to you.",
            )

        for task in open_tasks:
            module_label = "Projects" if task.project else "Quality Control"
            if module_label == "Projects" and not show_projects:
                continue
            if module_label == "Quality Control" and not show_qc:
                continue
            module_description = (
                "Project execution tasks awaiting your action."
                if module_label == "Projects"
                else "Quality inspections and tasks that still need attention."
            )
            module = _ensure_module(
                modules_map,
                module_order,
                module_label,
                "No pending QC tasks." if module_label == "Quality Control" else "No pending project tasks.",
                module_description,
            )

            due_label, due_display, due_variant = _describe_due_date(task.due_date, now)
            metadata = []
            if task.stage:
                metadata.append(task.stage)
            if task.lift_type:
                metadata.append(task.lift_type)
            if task.template and task.template.name:
                metadata.append(f"Form: {task.template.name}")
            if task.project and task.project.name:
                metadata.append(f"Project: {task.project.name}")

            creator_user = getattr(task, "creator", None)
            if creator_user and (not viewing_user or creator_user.id != viewing_user.id):
                owner_label = creator_user.display_name or creator_user.username
                if owner_label:
                    metadata.append(f"Owner: {owner_label}")

            assignee_user = None
            if assignee_lookup:
                assignee_user = assignee_lookup.get(getattr(task, "assigned_to", None))

            module["items"].append(
                {
                    "title": task.display_title,
                    "subtitle": task.client_name or task.site_name,
                    "description": task.description,
                    "identifier": f"#{task.id}",
                    "status": task.status or "Open",
                    "status_class": _status_badge_class(_status_key(task.status)),
                    "due_description": due_label,
                    "due_display": due_display,
                    "due_class": _due_badge_class(due_variant),
                    "due_variant": due_variant,
                    "url": url_for("qc_work_detail", work_id=task.id),
                    "secondary_url": url_for("forms_fill", form_id=task.template_id, work_id=task.id)
                    if task.template_id
                    else None,
                    "secondary_label": "New Submission" if task.template_id else None,
                    "metadata": metadata
                    + (
                        []
                        if not assignee_user
                        or (viewing_user and assignee_user.id == viewing_user.id)
                        else [
                            f"Assignee: {assignee_user.display_name}"
                            if assignee_user.display_name
                            else f"Assignee: {assignee_user.username}"
                        ]
                    ),
                }
                )

        if show_sales:
            sales_module = modules_map.get("Sales")
            for activity in sales_items:
                opportunity = activity.opportunity
                due_label, due_display, due_variant = _describe_due_date(activity.scheduled_for, now)
                status_key = "overdue" if due_variant == "overdue" else "scheduled"
                metadata = [activity.display_activity_type]
                subtitle = None
                if opportunity:
                    subtitle = opportunity.title
                    if opportunity.stage:
                        metadata.append(opportunity.stage)
                    if opportunity.client and opportunity.client.display_name:
                        metadata.append(f"Client: {opportunity.client.display_name}")

                if assignee_lookup:
                    owner_user = None
                    if opportunity and opportunity.owner_id:
                        owner_user = assignee_lookup.get(opportunity.owner_id)
                    if owner_user and owner_user.display_name:
                        owner_label = f"Owner: {owner_user.display_name}"
                        if owner_label not in metadata:
                            metadata.append(owner_label)
                    planner_user = None
                    if activity.created_by_id:
                        planner_user = assignee_lookup.get(activity.created_by_id)
                    if planner_user and planner_user.display_name:
                        planner_label = f"Planner: {planner_user.display_name}"
                        if planner_label not in metadata:
                            metadata.append(planner_label)

                sales_module["items"].append(
                    {
                        "title": activity.subject or activity.display_activity_type,
                        "subtitle": subtitle,
                        "description": activity.notes,
                        "identifier": f"Activity #{activity.id}",
                        "status": "Overdue" if status_key == "overdue" else "Scheduled",
                        "status_class": _status_badge_class(status_key),
                        "due_description": due_label,
                        "due_display": due_display,
                        "due_class": _due_badge_class(due_variant),
                        "due_variant": due_variant,
                        "url": url_for("sales_opportunity_detail", opportunity_id=opportunity.id)
                        if opportunity
                        else None,
                        "secondary_url": None,
                        "secondary_label": None,
                        "metadata": metadata,
                    }
                )

            for task in sales_tasks:
                due_label, due_display, due_variant = _describe_due_date(task.due_date, now)
                status_key = (task.status or "Pending").strip().lower()
                status_class = _status_badge_class(status_key)
                due_class = _due_badge_class(due_variant)

                related_bits = []
                if task.client:
                    related_bits.append(
                        task.client.display_name
                        or task.client.company_name
                        or task.client.code
                    )
                if task.opportunity:
                    related_bits.append(task.opportunity.title)
                subtitle = " · ".join(related_bits) or "Sales Task"

                metadata = []
                if task.category:
                    metadata.append({"label": "Category", "value": task.category})
                if task.related_type:
                    metadata.append({"label": "Type", "value": task.related_type})

                owner_user = None
                if assignee_lookup and task.owner_id:
                    owner_user = assignee_lookup.get(task.owner_id)

                if owner_user and owner_user.display_name:
                    metadata.append({"label": "Owner", "value": owner_user.display_name})
                elif task.owner and task.owner.display_name:
                    metadata.append({"label": "Owner", "value": task.owner.display_name})

                assignee_labels = []
                potential_assignees = list(task.assignees or [])
                if task.assignee and task.assignee not in potential_assignees:
                    potential_assignees.append(task.assignee)

                for user in potential_assignees:
                    if not user:
                        continue
                    lookup_user = assignee_lookup.get(user.id) if assignee_lookup else None
                    display_user = lookup_user or user
                    if display_user.display_name:
                        assignee_labels.append(display_user.display_name)
                    elif display_user.username:
                        assignee_labels.append(display_user.username)

                if not assignee_labels and task.owner and task.owner.display_name:
                    assignee_labels.append(task.owner.display_name)

                if assignee_labels:
                    metadata.append({"label": "Assigned", "value": ", ".join(assignee_labels)})

                sales_module["items"].append(
                    {
                        "title": task.title,
                        "subtitle": subtitle,
                        "description": task.description or "",
                        "status": task.status or "Pending",
                        "status_class": status_class,
                        "due_description": due_label,
                        "due_display": due_display,
                        "due_class": due_class,
                        "due_variant": due_variant,
                        "identifier": f"Sales Task · {task.id}",
                        "url": url_for("sales_task_detail", task_id=task.id),
                        "secondary_url": None,
                        "secondary_label": None,
                        "metadata": metadata,
                    }
                )

        if show_customer_support:
            for ticket in support_tickets or []:
                assignee_user = _resolve_ticket_assignee_user(
                    ticket, module_key="customer_support"
                )
                if assignee_lookup and assignee_user:
                    assignee_user = assignee_lookup.get(assignee_user.id, assignee_user)

                due_at = ticket.get("due_at") or _calculate_ticket_sla_due(ticket)
                if isinstance(due_at, datetime.datetime):
                    due_label, due_display, due_variant = _describe_due_date(due_at, now)
                else:
                    due_label, due_display, due_variant = None, None, "none"

                metadata = []
                if ticket.get("category"):
                    metadata.append(ticket.get("category"))
                if ticket.get("channel"):
                    metadata.append(ticket.get("channel"))
                if ticket.get("priority"):
                    metadata.append(f"Priority: {ticket.get('priority')}")

                if assignee_user and viewing_user and assignee_user.id != viewing_user.id:
                    owner_label = assignee_user.display_name or assignee_user.username
                    metadata.append(f"Owner: {owner_label}")

                support_module = modules_map.get("Customer Support")
                support_module["items"].append(
                    {
                        "title": ticket.get("subject") or "Support ticket",
                        "subtitle": ticket.get("customer")
                        or ticket.get("location")
                        or ticket.get("contact_name"),
                        "description": ticket.get("remarks"),
                        "identifier": ticket.get("id"),
                        "status": ticket.get("status") or "Open",
                        "status_class": _status_badge_class(_status_key(ticket.get("status"))),
                        "due_description": due_label,
                        "due_display": due_display,
                        "due_class": _due_badge_class(due_variant),
                        "due_variant": due_variant,
                        "url": url_for("customer_support_tasks", ticket=ticket.get("id")),
                        "secondary_url": None,
                        "secondary_label": None,
                        "metadata": metadata,
                    }
                )

        # --- Service module: AMC + breakdown visits assigned to user(s) ---
        # Only if the viewing user is allowed to see the Service module
        show_service = viewing_user.can_view_module("service") if viewing_user else False
        if "Service" in module_visibility_override:
            show_service = bool(module_visibility_override["Service"])

        if show_service:
            # Build set of allowed technician names depending on personal vs team view
            allowed_technician_names = set()

            if assignee_lookup:
                # Team Dash: visits assigned to any user in the team
                for user in assignee_lookup.values():
                    if not user or not user.is_active:
                        continue
                    for value in (user.display_name, user.username):
                        if value:
                            allowed_technician_names.add(value.strip().lower())
            else:
                # My Dash: visits assigned to the viewing user
                if viewing_user and viewing_user.is_active:
                    for value in (viewing_user.display_name, viewing_user.username):
                        if value:
                            allowed_technician_names.add(value.strip().lower())

            if allowed_technician_names:
                snapshot = get_service_schedule_snapshot()

                service_module = None
                overdue_count = 0
                today_count = 0
                upcoming_count = 0

                for entry in snapshot["entries"]:
                    visit_date = entry.get("date")
                    if not visit_date:
                        continue

                    status_key = (entry.get("status") or "scheduled").strip().lower()
                    if status_key in {"completed", "cancelled"}:
                        continue

                    technician = (entry.get("technician") or "").strip().lower()
                    if technician and allowed_technician_names and technician not in allowed_technician_names:
                        continue

                    # Only consider dates that are not in the far past with no status
                    due_label, due_display, due_variant = _describe_due_date(visit_date, now)
                    if due_variant == "none":
                        continue

                    if due_variant == "overdue":
                        overdue_count += 1
                    elif due_variant == "today":
                        today_count += 1
                    else:
                        upcoming_count += 1

                    # Lazily create the Service module once we know at least one item qualifies
                    if service_module is None:
                        service_module = _ensure_module(
                            modules_map,
                            module_order,
                            "Service",
                            "No upcoming service visits assigned.",
                            "Overdue and upcoming AMC / breakdown visits assigned to you or your team.",
                        )

                    lift = entry["lift"]
                    lift_name = lift.lift_code or "Lift"

                    # Build a site description using customer, city, route
                    site_bits = []
                    customer = getattr(lift, "customer", None)
                    company_name = getattr(customer, "company_name", None) if customer else None
                    if company_name:
                        site_bits.append(company_name)
                    elif getattr(lift, "customer_code", None):
                        site_bits.append(lift.customer_code)
                    if getattr(lift, "city", None):
                        site_bits.append(lift.city)
                    if getattr(lift, "route", None):
                        site_bits.append(lift.route)

                    description = " · ".join(site_bits) if site_bits else "Service site not specified"
                    checklist = entry.get("checklist") or ""
                    subtitle = checklist or "Scheduled service visit"

                    status_label = "Overdue" if due_variant == "overdue" else "Scheduled"
                    status_class = _status_badge_class("overdue" if due_variant == "overdue" else "scheduled")
                    due_class = _due_badge_class(due_variant)

                    service_module["items"].append(
                        {
                            "title": lift_name,
                            "subtitle": subtitle,
                            "description": description,
                            "status": status_label,
                            "status_class": status_class,
                            "due_description": due_label,
                            "due_display": due_display,
                            "due_class": due_class,
                            "due_variant": due_variant,
                            "identifier": f"Service visit · {visit_date:%d %b %Y} · {lift_name}",
                            "url": url_for("service_lift_detail", lift_id=lift.id),
                            "secondary_url": None,
                            "secondary_label": None,
                            "metadata": [
                                {
                                    "label": "Technician",
                                    "value": entry.get("technician") or "Unassigned",
                                }
                            ],
                        }
                    )

                if service_module is not None:
                    service_module["summary"] = {
                        "overdue": overdue_count,
                        "today": today_count,
                        "upcoming": upcoming_count,
                    }
                    pending_total += len(service_module["items"])

        pending_modules = [modules_map[label] for label in module_order]
        pending_total = sum(len(module["items"]) for module in pending_modules)
        return pending_modules, pending_total

    def _team_members_for(user):
        if not user:
            return []

        members = []
        seen_positions = set()
        stack = []

        position = getattr(user, "position", None)
        if position and getattr(position, "direct_reports", None):
            stack.extend(list(position.direct_reports))

        if not stack and user.is_admin:
            query = User.query.filter(User.id != user.id)
            query = query.filter(User.active.is_(True))
            ordered = query.order_by(
                User.first_name.asc(),
                User.last_name.asc(),
                User.username.asc(),
            ).all()
            return ordered

        while stack:
            pos = stack.pop()
            if not pos:
                continue
            pos_id = getattr(pos, "id", None)
            if pos_id in seen_positions:
                continue
            seen_positions.add(pos_id)
            direct_reports = list(getattr(pos, "direct_reports", []) or [])
            if direct_reports:
                stack.extend(direct_reports)
            if not getattr(pos, "active", True):
                continue
            for member in list(getattr(pos, "users", []) or []):
                if not member or getattr(member, "id", None) is None:
                    continue
                if member.id == user.id:
                    continue
                if not member.is_active:
                    continue
                members.append(member)

        unique_members = []
        seen_member_ids = set()
        for member in members:
            if member.id in seen_member_ids:
                continue
            seen_member_ids.add(member.id)
            unique_members.append(member)
        return unique_members

    status_order = case(
        (QCWork.status == "Pending Inspection", 0),
        (QCWork.status == "Inspection Done", 1),
        (QCWork.status == "Rectification Pending", 2),
        (QCWork.status == "Closed", 3),
        else_=4
    )
    now = datetime.datetime.utcnow()
    tasks = (
        QCWork.query
        .filter(QCWork.assigned_to == viewing_user.id)
        .order_by(status_order, QCWork.due_date.asc().nullslast(), QCWork.created_at.desc())
        .all()
    )
    actionable_tasks = [task for task in tasks if task.dependency_satisfied]
    blocked_tasks = [task for task in tasks if not task.dependency_satisfied and task.status != "Closed"]
    open_tasks = [task for task in actionable_tasks if task.status != "Closed"]
    closed_tasks = [task for task in tasks if task.status == "Closed"]

    open_count = sum(1 for task in open_tasks if (task.status or "").lower() != "closed")
    in_progress_count = sum(1 for task in open_tasks if (task.status or "").lower() == "inspection done")
    overdue_count = sum(
        1
        for task in open_tasks
        if task.due_date and task.due_date < now and (task.status or "").lower() != "closed"
    )

    team_load = []
    if current_user.is_admin:
        users = User.query.order_by(User.username.asc()).all()
        assignments = {user.id: [] for user in users}
        for task in QCWork.query.filter(QCWork.assigned_to.isnot(None)).all():
            assignments.setdefault(task.assigned_to, []).append(task)

        for member in users:
            member_tasks = assignments.get(member.id, [])
            actionable = [task for task in member_tasks if task.dependency_satisfied]
            open_items = [task for task in actionable if task.status != "Closed"]
            team_load.append({
                "user": member,
                "total": len(actionable),
                "open": sum(1 for task in open_items if (task.status or "").lower() in {"open", "blocked"}),
                "in_progress": sum(1 for task in open_items if (task.status or "").lower() == "in progress"),
                "overdue": sum(
                    1 for task in open_items if task.due_date and task.due_date < now
                )
            })

    support_tickets = _pending_support_tickets_for_users(
        {getattr(viewing_user, "id", None)}, include_other_department=True
    )
    pending_modules, pending_total = _build_pending_modules(
        viewing_user,
        open_tasks,
        now,
        support_tickets=support_tickets,
        sales_filter_mode="owner_only",
    )

    created_by_modules = []
    created_by_total = 0
    if viewing_user and getattr(viewing_user, "id", None):
        created_by_tasks = (
            QCWork.query
            .filter(QCWork.created_by == viewing_user.id)
            .filter(QCWork.status != "Closed")
            .order_by(status_order, QCWork.due_date.asc().nullslast(), QCWork.created_at.desc())
            .all()
        )
        created_actionable_tasks = [
            task
            for task in created_by_tasks
            if task.dependency_satisfied and task.assigned_to != viewing_user.id
        ]
        assignee_lookup = {
            user.id: user for user in get_assignable_users_for_module("qc", order_by="username")
        }
        created_by_modules, created_by_total = _build_pending_modules(
            viewing_user,
            created_actionable_tasks,
            now,
            assignee_lookup=assignee_lookup,
            sales_user_ids={viewing_user.id},
            sales_filter_mode="creator_only",
            module_visibility_override={
                "Customer Support": False,
                "Service": False,
            },
            include_sales_tasks=False,
        )

    team_members = _team_members_for(viewing_user)
    team_user_ids = sorted(
        {member.id for member in team_members if getattr(member, "id", None)}
    )
    team_pending_modules = []
    team_pending_total = 0
    if team_user_ids:
        team_tasks = (
            QCWork.query
            .filter(QCWork.assigned_to.in_(team_user_ids))
            .order_by(status_order, QCWork.due_date.asc().nullslast(), QCWork.created_at.desc())
            .all()
        )
        team_actionable_tasks = [task for task in team_tasks if task.dependency_satisfied]
        team_open_tasks = [task for task in team_actionable_tasks if task.status != "Closed"]
        assignment_lookup = {member.id: member for member in team_members}
        team_support_tickets = _pending_support_tickets_for_users(team_user_ids)
        team_pending_modules, team_pending_total = _build_pending_modules(
            viewing_user,
            team_open_tasks,
            now,
            assignee_lookup=assignment_lookup,
            sales_user_ids=team_user_ids,
            support_tickets=team_support_tickets,
            sales_filter_mode="owner_only",
        )

    return {
        "open_tasks": open_tasks,
        "closed_tasks": closed_tasks,
        "open_count": open_count,
        "in_progress_count": in_progress_count,
        "overdue_count": overdue_count,
        "blocked_tasks": blocked_tasks,
        "team_load": team_load,
        "pending_modules": pending_modules,
        "pending_total": pending_total,
        "created_by_modules": created_by_modules,
        "created_by_total": created_by_total,
        "team_pending_modules": team_pending_modules,
        "team_pending_total": team_pending_total,
        "team_members": team_members,
    }


@app.route("/dashboard")
@login_required
def dashboard():
    viewing_user = current_user
    selected_user_id = request.args.get("user_id", type=int)
    if selected_user_id and current_user.is_admin:
        candidate = db.session.get(User, selected_user_id)
        if candidate:
            viewing_user = candidate

    context = _build_task_overview(viewing_user)
    context.update({
        "viewing_user": viewing_user,
        "category_label": None,
        "page_mode": "dashboard",
        "switch_user_endpoint": "dashboard",
    })

    return render_template("dashboard.html", **context)


@app.route("/projects/pending")
@login_required
def projects_pending():
    _module_visibility_required("operations")
    viewing_user = current_user
    selected_user_id = request.args.get("user_id", type=int)
    if selected_user_id and current_user.is_admin:
        candidate = db.session.get(User, selected_user_id)
        if candidate:
            viewing_user = candidate

    context = _build_task_overview(viewing_user)
    context.update({
        "viewing_user": viewing_user,
        "category_label": "Projects",
        "category_url": url_for("projects_pending"),
        "page_mode": "projects",
        "switch_user_endpoint": "projects_pending",
    })

    project_modules = [
        module
        for module in context.get("pending_modules", [])
        if module.get("module") in {"Projects", "Quality Control"}
    ]
    context["pending_modules"] = project_modules
    context["pending_total"] = sum(len(module.get("items", [])) for module in project_modules)

    team_project_modules = [
        module
        for module in context.get("team_pending_modules", [])
        if module.get("module") in {"Projects", "Quality Control"}
    ]
    context["team_pending_modules"] = team_project_modules
    context["team_pending_total"] = sum(
        len(module.get("items", [])) for module in team_project_modules
    )

    return render_template("dashboard.html", **context)


# ---------------------- FORMS (TEMPLATES) ----------------------
@app.route("/forms")
@login_required
def forms_list():
    _module_visibility_required("qc")
    params = {"tab": "templates"}
    sort = request.args.get("sort")
    direction = request.args.get("direction")
    if sort:
        params["sort"] = sort
    if direction:
        params["direction"] = direction
    return redirect(url_for("qc_settings", **params))


@app.route("/forms/new", methods=["GET", "POST"])
@login_required
def forms_new():
    _module_visibility_required("qc")
    if request.method == "POST":
        name = (request.form.get("name") or "").strip()
        stage = (request.form.get("stage") or "").strip()
        lift_type = (request.form.get("lift_type") or "").strip()
        is_primary = request.form.get("is_primary") == "on"
        try:
            schema = json.loads(request.form.get("schema_json", "[]"))
        except Exception:
            flash("Invalid JSON schema", "error")
            return render_template(
                "forms_edit.html",
                item=None,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=[],
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        if not name:
            flash("Name is required", "error")
            return render_template(
                "forms_edit.html",
                item=None,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        if stage and stage not in STAGES:
            flash("Select a valid Stage.", "error")
            return render_template(
                "forms_edit.html",
                item=None,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )
        if lift_type and lift_type not in LIFT_TYPES:
            flash("Select a valid Lift Type.", "error")
            return render_template(
                "forms_edit.html",
                item=None,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        if is_primary and (not stage or not lift_type):
            flash("Choose both a QC type and lift type to mark a primary template.", "error")
            return render_template(
                "forms_edit.html",
                item=None,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        item = FormSchema(
            name=name,
            schema_json=json.dumps(schema, ensure_ascii=False),
            min_photos_if_all_good=0,
            stage=stage or None,
            lift_type=lift_type or None,
            is_primary=is_primary,
            updated_at=datetime.datetime.utcnow()
        )
        db.session.add(item)
        db.session.flush()
        if is_primary:
            (
                FormSchema.query.filter(
                    FormSchema.stage == item.stage,
                    FormSchema.lift_type == item.lift_type,
                    FormSchema.id != item.id,
                ).update({"is_primary": False})
            )
        db.session.commit()
        flash("Form created", "success")
        return redirect(url_for("qc_settings", tab="templates"))

    return render_template(
        "forms_edit.html",
        item=None,
        STAGES=STAGES,
        LIFT_TYPES=LIFT_TYPES,
        initial_schema=[],
        category_label="Forms",
        category_url=url_for('qc_settings', tab='templates')
    )


@app.route("/forms/<int:form_id>/edit", methods=["GET", "POST"])
@login_required
def forms_edit(form_id):
    _module_visibility_required("qc")
    item = db.session.get(FormSchema, form_id)
    if not item:
        flash("Form not found", "error")
        return redirect(url_for("qc_settings", tab="templates"))

    if request.method == "POST":
        name = (request.form.get("name") or "").strip()
        stage = (request.form.get("stage") or "").strip()
        lift_type = (request.form.get("lift_type") or "").strip()
        is_primary = request.form.get("is_primary") == "on"
        try:
            schema = json.loads(request.form.get("schema_json", "[]"))
        except Exception:
            flash("Invalid JSON schema", "error")
            return render_template(
                "forms_edit.html",
                item=item,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=[],
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        if name:
            item.name = name
        item.schema_json = json.dumps(schema, ensure_ascii=False)

        if stage and stage not in STAGES:
            flash("Select a valid Stage.", "error")
            return render_template(
                "forms_edit.html",
                item=item,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )
        if lift_type and lift_type not in LIFT_TYPES:
            flash("Select a valid Lift Type.", "error")
            return render_template(
                "forms_edit.html",
                item=item,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        item.stage = stage or None
        item.lift_type = lift_type or None
        item.updated_at = datetime.datetime.utcnow()

        if is_primary and (not item.stage or not item.lift_type):
            flash("Choose both a QC type and lift type to mark a primary template.", "error")
            return render_template(
                "forms_edit.html",
                item=item,
                STAGES=STAGES,
                LIFT_TYPES=LIFT_TYPES,
                initial_schema=schema,
                category_label="Forms",
                category_url=url_for('qc_settings', tab='templates')
            )

        item.is_primary = is_primary
        if is_primary:
            (
                FormSchema.query.filter(
                    FormSchema.stage == item.stage,
                    FormSchema.lift_type == item.lift_type,
                    FormSchema.id != item.id,
                ).update({"is_primary": False})
            )
        db.session.commit()
        flash("Form updated", "success")
        return redirect(url_for("qc_settings", tab="templates"))

    return render_template(
        "forms_edit.html",
        item=item,
        STAGES=STAGES,
        LIFT_TYPES=LIFT_TYPES,
        initial_schema=json.loads(item.schema_json or "[]"),
        category_label="Forms",
        category_url=url_for('qc_settings', tab='templates')
    )


@app.route("/forms/<int:form_id>/delete", methods=["POST"])
@login_required
def forms_delete(form_id):
    _module_visibility_required("qc")
    item = db.session.get(FormSchema, form_id)
    if item:
        db.session.delete(item)
        db.session.commit()
        flash("Form deleted", "info")
    return redirect(url_for("qc_settings", tab="templates"))


@app.route("/forms/<int:form_id>/duplicate", methods=["POST"])
@login_required
def forms_duplicate(form_id):
    _module_visibility_required("qc")
    source = db.session.get(FormSchema, form_id)
    if not source:
        flash("Form not found", "error")
        return redirect(url_for("qc_settings", tab="templates"))

    copy_name = f"{source.name} (Copy)"
    duplicate_form = FormSchema(
        name=copy_name,
        schema_json=source.schema_json,
        min_photos_if_all_good=source.min_photos_if_all_good,
        stage=source.stage,
        lift_type=source.lift_type,
        is_primary=False,
        updated_at=datetime.datetime.utcnow(),
    )
    db.session.add(duplicate_form)
    db.session.commit()

    flash("Form duplicated. You can now edit the copy.", "success")
    return redirect(url_for("forms_edit", form_id=duplicate_form.id))


@app.route("/forms/<int:form_id>/fill", methods=["GET", "POST"])
@login_required
def forms_fill(form_id):
    _module_visibility_required("qc")
    fs = db.session.get(FormSchema, form_id)
    if not fs:
        flash("Form not found", "error")
        return redirect(url_for("qc_settings", tab="templates"))

    schema_raw = json.loads(fs.schema_json)
    sections, is_sectioned = _normalize_form_schema(schema_raw)
    linked_work_id = request.args.get("work_id", type=int)
    back_url = request.args.get("return") or request.referrer or url_for("qc_home")
    draft_key = f"qc_form_{form_id}_{linked_work_id or 'general'}"

    def _is_not_ok_value(value):
        return isinstance(value, str) and value.strip().lower() in {"not ok", "ng"}

    def _filter_sections_for_resubmission(blocks, previous_payload):
        if not isinstance(previous_payload, dict):
            return blocks, False, False

        filtered_blocks = []
        found_not_ok = False

        for block in blocks:
            section_label = block.get("section") or ""
            previous_entries = {}
            if is_sectioned:
                section_values = previous_payload.get(section_label)
                if isinstance(section_values, list):
                    previous_entries = {
                        entry.get("label"): entry
                        for entry in section_values
                        if isinstance(entry, dict) and entry.get("label") is not None
                    }
            else:
                previous_entries = previous_payload

            filtered_items = []
            for field in block.get("items", []):
                if field.get("type") != "select":
                    continue

                prev_val = None
                if is_sectioned:
                    prev_entry = previous_entries.get(field.get("label")) if isinstance(previous_entries, dict) else None
                    if isinstance(prev_entry, dict):
                        prev_val = prev_entry.get("value")
                else:
                    prev_val = previous_entries.get(field.get("label")) if isinstance(previous_entries, dict) else None
                    if isinstance(prev_val, dict):
                        prev_val = prev_val.get("value")

                if _is_not_ok_value(prev_val):
                    filtered_items.append(field)

            if filtered_items:
                found_not_ok = True
                filtered_blocks.append({"section": section_label, "items": filtered_items})

        return filtered_blocks, found_not_ok, True

    resubmission_mode = False
    resubmission_notice = False
    if linked_work_id:
        previous_submission = (
            Submission.query
            .filter(Submission.form_id == form_id, Submission.work_id == linked_work_id)
            .order_by(Submission.created_at.desc())
            .first()
        )
        if previous_submission:
            resubmission_mode = True
            try:
                previous_data = json.loads(previous_submission.data_json or "{}")
            except Exception:
                previous_data = {}

            sections, has_not_ok, filter_supported = _filter_sections_for_resubmission(sections, previous_data)
            if filter_supported and not has_not_ok:
                flash(
                    "All items were marked OK in the latest submission. Nothing to resubmit for this task.",
                    "info",
                )
                return redirect(back_url)
            resubmission_notice = filter_supported

    def render_form(subcategory_label=None, preserved_data=None):
        return render_template(
            "form_render.html",
            fs=fs,
            sections=sections,
            is_sectioned=is_sectioned,
            category_label="Forms",
            category_url=url_for('qc_settings', tab='templates'),
            subcategory_label=subcategory_label or fs.name,
            back_url=back_url,
            draft_key=draft_key,
            preview_only=False,
            resubmission_mode=resubmission_mode,
            resubmission_notice=resubmission_notice,
            preserved_data=preserved_data,
        )

    if request.method == "POST":
        values = {} if is_sectioned else {}
        any_ng = False
        saved_photos = []
        per_item_photo_count = 0
        for s_idx, section in enumerate(sections):
            section_label = section.get("section") or f"Section {s_idx + 1}"
            section_items = section.get("items") or []
            section_entries = []
            if is_sectioned:
                values[section_label] = section_entries
            for f_idx, field in enumerate(section_items):
                label = field.get("label") or f"Item {f_idx + 1}"
                ftype = field.get("type")
                required = field.get("required", False)
                field_name = f"field__{s_idx}__{f_idx}"
                remark_name = f"remark__{s_idx}__{f_idx}"
                photo_name = f"photo__{s_idx}__{f_idx}"
                options = field.get("options") or []

                normalized_val = ""
                if ftype == "table":
                    rows = field.get("rows") or []
                    columns = field.get("columns") or []
                    table_values = []
                    missing_required = False
                    for r_idx, _ in enumerate(rows):
                        row_entries = []
                        for c_idx, _ in enumerate(columns):
                            cell_name = f"table__{s_idx}__{f_idx}__{r_idx}__{c_idx}"
                            cell_val = request.form.get(cell_name, "").strip()
                            if required and not cell_val:
                                missing_required = True
                            row_entries.append(cell_val)
                        table_values.append(row_entries)
                    if required and missing_required:
                        flash(f"'{label}' requires a value in every cell.", "error")
                        return render_form(preserved_data=request.form)
                    table_payload = {
                        "type": "table",
                        "rows": rows,
                        "columns": columns,
                        "values": table_values,
                        "reference_image": field.get("reference_image") or "",
                    }
                    if is_sectioned:
                        section_entries.append({
                            "label": label,
                            "type": "table",
                            "table": table_payload
                        })
                    else:
                        values[label] = table_payload
                    continue

                if ftype in ["text", "textarea"]:
                    val = request.form.get(field_name, "").strip()
                    if required and not val:
                        flash(f"'{label}' is required", "error")
                        return render_form(preserved_data=request.form)
                elif ftype in ["select", "if_else"]:
                    val = request.form.get(field_name, "")
                    normalized_val = val.strip().lower() if isinstance(val, str) else ""
                    if required and not val:
                        flash(f"'{label}' is required", "error")
                        return render_form(preserved_data=request.form)
                    if options and val and val not in options:
                        flash(f"'{label}' has an invalid selection", "error")
                        return render_form(preserved_data=request.form)
                    if normalized_val in {"ng", "not ok"}:
                        any_ng = True
                elif ftype == "checkbox":
                    selected_options = request.form.getlist(field_name)
                    cleaned = [val for val in selected_options if val]
                    if options:
                        invalid = [val for val in cleaned if val not in options]
                        if invalid:
                            flash(f"'{label}' has an invalid selection", "error")
                            return render_form(preserved_data=request.form)
                    if required and not cleaned:
                        flash(f"Select at least one option for '{label}'", "error")
                        return render_form(preserved_data=request.form)
                    val = cleaned
                    if any(v.strip().lower() in {"ng", "not ok"} for v in cleaned):
                        any_ng = True
                else:
                    val = request.form.get(field_name, "").strip()

                remark_val = ""
                if field.get("allow_remark"):
                    remark_val = request.form.get(remark_name, "").strip()

                item_saved_photos = []
                valid_item_files = []
                if field.get("allow_photo"):
                    upload_list = request.files.getlist(photo_name)
                    for f in upload_list:
                        if f and f.filename:
                            ext = f.filename.rsplit(".", 1)[1].lower() if "." in f.filename else ""
                            if ext in {"png", "jpg", "jpeg", "webp"}:
                                valid_item_files.append(f)
                    if (
                        field.get("photo_required_if_ng")
                        and normalized_val in {"ng", "not ok"}
                        and not valid_item_files
                    ):
                        flash(f"Photo evidence is required for '{label}' when marked Not OK.", "error")
                        return render_form(preserved_data=request.form)
                    for f in valid_item_files:
                        fname = secure_filename(f.filename)
                        dest = os.path.join(app.config["UPLOAD_FOLDER"], f"{datetime.datetime.utcnow().timestamp()}_{fname}")
                        f.save(dest)
                        saved_path = dest
                        item_saved_photos.append(saved_path)
                        saved_photos.append(saved_path)
                        per_item_photo_count += 1

                if is_sectioned:
                    section_entries.append({
                        "label": label,
                        "type": ftype,
                        "value": val,
                        "remark": remark_val or None,
                        "photos": item_saved_photos
                    })
                else:
                    values[label] = val
                    if field.get("allow_remark") and remark_val:
                        values[f"{label} - Remark"] = remark_val

        photo_files = request.files.getlist("photos")
        video_files = request.files.getlist("videos")
        saved_videos = []

        valid_photo_files = [
            p for p in photo_files
            if p and p.filename and "." in p.filename and p.filename.rsplit(".", 1)[1].lower() in {"png", "jpg", "jpeg", "webp"}
        ]

        if any_ng and per_item_photo_count + len(valid_photo_files) == 0:
            flash("At least one photo is required when any item is marked Not OK.", "error")
            return render_form(preserved_data=request.form)

        for f in valid_photo_files:
            fname = secure_filename(f.filename)
            dest = os.path.join(app.config["UPLOAD_FOLDER"], f"{datetime.datetime.utcnow().timestamp()}_{fname}")
            f.save(dest)
            saved_photos.append(dest)

        for f in video_files:
            if f and f.filename:
                ext = f.filename.rsplit(".",1)[1].lower() if "." in f.filename else ""
                if ext in {"mp4","mov","avi","mkv"}:
                    fname = secure_filename(f.filename)
                    dest = os.path.join(app.config["UPLOAD_FOLDER"], f"{datetime.datetime.utcnow().timestamp()}_{fname}")
                    f.save(dest)
                    saved_videos.append(dest)

        sub = Submission(
            form_id=fs.id,
            submitted_by=current_user.id,
            data_json=json.dumps(values, ensure_ascii=False),
            photos_json=json.dumps(saved_photos, ensure_ascii=False),
            videos_json=json.dumps(saved_videos, ensure_ascii=False),
            work_id=linked_work_id
        )
        db.session.add(sub)
        if linked_work_id:
            work = db.session.get(QCWork, linked_work_id)
            if work:
                previous_status = work.status or QC_STATUS_OPTIONS[0]
                if previous_status == QC_STATUS_OPTIONS[0]:
                    work.status = "Inspection Done"
                    log_work_event(
                        work.id,
                        "status_changed",
                        actor_id=current_user.id,
                        from_status=previous_status,
                        to_status="Inspection Done",
                    )
                log_work_event(
                    work.id,
                    "submission_created",
                    actor_id=current_user.id,
                    details={"submission_id": sub.id}
                )
        db.session.commit()
        flash("Submitted successfully!", "success")
        return redirect(url_for("dashboard"))

    return render_form()
@app.route("/forms/<int:form_id>/preview")
@login_required
def forms_preview(form_id):
    _module_visibility_required("qc")
    fs = db.session.get(FormSchema, form_id)
    if not fs:
        flash("Form not found", "error")
        return redirect(url_for("qc_settings", tab="templates"))

    schema_raw = json.loads(fs.schema_json or "[]")
    sections, is_sectioned = _normalize_form_schema(schema_raw)
    draft_key = f"qc_form_{form_id}_preview"
    back_url = request.referrer or url_for("qc_settings", tab="templates")
    return render_template(
        "form_render.html",
        fs=fs,
        sections=sections,
        is_sectioned=is_sectioned,
        category_label="Forms",
        category_url=url_for('qc_settings', tab='templates'),
        subcategory_label=f"Preview – {fs.name}",
        preview_only=True,
        draft_key=draft_key,
        back_url=back_url
    )


@app.route("/submissions/<int:sub_id>")
@login_required
def submission_view(sub_id):
    sub = db.session.get(Submission, sub_id)
    if not sub:
        flash("Submission not found", "error")
        return redirect(url_for("dashboard"))
    data = json.loads(sub.data_json or "{}")
    photos = json.loads(sub.photos_json or "[]")
    videos = json.loads(sub.videos_json or "[]")
    data_sectioned = any(
        isinstance(entries, list) and entries and isinstance(entries[0], dict) and "label" in entries[0]
        for entries in (data.values() if isinstance(data, dict) else [])
    )
    return render_template("submission_view.html", sub=sub, data=data, photos=photos, videos=videos,
                           data_sectioned=data_sectioned,
                           category_label="Dashboard", category_url=url_for('dashboard'),
                           subcategory_label=f"Submission #{sub.id}", subcategory_url=None)


# ---------------------- PROJECTS ----------------------
@app.route("/projects", methods=["GET", "POST"])
@login_required
def projects_list():
    _module_visibility_required("operations")
    if request.method == "POST":
        name = (request.form.get("name") or "").strip()
        site_name = (request.form.get("site_name") or "").strip()
        site_address = (request.form.get("site_address") or "").strip()
        customer_name = (request.form.get("customer_name") or "").strip()
        lift_type = (request.form.get("lift_type") or "").strip()
        floors_raw = (request.form.get("floors") or "").strip()
        stops_raw = (request.form.get("stops") or "").strip()
        opening_type = (request.form.get("opening_type") or "").strip()
        location = (request.form.get("location") or "").strip()
        handover_raw = (request.form.get("handover_date") or "").strip()
        priority = (request.form.get("priority") or "").strip()
        structure_type = (request.form.get("structure_type") or "").strip()
        cladding_type = (request.form.get("cladding_type") or "").strip()
        cabin_finish = (request.form.get("cabin_finish") or "").strip()
        door_operation_type = (request.form.get("door_operation_type") or "").strip()
        door_finish = (request.form.get("door_finish") or "").strip()

        if not name:
            flash("Project name is required.", "error")
            return redirect(url_for("projects_list"))

        if lift_type and lift_type not in LIFT_TYPES:
            flash("Select a valid lift type.", "error")
            return redirect(url_for("projects_list"))

        floors = normalize_floor_label(floors_raw)

        stops = None
        if stops_raw:
            try:
                stops = int(stops_raw)
                if stops < 0:
                    raise ValueError
            except ValueError:
                flash("Number of stops must be a positive whole number.", "error")
                return redirect(url_for("projects_list"))

        if opening_type and opening_type not in PROJECT_OPENING_TYPES:
            flash("Choose a valid opening type.", "error")
            return redirect(url_for("projects_list"))

        if location and location not in PROJECT_LOCATIONS:
            flash("Choose a valid location.", "error")
            return redirect(url_for("projects_list"))

        if structure_type and structure_type not in PROJECT_STRUCTURE_TYPES:
            flash("Choose a valid structure type.", "error")
            return redirect(url_for("projects_list"))

        if cladding_type and cladding_type not in PROJECT_CLADDING_TYPES:
            flash("Choose a valid cladding type.", "error")
            return redirect(url_for("projects_list"))

        if cabin_finish and cabin_finish not in PROJECT_CABIN_FINISHES:
            flash("Choose a valid cabin finish.", "error")
            return redirect(url_for("projects_list"))

        if door_operation_type and door_operation_type not in PROJECT_DOOR_OPERATION_TYPES:
            flash("Choose a valid door operation type.", "error")
            return redirect(url_for("projects_list"))

        if door_finish and door_finish not in PROJECT_DOOR_FINISHES:
            flash("Choose a valid door finish.", "error")
            return redirect(url_for("projects_list"))

        if priority and priority not in PROJECT_PRIORITIES:
            flash("Choose a valid project priority.", "error")
            return redirect(url_for("projects_list"))

        handover_date = None
        if handover_raw:
            try:
                handover_date = datetime.datetime.strptime(handover_raw, "%Y-%m-%d").date()
            except ValueError:
                flash("Provide a valid handover date (YYYY-MM-DD).", "error")
                return redirect(url_for("projects_list"))

        project = Project(
            name=name,
            site_name=site_name or None,
            site_address=site_address or None,
            customer_name=customer_name or None,
            lift_type=lift_type or None,
            floors=floors,
            stops=stops,
            opening_type=opening_type or None,
            location=location or None,
            handover_date=handover_date,
            priority=priority or None,
            structure_type=structure_type or None,
            cladding_type=cladding_type or None,
            cabin_finish=cabin_finish or None,
            door_operation_type=door_operation_type or None,
            door_finish=door_finish or None,
        )
        db.session.add(project)
        db.session.commit()
        flash("Project created.", "success")
        return redirect(url_for("project_detail", project_id=project.id))

    projects = Project.query.order_by(Project.created_at.desc()).all()
    stats_rows = (
        db.session.query(
            QCWork.project_id,
            func.count(QCWork.id).label("total"),
            func.coalesce(func.sum(case((QCWork.status == "Pending Inspection", 1), else_=0)), 0).label("open"),
            func.coalesce(func.sum(case((QCWork.status == "Inspection Done", 1), else_=0)), 0).label("in_progress"),
            func.coalesce(func.sum(case((QCWork.status == "Closed", 1), else_=0)), 0).label("closed")
        )
        .filter(QCWork.project_id.isnot(None))
        .group_by(QCWork.project_id)
        .all()
    )
    stats_map = {
        row.project_id: {
            "total": int(row.total or 0),
            "open": int(row.open or 0),
            "in_progress": int(row.in_progress or 0),
            "closed": int(row.closed or 0)
        }
        for row in stats_rows
    }
    return render_template(
        "projects.html",
        projects=projects,
        stats_map=stats_map,
        LIFT_TYPES=LIFT_TYPES,
        PROJECT_PRIORITIES=PROJECT_PRIORITIES,
        PROJECT_OPENING_TYPES=PROJECT_OPENING_TYPES,
        PROJECT_LOCATIONS=PROJECT_LOCATIONS,
        PROJECT_STRUCTURE_TYPES=PROJECT_STRUCTURE_TYPES,
        PROJECT_CLADDING_TYPES=PROJECT_CLADDING_TYPES,
        PROJECT_CABIN_FINISHES=PROJECT_CABIN_FINISHES,
        PROJECT_DOOR_OPERATION_TYPES=PROJECT_DOOR_OPERATION_TYPES,
        PROJECT_DOOR_FINISHES=PROJECT_DOOR_FINISHES,
    )


@app.route("/projects/<int:project_id>")
@login_required
def project_detail(project_id):
    _module_visibility_required("operations")
    project = Project.query.get_or_404(project_id)
    project_tasks = (
        ProjectTask.query
        .filter(ProjectTask.project_id == project.id)
        .order_by(ProjectTask.order_index.asc(), ProjectTask.id.asc())
        .all()
    )

    def _resolve_project_task_status(task):
        if task.linked_record_type == "qc_task":
            linked = db.session.get(QCWork, task.linked_record_id)
            return linked.status if linked else "Pending Inspection"
        if task.linked_record_type == "design_task":
            linked = db.session.get(DesignTask, task.linked_record_id)
            return linked.status if linked else "In progress"
        if task.linked_record_type == "srt_task":
            linked = db.session.get(SRTTask, task.linked_record_id)
            return linked.status if linked else "Scheduled"
        return "Open"

    def _is_task_closed(task):
        status = (getattr(task, "status", None) or "").lower()
        if task.module == "design":
            return status == "finalized"
        if task.module == "srt":
            return status == "closed"
        if task.module == "qc":
            return status == "closed"
        return False

    for task in project_tasks:
        task.status = _resolve_project_task_status(task)
        task.dependency_satisfied = all(_is_task_closed(dep) for dep in task.dependencies)
        task.display_title = task.name
        task.detail_url = None
        task.due_date = None
        task.planned_due_date = None
        task.planned_start_date = None
        task.planned_duration_days = None
        task.creator = None
        task.assignee = None
        task.template_task = task.template_task
        task.milestone = None
        task.description = task.description
        if task.linked_record_type == "qc_task":
            linked = db.session.get(QCWork, task.linked_record_id)
            if linked:
                task.display_title = linked.display_title
                task.description = linked.description
                task.creator = linked.creator
                task.assignee = linked.assignee
                task.due_date = linked.due_date
                task.planned_start_date = linked.planned_start_date
                task.planned_duration_days = linked.planned_duration_days
                task.planned_due_date = linked.planned_due_date
                task.template_task = linked.template_task
                task.milestone = linked.milestone
            task.detail_url = url_for("qc_work_detail", work_id=task.linked_record_id)
        elif task.linked_record_type == "design_task":
            linked = db.session.get(DesignTask, task.linked_record_id)
            if linked:
                task.display_title = linked.description or linked.project_label
                task.description = linked.notes or linked.description
                task.creator = linked.requested_by
                task.assignee = linked.assigned_to
                task.due_date = linked.due_date
            task.detail_url = url_for("design_task_detail", task_id=task.linked_record_id)
        elif task.linked_record_type == "srt_task":
            task.detail_url = url_for("srt_overview")

    active_tasks = [task for task in project_tasks if not _is_task_closed(task) and task.dependency_satisfied]
    waiting_tasks = [task for task in project_tasks if not _is_task_closed(task) and not task.dependency_satisfied]
    closed_tasks = [task for task in project_tasks if _is_task_closed(task)]

    templates = ProjectTemplate.query.order_by(ProjectTemplate.name.asc()).all()
    form_templates = FormSchema.query.order_by(FormSchema.name.asc()).all()
    users = get_assignable_users_for_module("operations", order_by="username")
    comments = (
        ProjectComment.query.filter_by(project_id=project.id)
        .order_by(ProjectComment.created_at.desc())
        .all()
    )
    project_delivery_orders = (
        DeliveryOrder.query.filter(DeliveryOrder.project_id == project.id)
        .order_by(DeliveryOrder.created_at.desc().nullslast())
        .limit(10)
        .all()
    )
    project_delivery_challans = (
        DeliveryChallan.query.options(joinedload(DeliveryChallan.delivery_order))
        .filter(
            or_(
                DeliveryChallan.project_id == project.id,
                DeliveryChallan.delivery_order.has(DeliveryOrder.project_id == project.id),
            )
        )
        .order_by(DeliveryChallan.created_at.desc().nullslast())
        .limit(10)
        .all()
    )

    return render_template(
        "project_detail.html",
        project=project,
        active_tasks=active_tasks,
        waiting_tasks=waiting_tasks,
        closed_tasks=closed_tasks,
        all_tasks=project_tasks,
        templates=templates,
        form_templates=form_templates,
        users=users,
        comments=comments,
        LIFT_TYPES=LIFT_TYPES,
        DEFAULT_TASK_FORM_NAME=DEFAULT_TASK_FORM_NAME,
        STAGES=STAGES,
        TASK_MILESTONES=TASK_MILESTONES,
        PROJECT_PRIORITIES=PROJECT_PRIORITIES,
        PROJECT_OPENING_TYPES=PROJECT_OPENING_TYPES,
        PROJECT_LOCATIONS=PROJECT_LOCATIONS,
        PROJECT_STRUCTURE_TYPES=PROJECT_STRUCTURE_TYPES,
        PROJECT_CLADDING_TYPES=PROJECT_CLADDING_TYPES,
        PROJECT_CABIN_FINISHES=PROJECT_CABIN_FINISHES,
        PROJECT_DOOR_OPERATION_TYPES=PROJECT_DOOR_OPERATION_TYPES,
        PROJECT_DOOR_FINISHES=PROJECT_DOOR_FINISHES,
        project_delivery_orders=project_delivery_orders,
        project_delivery_challans=project_delivery_challans,
    )


@app.route("/projects/<int:project_id>/edit", methods=["POST"])
@login_required
def project_edit(project_id):
    _module_visibility_required("operations")
    project = Project.query.get_or_404(project_id)

    name = (request.form.get("name") or "").strip()
    site_name = (request.form.get("site_name") or "").strip()
    site_address = (request.form.get("site_address") or "").strip()
    customer_name = (request.form.get("customer_name") or "").strip()
    lift_type = (request.form.get("lift_type") or "").strip()
    floors_raw = (request.form.get("floors") or "").strip()
    stops_raw = (request.form.get("stops") or "").strip()
    opening_type = (request.form.get("opening_type") or "").strip()
    location = (request.form.get("location") or "").strip()
    handover_raw = (request.form.get("handover_date") or "").strip()
    priority = (request.form.get("priority") or "").strip()
    structure_type = (request.form.get("structure_type") or "").strip()
    cladding_type = (request.form.get("cladding_type") or "").strip()
    cabin_finish = (request.form.get("cabin_finish") or "").strip()
    door_operation_type = (request.form.get("door_operation_type") or "").strip()
    door_finish = (request.form.get("door_finish") or "").strip()

    if not name:
        flash("Project name is required.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if lift_type and lift_type not in LIFT_TYPES:
        flash("Select a valid lift type.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    floors = normalize_floor_label(floors_raw)

    stops = None
    if stops_raw:
        try:
            stops = int(stops_raw)
            if stops < 0:
                raise ValueError
        except ValueError:
            flash("Number of stops must be a positive whole number.", "error")
            return redirect(url_for("project_detail", project_id=project.id))

    if opening_type and opening_type not in PROJECT_OPENING_TYPES:
        flash("Choose a valid opening type.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if location and location not in PROJECT_LOCATIONS:
        flash("Choose a valid location.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if structure_type and structure_type not in PROJECT_STRUCTURE_TYPES:
        flash("Choose a valid structure type.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if cladding_type and cladding_type not in PROJECT_CLADDING_TYPES:
        flash("Choose a valid cladding type.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if cabin_finish and cabin_finish not in PROJECT_CABIN_FINISHES:
        flash("Choose a valid cabin finish.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if door_operation_type and door_operation_type not in PROJECT_DOOR_OPERATION_TYPES:
        flash("Choose a valid door operation type.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if door_finish and door_finish not in PROJECT_DOOR_FINISHES:
        flash("Choose a valid door finish.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    if priority and priority not in PROJECT_PRIORITIES:
        flash("Choose a valid project priority.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    handover_date = None
    if handover_raw:
        try:
            handover_date = datetime.datetime.strptime(handover_raw, "%Y-%m-%d").date()
        except ValueError:
            flash("Provide a valid handover date (YYYY-MM-DD).", "error")
            return redirect(url_for("project_detail", project_id=project.id))

    project.name = name
    project.site_name = site_name or None
    project.site_address = site_address or None
    project.customer_name = customer_name or None
    project.lift_type = lift_type or None
    project.floors = floors
    project.stops = stops
    project.opening_type = opening_type or None
    project.location = location or None
    project.handover_date = handover_date
    project.priority = priority or None
    project.structure_type = structure_type or None
    project.cladding_type = cladding_type or None
    project.cabin_finish = cabin_finish or None
    project.door_operation_type = door_operation_type or None
    project.door_finish = door_finish or None

    db.session.commit()
    flash("Project updated.", "success")
    return redirect(url_for("project_detail", project_id=project.id))


@app.route("/projects/<int:project_id>/comments", methods=["POST"])
@login_required
def project_add_comment(project_id):
    _module_visibility_required("operations")

    project = Project.query.get_or_404(project_id)
    body = (request.form.get("body") or "").strip()
    if not body:
        flash("Comment cannot be empty.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    comment = ProjectComment(
        project=project,
        body=body,
        author=current_user if current_user.is_authenticated else None,
    )
    db.session.add(comment)
    db.session.commit()

    flash("Comment added.", "success")
    return redirect(url_for("project_detail", project_id=project.id))


@app.route("/projects/<int:project_id>/apply-template", methods=["POST"])
@login_required
def project_apply_template(project_id):
    _module_visibility_required("operations")
    project = Project.query.get_or_404(project_id)
    template_id = request.form.get("template_id", type=int)
    if not template_id:
        flash("Select a template to apply.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    template = ProjectTemplate.query.get(template_id)
    if not template:
        flash("Template not found.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    fallback_form = get_or_create_default_task_form()
    existing_template_task_ids = {
        task.template_task_id
        for task in ProjectTask.query.filter(
            ProjectTask.project_id == project.id,
            ProjectTask.template_task_id.isnot(None),
        ).all()
        if task.template_task_id is not None
    }

    created = []
    task_lookup = {}
    qc_lookup = {}
    ordered_template_tasks = sorted(template.tasks, key=lambda t: ((t.order_index or 0), t.id))

    for idx, template_task in enumerate(ordered_template_tasks, start=1):
        if template_task.id in existing_template_task_ids:
            continue

        module = (template_task.module or template_task.task_type or "general").lower()
        task_subtype = (template_task.task_subtype or "general").lower()
        assignee_id = None
        assignee_candidate = None
        if template_task.default_assignee_id:
            assignee_candidate = db.session.get(User, template_task.default_assignee_id)
            if assignee_candidate and assignee_candidate.is_active:
                assignee_id = assignee_candidate.id

        project_task = ProjectTask(
            project_id=project.id,
            template_task_id=template_task.id,
            name=template_task.name,
            description=template_task.description,
            order_index=template_task.order_index or idx,
            duration_days=template_task.duration_days,
            module=module,
            task_subtype=task_subtype,
            assignee_id=assignee_id,
        )
        db.session.add(project_task)
        db.session.flush()
        task_lookup[template_task.id] = project_task

        planned_start = template_task.planned_start_date
        planned_duration = template_task.duration_days
        due_date = None
        if planned_start and planned_duration:
            due_date = datetime.datetime.combine(planned_start, datetime.time.min) + datetime.timedelta(days=planned_duration)
        elif planned_duration and (template_task.start_mode or "immediate") != "after_previous":
            due_date = datetime.datetime.utcnow() + datetime.timedelta(days=planned_duration)
        elif template_task.planned_due_date:
            due_date = datetime.datetime.combine(template_task.planned_due_date, datetime.time.min)

        if module == "srt":
            srt_task = SRTTask(
                project_id=project.id,
                project_task_id=project_task.id,
                site_name=project.site_name or project.name,
                summary=template_task.name,
                description=template_task.description or template_task.name,
                status=SRT_STATUS_OPTIONS[0],
                priority="Normal",
                due_date=due_date.date() if isinstance(due_date, datetime.datetime) else None,
                assigned_to_id=assignee_id,
                created_by_id=current_user.id,
            )
            db.session.add(srt_task)
            db.session.flush()
            project_task.linked_record_type = "srt_task"
            project_task.linked_record_id = srt_task.id
            sample_task_id = f"SRT-{srt_task.id}"
            SRT_SAMPLE_TASKS.insert(
                0,
                {
                    "id": sample_task_id,
                    "site": project.site_name or project.name,
                    "name": template_task.name,
                    "summary": template_task.description or template_task.name,
                    "priority": "Normal",
                    "status": srt_task.status,
                    "due_date": srt_task.due_date,
                    "owner": assignee_candidate.display_name if assignee_candidate else "Unassigned",
                    "age_days": 0,
                },
            )
            _log_srt_activity(
                sample_task_id,
                type="status",
                label="Task created",
                detail=template_task.description or template_task.name,
                actor=current_user.display_name if current_user.is_authenticated else "System",
                actor_role="admin" if current_user.is_admin else "user",
            )
            created.append(project_task)
            continue

        if module == "design":
            design_task = DesignTask(
                task_type="design",
                subtype=task_subtype,
                project_id=project.id,
                project_task_id=project_task.id,
                project_name=project.name,
                requested_by_user_id=current_user.id,
                assigned_to_user_id=assignee_id,
                status=DESIGN_TASK_STATUS_OPTIONS[0],
                priority="medium",
                due_date=due_date.date() if isinstance(due_date, datetime.datetime) else None,
                task_name=template_task.name,
                description=template_task.description or template_task.name,
                origin_type="operations",
                origin_id=project.id,
                origin_reference=project.name,
                notes=None,
            )
            db.session.add(design_task)
            db.session.flush()
            project_task.linked_record_type = "design_task"
            project_task.linked_record_id = design_task.id
            created.append(project_task)
            continue

        if module == "qc":
            form_template = template_task.form_template or fallback_form
            if not form_template:
                continue
            new_task = QCWork(
                site_name=project.site_name or project.name,
                client_name=project.customer_name,
                address=project.site_address,
                template_id=form_template.id,
                stage=template_task.template.name,
                lift_type=project.lift_type or form_template.lift_type,
                project_id=project.id,
                project_task_id=project_task.id,
                created_by=current_user.id,
                assigned_to=assignee_id,
                name=template_task.name,
                description=template_task.description,
                template_task_id=template_task.id,
                status=QC_STATUS_OPTIONS[0],
                due_date=due_date,
                planned_start_date=planned_start,
                planned_duration_days=planned_duration,
                milestone=template_task.milestone or None,
            )
            db.session.add(new_task)
            db.session.flush()
            project_task.linked_record_type = "qc_task"
            project_task.linked_record_id = new_task.id
            qc_lookup[template_task.id] = new_task
            created.append(project_task)
            continue

        created.append(project_task)

    for template_task in ordered_template_tasks:
        project_task = task_lookup.get(template_task.id)
        if not project_task:
            continue
        dependency_project_tasks = [
            task_lookup[dep_id].id for dep_id in template_task.dependency_ids if dep_id in task_lookup
        ]
        set_project_task_dependencies(project_task, dependency_project_tasks)

        if template_task.id in qc_lookup:
            qc_deps = [
                qc_lookup[dep_id].id for dep_id in template_task.dependency_ids if dep_id in qc_lookup
            ]
            set_qc_work_dependencies(qc_lookup[template_task.id], qc_deps)

    if not created:
        flash("No new tasks were created – they may already exist for this project.", "info")
        return redirect(url_for("project_detail", project_id=project.id))

    db.session.commit()
    flash(f"Added {len(created)} tasks from template {template.name}.", "success")
    return redirect(url_for("project_detail", project_id=project.id))


@app.route("/projects/<int:project_id>/tasks/create", methods=["POST"])
@login_required
def project_task_create(project_id):
    _module_visibility_required("operations")
    project = Project.query.get_or_404(project_id)
    name = (request.form.get("name") or "").strip()
    description = (request.form.get("description") or "").strip()
    form_template_id = request.form.get("form_template_id", type=int)
    assigned_to = request.form.get("assigned_to", type=int)
    due = (request.form.get("due_date") or "").strip()
    depends_on_ids = []
    for raw in request.form.getlist("depends_on_ids"):
        try:
            dep_id = int(raw)
        except (TypeError, ValueError):
            continue
        if dep_id not in depends_on_ids:
            depends_on_ids.append(dep_id)
    stage = (request.form.get("stage") or "").strip()
    planned_start = (request.form.get("planned_start_date") or "").strip()
    duration_raw = (request.form.get("planned_duration_days") or "").strip()
    milestone_value = (request.form.get("milestone") or "").strip()

    if not name:
        flash("Provide a task name.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    form_template = db.session.get(FormSchema, form_template_id) if form_template_id else None
    if not form_template:
        form_template = get_or_create_default_task_form()
    if not form_template:
        flash("Set up a form template before creating tasks.", "error")
        return redirect(url_for("project_detail", project_id=project.id))

    due_dt = None
    if due:
        try:
            due_dt = datetime.datetime.strptime(due, "%Y-%m-%d")
        except Exception:
            flash("Invalid due date format.", "error")
            return redirect(url_for("project_detail", project_id=project.id))

    planned_start_date = None
    if planned_start:
        try:
            planned_start_date = datetime.datetime.strptime(planned_start, "%Y-%m-%d").date()
        except ValueError:
            flash("Invalid planned start date format.", "error")
            return redirect(url_for("project_detail", project_id=project.id))

    duration_days = None
    if duration_raw:
        try:
            duration_days = int(duration_raw)
        except ValueError:
            flash("Duration must be a whole number of days.", "error")
            return redirect(url_for("project_detail", project_id=project.id))
        if duration_days < 0:
            flash("Duration must be zero or positive.", "error")
            return redirect(url_for("project_detail", project_id=project.id))

    if due_dt is None:
        if planned_start_date and duration_days is not None:
            due_dt = datetime.datetime.combine(planned_start_date, datetime.time.min) + datetime.timedelta(days=duration_days)
        elif duration_days is not None:
            due_dt = datetime.datetime.utcnow() + datetime.timedelta(days=duration_days)

    dependency_tasks = []
    assignee_user = None
    if assigned_to:
        assignee_user = db.session.get(User, assigned_to)
        if not assignee_user or not assignee_user.can_be_assigned_module("operations"):
            flash("Choose an assignee who is available for Operations tasks.", "error")
            return redirect(url_for("project_detail", project_id=project.id))
    if depends_on_ids:
        dependencies = (
            ProjectTask.query
            .filter(ProjectTask.project_id == project.id, ProjectTask.id.in_(depends_on_ids))
            .all()
        )
        found_ids = {dep.id for dep in dependencies}
        missing = [dep_id for dep_id in depends_on_ids if dep_id not in found_ids]
        if missing:
            flash("Choose dependencies from the same project.", "error")
            return redirect(url_for("project_detail", project_id=project.id))
        id_map = {dep.id: dep for dep in dependencies}
        dependency_tasks = [id_map[dep_id] for dep_id in depends_on_ids if dep_id in id_map]

    project_task = ProjectTask(
        project_id=project.id,
        name=name,
        description=description or None,
        order_index=ProjectTask.query.filter_by(project_id=project.id).count() + 1,
        duration_days=duration_days,
        module="qc",
        task_subtype="qc",
        assignee_id=assigned_to if assignee_user else None,
    )
    db.session.add(project_task)
    db.session.flush()
    set_project_task_dependencies(project_task, [dep.id for dep in dependency_tasks])

    work = QCWork(
        site_name=project.site_name or project.name,
        client_name=project.customer_name,
        address=project.site_address,
        template_id=form_template.id,
        stage=stage or None,
        lift_type=project.lift_type or form_template.lift_type,
        project_id=project.id,
        project_task_id=project_task.id,
        due_date=due_dt,
        created_by=current_user.id,
        assigned_to=assigned_to if assignee_user else None,
        name=name,
        description=description or None,
        status=QC_STATUS_OPTIONS[0],
        planned_start_date=planned_start_date,
        planned_duration_days=duration_days,
        milestone=milestone_value or None
    )
    db.session.add(work)
    db.session.flush()
    set_qc_work_dependencies(work, [dep.id for dep in dependency_tasks if dep.module == "qc"])
    log_work_event(
        work.id,
        "created_from_project",
        actor_id=current_user.id,
        details={
            "project_id": project.id,
            "stage": stage or None,
            "assigned_to": assigned_to,
            "due_date": work.due_date.strftime("%Y-%m-%d") if work.due_date else None,
            "dependencies": [dep.id for dep in dependency_tasks],
            "planned_start_date": planned_start_date.strftime("%Y-%m-%d") if planned_start_date else None,
            "planned_duration_days": duration_days,
            "milestone": work.milestone
        }
    )
    if assignee_user:
        log_work_event(
            work.id,
            "assigned",
            actor_id=current_user.id,
            details={"assigned_to": assigned_to}
        )
        create_notification(
            assignee_user.id,
            f"You have been assigned a new task: {work.display_title}",
            url_for("qc_work_detail", work_id=work.id),
            commit=False,
        )
    project_task.linked_record_type = "qc_task"
    project_task.linked_record_id = work.id
    db.session.commit()
    flash("Project task created.", "success")
    return redirect(url_for("qc_work_detail", work_id=work.id))


def _load_project_template_context():
    templates = ProjectTemplate.query.order_by(ProjectTemplate.name.asc()).all()
    template_counts = {
        tpl.id: len(tpl.tasks)
        for tpl in templates
    }
    task_templates = TaskTemplate.query.order_by(TaskTemplate.created_at.desc()).all()
    return {
        "templates": templates,
        "template_counts": template_counts,
        "task_templates": task_templates,
        "DEFAULT_TASK_FORM_NAME": DEFAULT_TASK_FORM_NAME,
    }


def _handle_project_template_create():
    if request.method != "POST":
        return None

    name = (request.form.get("name") or "").strip()
    description = (request.form.get("description") or "").strip()
    if not name:
        flash("Template name is required.", "error")
        return None

    template = ProjectTemplate(
        name=name,
        description=description or None,
        created_by=current_user.id
    )
    db.session.add(template)
    db.session.commit()
    flash("Project template created.", "success")
    return redirect(url_for("project_template_detail", template_id=template.id))


def _render_ni_settings(default_tab="settings"):
    active_tab = request.args.get("tab") or default_tab
    creation_result = _handle_project_template_create()
    if request.method == "POST":
        active_tab = "project-templates"
    if creation_result:
        return creation_result

    context = _load_project_template_context()
    context["active_tab"] = active_tab
    return render_template("ni_settings.html", **context)


@app.route("/projects/settings", methods=["GET", "POST"])
@login_required
def ni_settings():
    _module_visibility_required("operations")
    return _render_ni_settings()


@app.route("/project-templates", methods=["GET", "POST"])
@login_required
def project_templates():
    _module_visibility_required("operations")
    return _render_ni_settings(default_tab="project-templates")


@app.route("/project-templates/<int:template_id>", methods=["GET", "POST"])
@login_required
def project_template_detail(template_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    users = get_assignable_users_for_module("operations", order_by="username")
    forms = FormSchema.query.order_by(FormSchema.name.asc()).all()

    if request.method == "POST":
        task_module = (request.form.get("module") or request.form.get("task_type") or "general").lower()
        if task_module not in dict(PROJECT_TEMPLATE_TASK_MODULES):
            task_module = "general"
        subtype_choices = dict(PROJECT_TEMPLATE_TASK_SUBTYPES.get(task_module, []))
        task_subtype = (request.form.get("task_subtype") or "").lower()
        if task_subtype not in subtype_choices:
            task_subtype = next(iter(subtype_choices.keys()), "general")
        task_type = task_module
        name = (request.form.get("name") or "").strip()
        description = (request.form.get("description") or "").strip()
        requested_order = request.form.get("order_index", type=int)
        depends_on_ids = []
        for raw in request.form.getlist("depends_on_ids"):
            try:
                dep_id = int(raw)
            except (TypeError, ValueError):
                continue
            if dep_id not in depends_on_ids:
                depends_on_ids.append(dep_id)
        default_assignee_id = request.form.get("default_assignee_id", type=int)
        form_template_id = request.form.get("form_template_id", type=int)

        if not name:
            flash("Task name is required.", "error")
            return redirect(url_for("project_template_detail", template_id=template.id))

        if depends_on_ids:
            dependencies = ProjectTemplateTask.query.filter(
                ProjectTemplateTask.template_id == template.id,
                ProjectTemplateTask.id.in_(depends_on_ids)
            ).all()
            valid_dependency_ids = {dep.id for dep in dependencies}
            depends_on_ids = [dep_id for dep_id in depends_on_ids if dep_id in valid_dependency_ids]

        if default_assignee_id:
            assignee_candidate = db.session.get(User, default_assignee_id)
            if not assignee_candidate or not assignee_candidate.can_be_assigned_module("operations"):
                flash("Choose a valid default assignee with Operations access.", "error")
                return redirect(url_for("project_template_detail", template_id=template.id))

        if form_template_id and not db.session.get(FormSchema, form_template_id):
            flash("Choose a valid form template.", "error")
            return redirect(url_for("project_template_detail", template_id=template.id))

        start_mode, planned_start_date, duration_value, milestone_value, timing_error = _extract_task_timing(request.form)
        if timing_error:
            flash(timing_error, "error")
            return redirect(url_for("project_template_detail", template_id=template.id))

        existing_tasks = ProjectTemplateTask.query.filter_by(template_id=template.id).order_by(
            ProjectTemplateTask.order_index.asc(),
            ProjectTemplateTask.id.asc()
        ).all()
        max_position = len(existing_tasks) + 1
        if not requested_order or requested_order < 1:
            requested_order = max_position
        else:
            requested_order = min(requested_order, max_position)

        shifts = False
        for idx, existing in enumerate(existing_tasks, start=1):
            new_index = idx if idx < requested_order else idx + 1
            if existing.order_index != new_index:
                shifts = True
            existing.order_index = new_index

        task = ProjectTemplateTask(
            template_id=template.id,
            task_type=task_type,
            module=task_module,
            task_subtype=task_subtype,
            name=name,
            description=description or None,
            order_index=requested_order,
            default_assignee_id=default_assignee_id,
            form_template_id=form_template_id,
            start_mode=start_mode,
            planned_start_date=planned_start_date,
            duration_days=duration_value,
            milestone=milestone_value
        )
        db.session.add(task)
        db.session.flush()
        set_template_task_dependencies(task, depends_on_ids)
        normalize_template_task_order(template.id)
        db.session.commit()
        message = "Template task added."
        if shifts:
            message = "Template task added. Existing tasks were re-ordered automatically."
        flash(message, "success")
        return redirect(url_for("project_template_detail", template_id=template.id))

    tasks = ProjectTemplateTask.query.filter_by(template_id=template.id).order_by(
        ProjectTemplateTask.order_index.asc(),
        ProjectTemplateTask.id.asc()
    ).all()
    return render_template(
        "project_template_detail.html",
        template=template,
        tasks=tasks,
        users=users,
        forms=forms,
        DEFAULT_TASK_FORM_NAME=DEFAULT_TASK_FORM_NAME,
        TASK_MILESTONES=TASK_MILESTONES,
        PROJECT_TEMPLATE_TASK_TYPES=PROJECT_TEMPLATE_TASK_TYPES,
        PROJECT_TEMPLATE_TASK_MODULES=PROJECT_TEMPLATE_TASK_MODULES,
        PROJECT_TEMPLATE_TASK_SUBTYPES=PROJECT_TEMPLATE_TASK_SUBTYPES,
        PROJECT_TEMPLATE_BADGES=PROJECT_TEMPLATE_BADGES,
        TASK_TYPE_LABELS=TASK_TYPE_LABELS,
    )


@app.route("/project-templates/<int:template_id>/update", methods=["POST"])
@login_required
def project_template_update(template_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    name = (request.form.get("template_name") or request.form.get("name") or "").strip()
    description = (request.form.get("template_description") or request.form.get("description") or "").strip()
    if not name:
        flash("Template name is required.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    template.name = name
    template.description = description or None
    db.session.commit()
    flash("Template details saved.", "success")
    return redirect(url_for("project_template_detail", template_id=template.id))


@app.route("/project-templates/<int:template_id>/save-as-task-template", methods=["POST"])
@login_required
def project_template_save_as_task_template(template_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    name = (request.form.get("task_template_name") or "").strip()
    description = (request.form.get("task_template_description") or "").strip()
    if not name:
        flash("Provide a name for the task template.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    existing = TaskTemplate.query.filter(func.lower(TaskTemplate.name) == name.lower()).first()
    if existing:
        flash("A task template with that name already exists.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    blueprint = build_task_template_blueprint(template)
    task_template = TaskTemplate(
        name=name,
        description=description or None,
        blueprint_json=json.dumps(blueprint, ensure_ascii=False),
        created_from_template_id=template.id,
        created_by=current_user.id
    )
    db.session.add(task_template)
    db.session.commit()
    flash("Task template saved for future reuse.", "success")
    return redirect(url_for("project_template_detail", template_id=template.id))


@app.route("/task-templates/<int:task_template_id>/create-project-template", methods=["POST"])
@login_required
def create_project_template_from_task_template(task_template_id):
    task_template = TaskTemplate.query.get_or_404(task_template_id)
    name = (request.form.get("name") or task_template.name or "").strip()
    description = (request.form.get("description") or task_template.description or "").strip()
    if not name:
        flash("Template name is required.", "error")
        return redirect(url_for("ni_settings", tab="project-templates"))

    new_template = ProjectTemplate(
        name=name,
        description=description or None,
        created_by=current_user.id
    )
    db.session.add(new_template)
    db.session.flush()

    try:
        blueprint = json.loads(task_template.blueprint_json or "[]")
    except json.JSONDecodeError:
        blueprint = []

    apply_blueprint_to_template(new_template, blueprint)
    db.session.commit()
    flash(f"Project template '{name}' created from task template.", "success")
    return redirect(url_for("project_template_detail", template_id=new_template.id))


@app.route("/project-templates/<int:template_id>/delete", methods=["POST"])
@login_required
def project_template_delete(template_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    if not (current_user.is_admin or template.created_by == current_user.id):
        flash("You do not have permission to delete this template.", "error")
        return redirect(url_for("ni_settings", tab="project-templates"))

    name = template.name or f'Template {template.id}'
    db.session.delete(template)
    db.session.commit()
    flash(f"Project template '{name}' deleted.", "success")
    return redirect(url_for("ni_settings", tab="project-templates"))



# ---- Template task management helpers ----
@app.route("/project-templates/<int:template_id>/tasks/<int:task_id>/edit", methods=["POST"])
@login_required
def project_template_task_edit(template_id, task_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    task = ProjectTemplateTask.query.filter_by(id=task_id, template_id=template.id).first()
    if not task:
        flash("Task not found for this template.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    task_module = (request.form.get("module") or request.form.get("task_type") or "general").lower()
    if task_module not in dict(PROJECT_TEMPLATE_TASK_MODULES):
        task_module = "general"
    subtype_choices = dict(PROJECT_TEMPLATE_TASK_SUBTYPES.get(task_module, []))
    task_subtype = (request.form.get("task_subtype") or "").lower()
    if task_subtype not in subtype_choices:
        task_subtype = next(iter(subtype_choices.keys()), "general")
    task_type = task_module
    name = (request.form.get("name") or "").strip()
    description = (request.form.get("description") or "").strip()
    requested_order = request.form.get("order_index", type=int)
    depends_on_ids = []
    for raw in request.form.getlist("depends_on_ids"):
        try:
            dep_id = int(raw)
        except (TypeError, ValueError):
            continue
        if dep_id not in depends_on_ids:
            depends_on_ids.append(dep_id)
    default_assignee_id = request.form.get("default_assignee_id", type=int)
    form_template_id = request.form.get("form_template_id", type=int)

    if not name:
        flash("Task name is required.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    if depends_on_ids:
        if task.id in depends_on_ids:
            flash("A task cannot depend on itself.", "error")
            return redirect(url_for("project_template_detail", template_id=template.id))
        dependencies = ProjectTemplateTask.query.filter(
            ProjectTemplateTask.template_id == template.id,
            ProjectTemplateTask.id.in_(depends_on_ids)
        ).all()
        valid_dependency_ids = {dep.id for dep in dependencies}
        depends_on_ids = [dep_id for dep_id in depends_on_ids if dep_id in valid_dependency_ids]

    if default_assignee_id:
        assignee_candidate = db.session.get(User, default_assignee_id)
        if not assignee_candidate or not assignee_candidate.can_be_assigned_module("operations"):
            flash("Choose a valid default assignee with Operations access.", "error")
            return redirect(url_for("project_template_detail", template_id=template.id))

    if form_template_id and not db.session.get(FormSchema, form_template_id):
        flash("Choose a valid form template.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    start_mode, planned_start_date, duration_value, milestone_value, timing_error = _extract_task_timing(request.form)
    if timing_error:
        flash(timing_error, "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    existing_tasks = ProjectTemplateTask.query.filter_by(template_id=template.id).order_by(
        ProjectTemplateTask.order_index.asc(),
        ProjectTemplateTask.id.asc()
    ).all()
    others = [t for t in existing_tasks if t.id != task.id]
    max_position = len(others) + 1
    if not requested_order or requested_order < 1:
        requested_order = max_position if task.order_index is None else min(task.order_index, max_position)
    else:
        requested_order = min(requested_order, max_position)

    for idx, existing in enumerate(others, start=1):
        new_index = idx if idx < requested_order else idx + 1
        existing.order_index = new_index

    task.name = name
    task.task_type = task_type
    task.module = task_module
    task.task_subtype = task_subtype
    task.description = description or None
    task.order_index = requested_order
    task.default_assignee_id = default_assignee_id
    task.form_template_id = form_template_id
    task.start_mode = start_mode
    task.planned_start_date = planned_start_date
    task.duration_days = duration_value
    task.milestone = milestone_value

    set_template_task_dependencies(task, depends_on_ids)

    normalize_template_task_order(template.id)
    db.session.commit()
    flash("Template task updated.", "success")
    return redirect(url_for("project_template_detail", template_id=template.id))


@app.route("/project-templates/<int:template_id>/tasks/<int:task_id>/delete", methods=["POST"])
@login_required
def project_template_task_delete(template_id, task_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    task = ProjectTemplateTask.query.filter_by(id=task_id, template_id=template.id).first()
    if not task:
        flash("Task not found for this template.", "error")
        return redirect(url_for("project_template_detail", template_id=template.id))

    ProjectTemplateTaskDependency.query.filter(
        or_(
            ProjectTemplateTaskDependency.task_id == task.id,
            ProjectTemplateTaskDependency.depends_on_id == task.id,
        )
    ).delete(synchronize_session=False)
    ProjectTemplateTask.query.filter_by(depends_on_id=task.id).update(
        {"depends_on_id": None},
        synchronize_session=False,
    )
    db.session.delete(task)
    normalize_template_task_order(template.id)
    db.session.commit()
    flash("Template task deleted.", "success")
    return redirect(url_for("project_template_detail", template_id=template.id))


@app.route("/project-templates/<int:template_id>/tasks/reorder", methods=["POST"])
@login_required
def project_template_task_reorder(template_id):
    _module_visibility_required("operations")
    template = ProjectTemplate.query.get_or_404(template_id)
    payload = request.get_json(silent=True) or {}
    ordered_ids = payload.get("ordered_ids")
    if not isinstance(ordered_ids, list) or not ordered_ids:
        return jsonify({"ok": False, "message": "No ordering received."}), 400

    try:
        ordered_ids = [int(task_id) for task_id in ordered_ids]
    except (TypeError, ValueError):
        return jsonify({"ok": False, "message": "Invalid task identifiers."}), 400

    template_task_ids = {task.id for task in template.tasks}
    if set(ordered_ids) != template_task_ids:
        return jsonify({"ok": False, "message": "Ordering must include all template tasks."}), 400

    tasks = {
        task.id: task for task in ProjectTemplateTask.query.filter(
            ProjectTemplateTask.template_id == template.id,
            ProjectTemplateTask.id.in_(ordered_ids)
        ).all()
    }

    if len(tasks) != len(ordered_ids):
        return jsonify({"ok": False, "message": "One or more tasks were not found."}), 400

    for idx, task_id in enumerate(ordered_ids, start=1):
        tasks[task_id].order_index = idx

    db.session.commit()
    return jsonify({"ok": True})


# ---------------------- CUSTOMER SUPPORT MODULE ----------------------
@app.route("/customer-support")
@login_required
def customer_support_home():
    _module_visibility_required("customer_support")
    summary = _customer_support_summary()
    counts = summary["counts"]
    recent_tickets = []
    for ticket in summary["recent"][:5]:
        recent_tickets.append(
            {
                **ticket,
                "created_display": ticket["created_at"].strftime("%d %b %Y · %I:%M %p"),
                "updated_display": (ticket.get("updated_at") or ticket["created_at"]).strftime("%d %b %Y · %I:%M %p"),
            }
        )

    kpis = [
        {"label": "Open", "value": counts.get("Open", 0), "tone": "rose"},
        {"label": "In Progress", "value": counts.get("In Progress", 0), "tone": "amber"},
        {"label": "Resolved", "value": counts.get("Resolved", 0), "tone": "emerald"},
        {"label": "Closed", "value": counts.get("Closed", 0), "tone": "sky"},
    ]

    return render_template(
        "customer_support_overview.html",
        kpis=kpis,
        total_tickets=summary["total"],
        recent_tickets=recent_tickets,
        categories=CUSTOMER_SUPPORT_CATEGORIES,
        channels=CUSTOMER_SUPPORT_CHANNELS,
    )


@app.route("/customer-support/overview")
@login_required
def customer_support_overview():
    _module_visibility_required("customer_support")
    return redirect(url_for("customer_support_home"))


@app.route("/customer-support/tasks", methods=["GET", "POST"])
@login_required
def customer_support_tasks():
    ticket_id = request.args.get("ticket")
    selected_ticket = _get_customer_support_ticket(ticket_id)

    # Allow the ticket owner to view the ticket modal even if their module
    # visibility has since been restricted.
    selected_ticket_assignee_id = None
    selected_ticket_owner_id = None
    if selected_ticket:
        assignee_user = _resolve_ticket_assignee_user(selected_ticket, module_key=None)
        if assignee_user:
            selected_ticket_assignee_id = assignee_user.id
        owner_user = _resolve_ticket_owner_user(selected_ticket, module_key=None)
        if owner_user:
            selected_ticket_owner_id = owner_user.id

    _module_visibility_required(
        "customer_support", owner_user_id=selected_ticket_assignee_id or selected_ticket_owner_id
    )
    add_ticket_form_data = {}
    add_ticket_errors = []
    open_add_ticket_modal = False

    if request.method == "POST":
        response = _handle_customer_support_ticket_creation()
        if isinstance(response, dict):
            add_ticket_errors = response.get("errors") or []
            add_ticket_form_data = response.get("form_values") or {}
            open_add_ticket_modal = True
        elif response is not None:
            return response

    if current_user.is_authenticated and "owner" not in add_ticket_form_data:
        add_ticket_form_data["owner"] = str(current_user.id)
    now = datetime.datetime.utcnow()
    tickets = []
    for ticket in CUSTOMER_SUPPORT_TICKETS:
        _resolve_ticket_assignee_user(ticket)
        _resolve_ticket_owner_user(ticket)
        if not ticket.get("owner"):
            ticket["owner"] = "Unassigned"
        sla_due_at = _calculate_ticket_sla_due(ticket)
        ticket["_sla_due_at"] = sla_due_at
        ticket["_sla_due_iso"] = sla_due_at.isoformat() if sla_due_at else ""
        ticket["_sla_due_display"] = sla_due_at.strftime("%d %b %Y %H:%M") if sla_due_at else "No SLA"
        ticket["_sla_seconds_remaining"] = (sla_due_at - now).total_seconds() if sla_due_at else None
        if _ticket_is_other_department(ticket):
            continue
        tickets.append(ticket)

    tickets.sort(key=lambda ticket: ticket.get("_sla_due_at") or datetime.datetime.max)
    ticket_open_task_map = {
        ticket.get("id"): _ticket_has_open_linked_tasks(ticket) for ticket in tickets
    }
    selected_ticket = selected_ticket or _get_customer_support_ticket(ticket_id)

    timeline = []
    attachments = []
    linked_tasks = []
    open_linked_task_modal = request.args.get("open_linked_task") == "1"
    ticket_first_update = None
    has_open_linked_tasks = False
    if selected_ticket:
        timeline = sorted(
            (
                apply_actor_context(event)
                for event in selected_ticket.get("timeline", [])
            ),
            key=lambda event: event.get("timestamp"),
            reverse=True,
        )
        attachments = selected_ticket.get("attachments", [])
        linked_tasks = selected_ticket.get("linked_tasks", [])
        if linked_tasks:
            has_open_linked_tasks = _ticket_has_open_linked_tasks(selected_ticket)

        timeline_chronological = sorted(
            (
                apply_actor_context(event)
                for event in selected_ticket.get("timeline", [])
            ),
            key=lambda event: event.get("timestamp"),
        )
        for entry in timeline_chronological:
            if entry.get("comment"):
                ticket_first_update = entry
                break
        if ticket_first_update is None and timeline_chronological:
            ticket_first_update = timeline_chronological[0]

    active_support_users = [
        user for user in get_assignable_users_for_module("customer_support") if user.is_active
    ]
    active_sales_users = [
        user for user in get_assignable_users_for_module("sales") if user.is_active
    ]

    support_settings = _load_customer_support_settings()
    category_assignments = support_settings.get("category_position_assignments") or {}
    assignee_whitelist = {}
    for category in CUSTOMER_SUPPORT_CATEGORIES:
        category_id = category.get("id")
        allowed_users = []
        for user in active_support_users:
            if _category_allows_user_assignment(
                category_id, user, settings=support_settings
            ):
                allowed_users.append(user.id)
        assignee_whitelist[category_id] = allowed_users

    sales_clients = (
        SalesClient.query.order_by(func.lower(func.coalesce(SalesClient.display_name, ""))).all()
    )
    installation_projects = Project.query.order_by(func.lower(Project.name)).all()
    amc_customers = (
        Customer.query.order_by(func.lower(func.coalesce(Customer.company_name, ""))).all()
    )

    return render_template(
        "customer_support_tasks.html",
        tickets=tickets,
        selected_ticket=selected_ticket,
        timeline=timeline,
        attachments=attachments,
        linked_tasks=linked_tasks,
        ticket_first_update=ticket_first_update,
        support_categories=CUSTOMER_SUPPORT_CATEGORIES,
        channels=CUSTOMER_SUPPORT_CHANNELS,
        sla_presets=CUSTOMER_SUPPORT_SLA_PRESETS,
        status_options=["Open", "In Progress", "Resolved", "Closed"],
        priority_options=["Low", "Medium", "High", "Critical"],
        open_ticket_modal=bool(selected_ticket),
        open_linked_task_modal=open_linked_task_modal,
        has_open_linked_tasks=has_open_linked_tasks,
        ticket_open_task_map=ticket_open_task_map,
        active_support_users=active_support_users,
        support_settings=support_settings,
        category_assignments=category_assignments,
        assignee_whitelist=assignee_whitelist,
        amc_lifts=_customer_support_amc_site_options(),
        add_ticket_form_data=add_ticket_form_data,
        add_ticket_errors=add_ticket_errors,
        open_add_ticket_modal=open_add_ticket_modal,
        sales_clients=sales_clients,
        installation_projects=installation_projects,
        amc_customers=amc_customers,
        active_sales_users=active_sales_users,
    )


@app.route("/customer-support/linked-tasks", methods=["POST"])
@login_required
def customer_support_create_linked_task():
    _module_visibility_required("customer_support")
    ticket_id = (request.form.get("ticket_id") or "").strip()
    if not ticket_id:
        flash("Select a ticket before creating a linked task.", "error")
        return redirect(url_for("customer_support_tasks"))

    ticket = _get_customer_support_ticket(ticket_id)
    if not ticket:
        flash("The referenced ticket could not be found.", "error")
        return redirect(url_for("customer_support_tasks"))

    support_settings = _load_customer_support_settings()

    title = (request.form.get("title") or "").strip()
    details = (request.form.get("details") or "").strip()
    owner_id_raw = (request.form.get("owner_id") or "").strip()
    assignee_id_raw = (request.form.get("assignee") or "").strip()
    due_date_raw = (request.form.get("due_date") or "").strip()
    task_url = (request.form.get("task_url") or "").strip()
    category = (request.form.get("category") or "").strip()
    priority = (request.form.get("priority") or "").strip()

    errors = []
    if not title:
        errors.append("Provide a title for the linked task.")

    due_date = None
    if due_date_raw:
        try:
            due_date = datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date()
        except ValueError:
            errors.append("Enter the due date in YYYY-MM-DD format.")

    owner_user = None
    assignee_user = None
    if assignee_id_raw:
        try:
            assignee_user = db.session.get(User, int(assignee_id_raw))
        except (TypeError, ValueError):
            assignee_user = None

        if not assignee_user:
            errors.append("Select a valid assignee for the linked task.")
        elif not assignee_user.is_active:
            errors.append("The selected assignee is not active on the portal.")
        elif not assignee_user.can_be_assigned_module("customer_support"):
            errors.append("The selected user cannot be assigned to customer support tasks.")
        elif not _category_allows_user_assignment(
            category, assignee_user, settings=support_settings
        ):
            errors.append(
                f"{assignee_user.display_name} cannot be assigned to this category based on CS settings."
            )

    if owner_id_raw:
        try:
            owner_user = db.session.get(User, int(owner_id_raw))
        except (TypeError, ValueError):
            owner_user = None

        if not owner_user:
            errors.append("Select a valid owner for the linked task.")
        elif not owner_user.is_active:
            errors.append("The selected owner is not active on the portal.")
        elif not owner_user.can_be_assigned_module("customer_support"):
            errors.append("The selected user cannot own customer support tasks.")

    if errors:
        for message in errors:
            flash(message, "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id, open_linked_task="1"))

    category_label = None
    if category:
        category_label = next((item.get("label") for item in CUSTOMER_SUPPORT_CATEGORIES if item.get("id") == category), None)

    assignee_label = assignee_user.display_name if assignee_user else "Unassigned"
    owner_label = owner_user.display_name if owner_user else (current_user.display_name if current_user.is_authenticated else "Unassigned")
    owner_id = owner_user.id if owner_user else (current_user.id if current_user.is_authenticated else None)

    created_enquiry = None
    if category and category.lower() == "sales-ni":
        try:
            created_enquiry = _create_enquiry_from_sales_ni_task(
                ticket=ticket,
                title=title,
                details=details,
                assignee_user=assignee_user,
                owner_user=owner_user,
            )
        except Exception as exc:
            app.logger.exception("Failed to create enquiry for Sales – NI task: %s", exc)
            flash(
                "Could not create the enquiry for this Sales – NI task. Please try again.",
                "error",
            )
            return redirect(url_for("customer_support_tasks", ticket=ticket_id, open_linked_task="1"))

    new_task = {
        "id": generate_linked_task_id(),
        "title": title,
        "owner": owner_label,
        "owner_id": owner_id,
        "assignee": assignee_label,
        "assignee_id": assignee_user.id if assignee_user else None,
        "status": "Open",
        "due_date": due_date,
        "details": details or None,
        "category": category_label or category or None,
        "priority": priority or "Medium",
        "created_at": datetime.datetime.utcnow(),
        "url": task_url or None,
    }

    if created_enquiry:
        new_task["linked_enquiry"] = {
            "id": created_enquiry.id,
            "title": created_enquiry.title,
            "url": url_for("sales_opportunity_detail", opportunity_id=created_enquiry.id),
        }

    ticket.setdefault("linked_tasks", []).append(new_task)
    if created_enquiry:
        db.session.commit()
    _save_customer_support_state()
    flash("Linked task created successfully.", "success")
    return redirect(url_for("customer_support_tasks", ticket=ticket_id))


@app.route("/customer-support/tickets/<ticket_id>/update", methods=["POST"])
@login_required
def customer_support_update_ticket(ticket_id):
    _module_visibility_required("customer_support")
    ticket = _get_customer_support_ticket(ticket_id)
    if not ticket:
        flash("The requested ticket could not be found.", "error")
        return redirect(url_for("customer_support_tasks"))

    support_settings = _load_customer_support_settings()
    status = (request.form.get("status") or ticket.get("status") or "Open").strip()
    priority = (request.form.get("priority") or ticket.get("priority") or "Medium").strip()
    owner_value = (request.form.get("owner") or "").strip()
    assignee_value = (request.form.get("assignee") or "").strip()
    closing_comment = (request.form.get("closing_comment") or "").strip()

    allowed_status = {"Open", "In Progress", "Resolved", "Closed"}
    allowed_priority = {"Low", "Medium", "High", "Critical"}
    errors = []
    if status not in allowed_status:
        errors.append("Choose a valid status for the ticket.")
    if priority not in allowed_priority:
        errors.append("Choose a valid priority for the ticket.")

    owner_user = None
    assignee_user = None
    new_assignee_label = "Unassigned"
    new_assignee_id = None
    current_assignee_label = ticket.get("assignee") or "Unassigned"
    current_assignee_id = ticket.get("assignee_user_id")
    owner_clear_requested = owner_value == ""
    if owner_value:
        try:
            owner_user_id = int(owner_value)
        except (TypeError, ValueError):
            owner_user_id = None
        if owner_user_id is None:
            errors.append("Select an owner from the available team members.")
        else:
            owner_user = User.query.get(owner_user_id)
            if not owner_user or not owner_user.is_active or not owner_user.can_be_assigned_module("customer_support"):
                errors.append("Select an owner from the available team members.")

    if assignee_value:
        try:
            assignee_user_id = int(assignee_value)
        except (TypeError, ValueError):
            assignee_user_id = None
        if assignee_user_id is None:
            if assignee_value == current_assignee_label:
                new_assignee_label = current_assignee_label
                new_assignee_id = current_assignee_id
            else:
                errors.append("Select an assignee from the available team members.")
        else:
            assignee_user = User.query.get(assignee_user_id)
            if (
                not assignee_user
                or not assignee_user.is_active
                or not assignee_user.can_be_assigned_module("customer_support")
            ):
                errors.append("Select an assignee from the available team members.")
            elif not _category_allows_user_assignment(
                ticket.get("category"), assignee_user, settings=support_settings
            ):
                errors.append(
                    f"{assignee_user.display_name} cannot be assigned to this category based on CS settings."
                )
            else:
                new_assignee_label = assignee_user.display_name
                new_assignee_id = assignee_user.id
    else:
        new_assignee_label = "Unassigned"
        new_assignee_id = None

    if errors:
        for message in errors:
            flash(message, "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    current_status = (ticket.get("status") or "").strip().lower()
    new_status = status.lower()
    requires_closing_comment = new_status in {"resolved", "closed"} and new_status != current_status

    if requires_closing_comment and _ticket_has_open_linked_tasks(ticket):
        flash("Resolve or close all linked tasks before marking the ticket resolved or closed.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    if requires_closing_comment and not closing_comment:
        flash("Add closing remarks before completing the ticket.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    changes = []
    if status != ticket.get("status"):
        changes.append(f"Status updated to {status}")
        ticket["status"] = status
    if priority != ticket.get("priority"):
        changes.append(f"Priority updated to {priority}")
        ticket["priority"] = priority
    if (
        new_assignee_label != current_assignee_label
        or (new_assignee_id or None) != (current_assignee_id or None)
    ):
        changes.append(f"Assigned to {new_assignee_label}")
        ticket["assignee"] = new_assignee_label
        ticket["assignee_user_id"] = new_assignee_id

    if owner_value or owner_clear_requested:
        new_owner_label = owner_user.display_name if owner_user else "Unassigned"
        new_owner_id = owner_user.id if owner_user else None
        if (
            new_owner_label != (ticket.get("owner") or "Unassigned")
            or (new_owner_id or None) != (ticket.get("owner_user_id") or None)
        ):
            changes.append(f"Owner updated to {new_owner_label}")
            ticket["owner"] = new_owner_label
            ticket["owner_user_id"] = new_owner_id

    if not changes:
        flash("No changes detected to update.", "info")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    ticket["updated_at"] = datetime.datetime.utcnow()
    actor_info = timeline_actor_context()
    ticket.setdefault("timeline", []).append(
        {
            "timestamp": datetime.datetime.utcnow(),
            "type": "status",
            "label": "Ticket details updated",
            "visibility": "internal",
            "detail": "; ".join(changes),
            **actor_info,
        }
    )

    if closing_comment:
        ticket.setdefault("timeline", []).append(
            {
                "timestamp": datetime.datetime.utcnow(),
                "type": "comment",
                "label": "Closing remarks",
                "visibility": "internal",
                "comment": closing_comment,
                **actor_info,
            }
        )

    _save_customer_support_state()
    flash("Ticket details updated successfully.", "success")
    return redirect(url_for("customer_support_tasks", ticket=ticket_id))


@app.route("/customer-support/tickets/<ticket_id>/resolve", methods=["POST"])
@login_required
def customer_support_mark_ticket_resolved(ticket_id):
    _module_visibility_required("customer_support")
    ticket = _get_customer_support_ticket(ticket_id)
    if not ticket:
        flash("The requested ticket could not be found.", "error")
        return redirect(url_for("customer_support_tasks"))

    closing_comment = (request.form.get("closing_comment") or "").strip()
    if not closing_comment:
        flash("Add closing remarks before completing the ticket.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    if _ticket_has_open_linked_tasks(ticket):
        flash("Resolve linked tasks before marking this ticket resolved.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    current_status = (ticket.get("status") or "").strip()
    now = datetime.datetime.utcnow()
    actor_info = timeline_actor_context()

    if current_status.lower() not in {"resolved", "closed"}:
        ticket["status"] = "Resolved"
        ticket["updated_at"] = now
        previous_label = current_status or "Open"
        ticket.setdefault("timeline", []).append(
            {
                "timestamp": now,
                "type": "status",
                "label": "Ticket marked resolved",
                "visibility": "internal",
                "detail": f"Status changed from {previous_label} to Resolved.",
                **actor_info,
            }
        )
    else:
        ticket["updated_at"] = now

    ticket.setdefault("timeline", []).append(
        {
            "timestamp": datetime.datetime.utcnow(),
            "type": "comment",
            "label": "Closing remarks",
            "visibility": "internal",
            "comment": closing_comment,
                **actor_info,
            }
        )

    _save_customer_support_state()
    flash(f"Ticket {ticket_id} marked as resolved.", "success")
    return redirect(url_for("customer_support_tasks"))


@app.route("/customer-support/tickets/<ticket_id>/delete", methods=["POST"])
@login_required
def customer_support_delete_ticket(ticket_id):
    _module_visibility_required("customer_support")
    if not current_user.is_admin:
        flash("You do not have permission to delete tickets.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    ticket = _get_customer_support_ticket(ticket_id)
    if not ticket:
        flash("The requested ticket could not be found.", "error")
        return redirect(url_for("customer_support_tasks"))

    CUSTOMER_SUPPORT_TICKETS[:] = [item for item in CUSTOMER_SUPPORT_TICKETS if item.get("id") != ticket_id]
    _save_customer_support_state()
    flash(f"Ticket {ticket_id} deleted successfully.", "success")
    return redirect(url_for("customer_support_tasks"))


@app.route("/customer-support/tickets/<ticket_id>/comment", methods=["POST"])
@login_required
def customer_support_post_update(ticket_id):
    _module_visibility_required("customer_support")
    ticket = _get_customer_support_ticket(ticket_id)
    if not ticket:
        flash("The requested ticket could not be found.", "error")
        return redirect(url_for("customer_support_tasks"))

    comment = (request.form.get("comment") or "").strip()
    is_external = request.form.get("is_external") == "1"
    uploaded_files = request.files.getlist("attachments") or []
    valid_files = [file for file in uploaded_files if file and file.filename]

    if not comment and not valid_files:
        flash("Add a comment or attach at least one file before posting the update.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    attachments_added = _save_customer_support_attachments(valid_files)

    if not comment and not attachments_added:
        flash("No valid attachments were uploaded.", "error")
        return redirect(url_for("customer_support_tasks", ticket=ticket_id))

    if attachments_added:
        ticket.setdefault("attachments", []).extend(attachments_added)

    actor_info = timeline_actor_context()
    visibility_label = "External update" if is_external else "Internal note"
    timeline_entry = {
        "timestamp": datetime.datetime.utcnow(),
        "type": "comment" if comment else "attachment",
        "label": visibility_label,
        "visibility": "external" if is_external else "internal",
    }
    timeline_entry.update(actor_info)

    if comment:
        timeline_entry["comment"] = comment

    if attachments_added:
        names = ", ".join(item["label"] for item in attachments_added)
        timeline_entry["detail"] = f"Uploaded: {names}"

    ticket.setdefault("timeline", []).append(timeline_entry)
    ticket["updated_at"] = datetime.datetime.utcnow()

    _save_customer_support_state()
    flash("Ticket update posted successfully.", "success")
    return redirect(url_for("customer_support_tasks", ticket=ticket_id))


@app.route("/customer-support/calls")
@login_required
def customer_support_calls():
    _module_visibility_required("customer_support")
    status_filter = request.args.get("status") or ""
    category_filter = request.args.get("category") or ""
    search_term = request.args.get("q") or ""

    call_logs = _customer_support_filter_calls(
        category=category_filter or None,
        status=status_filter or None,
        search=search_term or None,
    )

    return render_template(
        "customer_support_calls.html",
        call_logs=call_logs,
        status_filter=status_filter,
        category_filter=category_filter,
        search_term=search_term,
        status_options=["Open", "In Progress", "Resolved", "Closed"],
        categories=CUSTOMER_SUPPORT_CATEGORIES,
    )


@app.route("/customer-support/settings", methods=["GET", "POST"])
@login_required
def customer_support_settings():
    _module_visibility_required("customer_support")
    _require_admin()

    tab = (request.args.get("tab") or "assignments").lower()
    allowed_tabs = {"assignments", "configuration"}
    active_tab = tab if tab in allowed_tabs else "assignments"

    settings = _load_customer_support_settings()
    if request.method == "POST":
        updated = {
            "category_position_assignments": {},
        }

        for category in CUSTOMER_SUPPORT_CATEGORIES:
            field_name = f"category_positions_{category.get('id')}"
            updated["category_position_assignments"][category.get("id")] = request.form.getlist(
                field_name
            )

        _save_customer_support_settings(updated)
        flash("Customer Support settings saved.", "success")
        return redirect(url_for("customer_support_settings", tab=active_tab))

    positions = Position.query.options(joinedload(Position.department)).order_by(Position.title.asc()).all()
    positions = sorted(positions, key=lambda pos: (pos.display_label or "").lower())

    return render_template(
        "customer_support_settings.html",
        settings=settings,
        categories=CUSTOMER_SUPPORT_CATEGORIES,
        positions=positions,
        support_channels=CUSTOMER_SUPPORT_CHANNELS,
        support_sla_presets=CUSTOMER_SUPPORT_SLA_PRESETS,
        active_tab=active_tab,
    )


# ---------------------- SERVICE MODULE ----------------------


@app.route("/service/settings")
@login_required
def service_settings():
    _module_visibility_required("service")
    _require_admin()

    service_routes = ServiceRoute.query.order_by(
        func.lower(ServiceRoute.state), func.lower(ServiceRoute.branch)
    ).all()
    dropdown_options = get_dropdown_options_map()
    service_dropdown_groups = {
        category: {
            "label": label,
            "active": get_service_dropdown_options(category, active_only=True),
            "inactive": get_service_dropdown_options(category, active_only=False),
        }
        for category, label in SERVICE_DROPDOWN_CATEGORIES.items()
    }
    for group in service_dropdown_groups.values():
        group["inactive"] = [option for option in group["inactive"] if not option.is_active]

    return render_template(
        "service/service_settings.html",
        service_routes=service_routes,
        dropdown_options=dropdown_options,
        dropdown_meta=DROPDOWN_FIELD_DEFINITIONS,
        service_dropdown_groups=service_dropdown_groups,
    )


@app.route("/service/settings/dropdowns/add", methods=["POST"])
@login_required
def service_settings_dropdown_add():
    _module_visibility_required("service")
    _require_admin()

    def _redirect_with_open(category_key=None, *, focus_value=False):
        if category_key in SERVICE_DROPDOWN_CATEGORIES:
            redirect_url = url_for(
                "service_settings",
                open=category_key,
                focus="value" if focus_value else None,
            )
            return redirect(f"{redirect_url}#dropdown-{category_key}")
        return redirect(url_for("service_settings"))

    category = clean_str(request.form.get("category"))
    if category not in SERVICE_DROPDOWN_CATEGORIES:
        flash("Invalid dropdown category.", "error")
        return _redirect_with_open(category)

    value = clean_str(request.form.get("value"))
    if not value:
        flash("Option value is required.", "error")
        return _redirect_with_open(category)

    sort_order_raw = clean_str(request.form.get("sort_order"))
    try:
        sort_order = int(sort_order_raw) if sort_order_raw else None
    except (TypeError, ValueError):
        flash("Sort order must be a whole number.", "error")
        return _redirect_with_open(category)

    if sort_order is not None and sort_order < 1:
        flash("Sort order must be 1 or greater.", "error")
        return _redirect_with_open(category)

    existing = ServiceDropdownOption.query.filter(
        ServiceDropdownOption.category == category,
        func.lower(ServiceDropdownOption.value) == value.lower(),
    ).first()
    if existing:
        flash("That option already exists for this category.", "error")
        return _redirect_with_open(category)

    if sort_order is None:
        sort_order = _next_service_dropdown_sort_order(category)
    else:
        _shift_service_dropdown_sort_orders(category, sort_order)

    db.session.add(ServiceDropdownOption(category=category, value=value, sort_order=sort_order, is_active=True))
    db.session.commit()
    flash("Service dropdown option added.", "success")
    return _redirect_with_open(category, focus_value=True)


@app.route("/service/settings/dropdowns/toggle", methods=["POST"])
@login_required
def service_settings_dropdown_toggle():
    _module_visibility_required("service")
    _require_admin()

    category = clean_str(request.form.get("category"))
    if category not in SERVICE_DROPDOWN_CATEGORIES:
        flash("Invalid dropdown category.", "error")
        return redirect(url_for("service_settings"))

    option_id_raw = request.form.get("option_id")
    try:
        option_id = int(option_id_raw)
    except (TypeError, ValueError):
        flash("Invalid option selected.", "error")
        return redirect(url_for("service_settings"))

    option = db.session.get(ServiceDropdownOption, option_id)
    if not option or option.category != category:
        flash("Option not found.", "error")
        return redirect(url_for("service_settings"))

    option.is_active = not bool(option.is_active)
    db.session.commit()
    flash("Service dropdown option updated.", "success")
    return redirect(url_for("service_settings"))


@app.route("/service/settings/dropdowns/update", methods=["POST"])
@login_required
def service_settings_dropdown_update():
    _module_visibility_required("service")
    _require_admin()

    def _redirect_with_open(category_key):
        if category_key in SERVICE_DROPDOWN_CATEGORIES:
            redirect_url = url_for("service_settings", open=category_key)
            return redirect(f"{redirect_url}#dropdown-{category_key}")
        return redirect(url_for("service_settings"))

    option_id_raw = request.form.get("option_id")
    try:
        option_id = int(option_id_raw)
    except (TypeError, ValueError):
        flash("Invalid option selected.", "error")
        return redirect(url_for("service_settings"))

    option = db.session.get(ServiceDropdownOption, option_id)
    if not option or option.category not in SERVICE_DROPDOWN_CATEGORIES:
        flash("Option not found.", "error")
        return redirect(url_for("service_settings"))

    category = option.category

    value = clean_str(request.form.get("value"))
    if not value:
        flash("Option value is required.", "error")
        return _redirect_with_open(category)

    sort_order_raw = clean_str(request.form.get("sort_order"))
    try:
        sort_order = int(sort_order_raw) if sort_order_raw else None
    except (TypeError, ValueError):
        flash("Sort order must be a whole number.", "error")
        return _redirect_with_open(category)

    if sort_order is None:
        sort_order = _next_service_dropdown_sort_order(category)
    elif sort_order < 1:
        flash("Sort order must be 1 or greater.", "error")
        return _redirect_with_open(category)

    existing = ServiceDropdownOption.query.filter(
        ServiceDropdownOption.category == category,
        func.lower(ServiceDropdownOption.value) == value.lower(),
        ServiceDropdownOption.id != option.id,
    ).first()
    if existing:
        flash(
            f'"{value}" already exists in {SERVICE_DROPDOWN_CATEGORIES.get(category, "this category")}.',
            "error",
        )
        return _redirect_with_open(category)

    option.value = value
    if sort_order != option.sort_order:
        _shift_service_dropdown_sort_orders(category, sort_order, exclude_option_id=option.id)
    option.sort_order = sort_order
    db.session.commit()
    flash("Service dropdown option saved.", "success")
    return _redirect_with_open(category)


@app.route("/service/settings/dropdowns/reorder", methods=["POST"])
@login_required
def service_settings_dropdown_reorder():
    def _json_error(error_key, status_code=400):
        return jsonify({"ok": False, "error": error_key}), status_code

    if not current_user.can_view_module("service"):
        return _json_error("module-disabled", 403)

    if not current_user.is_admin:
        return _json_error("not-admin", 403)

    payload = request.get_json(silent=True) or {}
    category = clean_str(payload.get("category"))
    ordered_ids = payload.get("ordered_ids")
    if not isinstance(ordered_ids, list):
        ordered_ids = payload.get("order")

    if category not in SERVICE_DROPDOWN_CATEGORIES:
        return _json_error("invalid-category", 400)
    if not isinstance(ordered_ids, list):
        return _json_error("invalid-order", 400)

    normalized_ids = []
    seen = set()
    for raw_option_id in ordered_ids:
        try:
            option_id = int(raw_option_id)
        except (TypeError, ValueError):
            return _json_error("invalid-option-id", 400)
        if option_id in seen:
            continue
        seen.add(option_id)
        normalized_ids.append(option_id)

    all_options = ServiceDropdownOption.query.filter(ServiceDropdownOption.category == category).order_by(
        ServiceDropdownOption.sort_order.asc(), ServiceDropdownOption.id.asc()
    ).all()
    option_map = {option.id: option for option in all_options}

    if not normalized_ids:
        return _json_error("invalid-order", 400)

    category_ordered_ids = [option_id for option_id in normalized_ids if option_id in option_map]
    if not category_ordered_ids:
        return _json_error("invalid-order", 400)

    category_seen = set(category_ordered_ids)
    full_order = category_ordered_ids + [option.id for option in all_options if option.id not in category_seen]

    for index, option_id in enumerate(full_order, start=1):
        option_map[option_id].sort_order = index

    db.session.commit()
    return jsonify({"ok": True})


def _coerce_date(value):
    if isinstance(value, datetime.datetime):
        return value.date()
    if isinstance(value, datetime.date):
        return value
    if isinstance(value, str):
        cleaned = value.strip()
        if not cleaned:
            return None
        for fmt in (
            "%Y-%m-%d",
            "%Y/%m/%d",
            "%d-%m-%Y",
            "%d/%m/%Y",
            "%Y-%m-%dT%H:%M:%S",
            "%Y-%m-%dT%H:%M:%S.%f",
        ):
            try:
                return datetime.datetime.strptime(cleaned, fmt).date()
            except ValueError:
                continue
    return None


def _coerce_bool(value):
    if isinstance(value, bool):
        return value
    if isinstance(value, str):
        lowered = value.strip().lower()
        if lowered in {"yes", "true", "1"}:
            return True
        if lowered in {"no", "false", "0"}:
            return False
    return None


def _coerce_float(value):
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        cleaned = value.strip()
        if not cleaned:
            return None
        try:
            return float(cleaned)
        except ValueError:
            return None
    return None


def _coerce_minutes(value):
    if value in (None, ""):
        return None
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        cleaned = value.strip().lower()
        if not cleaned:
            return None
        time_match = re.match(r"^(-?\d+):(\d{1,2})$", cleaned)
        if time_match:
            hours_part = float(time_match.group(1))
            minutes_part = float(time_match.group(2))
            return hours_part * 60 + minutes_part
        hour_match = re.search(r"(-?\d+(?:\.\d+)?)\s*h", cleaned)
        minute_match = re.search(r"(-?\d+(?:\.\d+)?)\s*m", cleaned)
        total_minutes = 0.0
        matched = False
        if hour_match:
            total_minutes += float(hour_match.group(1)) * 60
            matched = True
        if minute_match:
            total_minutes += float(minute_match.group(1))
            matched = True
        if matched:
            return total_minutes
        for suffix in ("minutes", "minute", "mins", "min", "m"):
            if cleaned.endswith(suffix):
                cleaned = cleaned[: -len(suffix)].strip()
                break
        if cleaned.endswith("h"):
            try:
                return float(cleaned[:-1].strip()) * 60
            except ValueError:
                return None
        try:
            return float(cleaned)
        except ValueError:
            return None
    return None


def _create_service_visit_from_support_ticket(ticket: dict) -> None:
    """
    Create a service visit entry on the relevant Lift based on a newly created
    Customer Support ticket (typically breakdown / AMC complaints).

    Assumptions:
    - ticket is a dict from CUSTOMER_SUPPORT_TICKETS.
    - ticket["lift_id"] (or similar) links to a Lift row.
    - We do NOT commit outside this function; the caller will commit.
    """
    lift_id = ticket.get("lift_id") or ticket.get("linked_lift_id")
    if not lift_id:
        return

    try:
        lift_id = int(lift_id)
    except (TypeError, ValueError):
        return

    lift = db.session.get(Lift, lift_id)
    if not lift:
        return

    category_key = (ticket.get("category_key") or "").strip().lower()
    category_label = (ticket.get("category") or "").strip()

    creates_service_visit = False

    SERVICE_RELATED_CATEGORY_KEYS = {
        "support_amc",
        "support_non_amc",
        "breakdown",
        "complaint",
        "amc_complaint",
        "service_complaint",
    }

    if category_key and category_key in SERVICE_RELATED_CATEGORY_KEYS:
        creates_service_visit = True
    else:
        label_lower = category_label.lower()
        if any(word in label_lower for word in ("amc", "service", "breakdown", "complaint")):
            creates_service_visit = True

    if not creates_service_visit:
        return

    subject = (ticket.get("subject") or ticket.get("title") or "").strip()
    remarks = (ticket.get("remarks") or ticket.get("description") or "").strip()

    complaint_summary = subject
    if remarks:
        first_line = remarks.splitlines()[0]
        if first_line and first_line not in complaint_summary:
            if complaint_summary:
                complaint_summary = f"{complaint_summary} – {first_line}"
            else:
                complaint_summary = first_line

    ticket_ref = ticket.get("reference") or ticket.get("ticket_no") or ticket.get("id")
    ticket_ref_str = str(ticket_ref) if ticket_ref is not None else None

    today = datetime.date.today()

    schedule = lift.service_schedule or []

    for entry in schedule:
        entry_date = _coerce_date(entry.get("date"))
        source = (entry.get("source") or "").strip().lower()
        existing_ref = (
            str(entry.get("support_ticket_ref") or "")
            if entry.get("support_ticket_ref") is not None
            else ""
        )
        if (
            entry_date == today
            and source == "support_ticket"
            and ticket_ref_str
            and existing_ref == ticket_ref_str
        ):
            return

    visit_entry = {
        "date": today.isoformat(),
        "status": "scheduled",
        "source": "support_ticket",
        "support_ticket_ref": ticket_ref_str,
        "complaint_summary": complaint_summary,
        "checklist": category_label or "Breakdown visit",
        "technician": "",
        "created_at": datetime.datetime.utcnow().isoformat(),
    }

    schedule.append(visit_entry)
    lift.service_schedule = schedule


def _format_minutes_display(value):
    numeric = _coerce_float(value)
    if numeric is None:
        return "—"
    total_minutes = int(round(numeric))
    sign = "-" if total_minutes < 0 else ""
    minutes_abs = abs(total_minutes)
    hours, minutes = divmod(minutes_abs, 60)
    parts = []
    if hours:
        parts.append(f"{hours}h")
    if minutes or not parts:
        parts.append(f"{minutes}m")
    return sign + " ".join(parts)


def _format_percentage(numerator, denominator):
    if not denominator:
        return None
    try:
        ratio = (numerator / denominator) * 100
    except ZeroDivisionError:
        return None
    if ratio.is_integer():
        return f"{int(ratio)}%"
    return f"{ratio:.1f}%"


def _format_delta_label(delta_days):
    if delta_days == 0:
        return "Today"
    if delta_days == 1:
        return "Tomorrow"
    if delta_days > 1:
        return f"In {delta_days} days"
    if delta_days == -1:
        return "Yesterday"
    return f"{abs(delta_days)} days ago"


def get_service_schedule_snapshot():
    today = datetime.date.today()
    lifts = (
        Lift.query.options(
            load_only(
                Lift.id,
                Lift.lift_code,
                Lift.customer_code,
                Lift.route,
                Lift.city,
                Lift.service_schedule_json,
                Lift.next_service_due,
            ),
            joinedload(Lift.customer),
        )
        .filter(
            or_(
                Lift.service_schedule_json.isnot(None),
                Lift.next_service_due.isnot(None),
            )
        )
        .order_by(func.lower(Lift.lift_code))
        .all()
    )
    entries = []
    lifts_with_schedule = 0
    branches = set()
    for (raw_branch,) in (
        db.session.query(Lift.route)
        .filter(Lift.route.isnot(None), func.trim(Lift.route) != "")
        .distinct()
        .all()
    ):
        cleaned_branch = clean_str(raw_branch)
        if cleaned_branch:
            branches.add(cleaned_branch)

    for lift in lifts:
        branch_value = clean_str(lift.route)
        if branch_value:
            branches.add(branch_value)
        schedule = lift.service_schedule or []
        if schedule:
            lifts_with_schedule += 1
        for raw_entry in schedule:
            visit_date = _coerce_date(raw_entry.get("date"))
            status_value = clean_str(raw_entry.get("status")) or "scheduled"
            status_key = status_value.lower()
            if status_key not in SERVICE_VISIT_STATUS_LABELS:
                status_key = "scheduled"
            route_value = clean_str(raw_entry.get("route")) or clean_str(lift.route)
            technician = clean_str(raw_entry.get("technician"))
            complaint_summary = clean_str(raw_entry.get("complaint_summary")) or ""
            ticket_ref = raw_entry.get("support_ticket_ref")
            entries.append(
                {
                    "lift": lift,
                    "date": visit_date,
                    "status": status_key,
                    "route": route_value,
                    "technician": technician,
                    "first_time_fix": _coerce_bool(raw_entry.get("first_time_fix")),
                    "on_time": _coerce_bool(
                        raw_entry.get("on_time")
                        or raw_entry.get("on_time_completion")
                    ),
                    "travel_minutes": _coerce_minutes(
                        raw_entry.get("travel_minutes")
                        or raw_entry.get("travel_time")
                    ),
                    "repair_minutes": _coerce_minutes(
                        raw_entry.get("repair_minutes")
                        or raw_entry.get("duration_minutes")
                    ),
                    "rating": _coerce_float(raw_entry.get("rating")),
                    "checklist": clean_str(raw_entry.get("checklist")),
                    "complaint_summary": complaint_summary,
                    "support_ticket_ref": ticket_ref,
                }
            )

    return {
        "today": today,
        "lifts": lifts,
        "entries": entries,
        "branches": branches,
        "lifts_with_schedule": lifts_with_schedule,
        "total_lifts": db.session.query(func.count(Lift.id)).scalar() or 0,
    }


def build_service_overview_payload():
    snapshot = get_service_schedule_snapshot()
    entries = snapshot["entries"]
    lifts = snapshot["lifts"]
    today = snapshot["today"]
    total_lifts = snapshot.get("total_lifts") or len(lifts)

    status_counts = Counter()
    technicians_assigned = set()
    branches = snapshot.get("branches", set())

    def _initial_tech_stats():
        return {
            "name": "Unassigned",
            "open": 0,
            "completed": 0,
            "overdue": 0,
            "first_time_fix_total": 0,
            "first_time_fix_success": 0,
            "on_time_total": 0,
            "on_time_success": 0,
            "travel_minutes_total": 0.0,
            "travel_entries": 0,
            "repair_minutes_total": 0.0,
            "repair_entries": 0,
            "ratings": [],
        }

    technician_stats = defaultdict(_initial_tech_stats)

    overall_completed_this_month = 0
    overall_first_time_fix_total = 0
    overall_first_time_fix_success = 0
    overall_on_time_total = 0
    overall_on_time_success = 0

    for entry in entries:
        status_counts[entry["status"]] += 1
        if entry["technician"]:
            technicians_assigned.add(entry["technician"])
        entry["is_overdue"] = (
            entry["status"] == "overdue"
            or (
                entry["status"] != "completed"
                and isinstance(entry.get("date"), datetime.date)
                and entry["date"] < today
            )
        )
        if (
            entry["status"] == "completed"
            and isinstance(entry.get("date"), datetime.date)
            and entry["date"].year == today.year
            and entry["date"].month == today.month
        ):
            overall_completed_this_month += 1
        if entry["status"] == "completed" and entry["first_time_fix"] is not None:
            overall_first_time_fix_total += 1
            if entry["first_time_fix"]:
                overall_first_time_fix_success += 1
        if entry["status"] == "completed" and entry["on_time"] is not None:
            overall_on_time_total += 1
            if entry["on_time"]:
                overall_on_time_success += 1

        stat_key = entry["technician"] or "__unassigned__"
        stat = technician_stats[stat_key]
        stat["name"] = entry["technician"] or "Unassigned"
        if entry["status"] == "completed":
            stat["completed"] += 1
        else:
            stat["open"] += 1
        if entry["is_overdue"]:
            stat["overdue"] += 1
        if entry["status"] == "completed" and entry["first_time_fix"] is not None:
            stat["first_time_fix_total"] += 1
            if entry["first_time_fix"]:
                stat["first_time_fix_success"] += 1
        if entry["status"] == "completed" and entry["on_time"] is not None:
            stat["on_time_total"] += 1
            if entry["on_time"]:
                stat["on_time_success"] += 1
        if entry["travel_minutes"] is not None:
            stat["travel_minutes_total"] += entry["travel_minutes"]
            stat["travel_entries"] += 1
        if entry["repair_minutes"] is not None:
            stat["repair_minutes_total"] += entry["repair_minutes"]
            stat["repair_entries"] += 1
        if entry["rating"] is not None:
            stat["ratings"].append(entry["rating"])

    open_entries = [entry for entry in entries if entry["status"] != "completed"]
    open_count = len(open_entries)
    overdue_count = sum(1 for entry in entries if entry.get("is_overdue"))
    unassigned_stats = technician_stats.get("__unassigned__")
    unassigned_open = unassigned_stats["open"] if unassigned_stats else 0

    lifts_without_schedule = max(
        total_lifts - snapshot.get("lifts_with_schedule", 0), 0
    )

    amc_dates_recorded = (
        db.session.query(func.count(Lift.id))
        .filter(Lift.amc_end.isnot(None))
        .scalar()
        or 0
    )
    amc_due_within_30 = (
        db.session.query(func.count(Lift.id))
        .filter(
            Lift.amc_end.isnot(None),
            Lift.amc_end >= today,
            Lift.amc_end <= today + datetime.timedelta(days=30),
        )
        .scalar()
        or 0
    )

    first_time_fix_display = _format_percentage(
        overall_first_time_fix_success,
        overall_first_time_fix_total,
    )
    first_time_fix_rate_value = None
    if first_time_fix_display:
        first_time_fix_rate_value = (
            (overall_first_time_fix_success / overall_first_time_fix_total) * 100
            if overall_first_time_fix_total
            else None
        )

    on_time_display = _format_percentage(
        overall_on_time_success, overall_on_time_total
    )
    on_time_rate_value = None
    if on_time_display:
        on_time_rate_value = (
            (overall_on_time_success / overall_on_time_total) * 100
            if overall_on_time_total
            else None
        )

    kpis = []
    kpis.append(
        {
            "label": "Open service visits",
            "value": str(open_count),
            "descriptor": (
                "Visits awaiting completion"
                if entries
                else "Add service schedule entries on lifts to start tracking workload."
            ),
            "tone": "emerald" if open_count == 0 else "amber",
        }
    )
    kpis.append(
        {
            "label": "Overdue visits",
            "value": str(overdue_count),
            "descriptor": (
                "Past-due or marked overdue visits"
                if entries
                else "Overdue metrics appear once visits are scheduled."
            ),
            "tone": "emerald" if overdue_count == 0 else "rose",
        }
    )
    kpis.append(
        {
            "label": "Visits completed this month",
            "value": str(overall_completed_this_month),
            "descriptor": (
                f"{today.strftime('%b %Y')} closures"
                if overall_completed_this_month
                else "Complete a visit to track monthly closures."
            ),
            "tone": "emerald" if overall_completed_this_month else "slate",
        }
    )
    kpis.append(
        {
            "label": "AMC renewals due (30 days)",
            "value": str(amc_due_within_30),
            "descriptor": (
                f"Across {amc_dates_recorded} lifts with AMC end dates"
                if amc_dates_recorded
                else "Capture AMC end dates on lifts to monitor renewals."
            ),
            "tone": (
                "slate"
                if not amc_dates_recorded
                else ("amber" if amc_due_within_30 else "emerald")
            ),
        }
    )
    kpis.append(
        {
            "label": "Lifts without schedule",
            "value": str(max(lifts_without_schedule, 0)),
            "descriptor": (
                "Lifts without any recorded service visits"
                if lifts
                else "Add lifts to begin tracking service schedules."
            ),
            "tone": (
                "slate"
                if not lifts
                else ("rose" if lifts_without_schedule else "emerald")
            ),
        }
    )
    kpis.append(
        {
            "label": "First-time-fix rate",
            "value": first_time_fix_display or "—",
            "descriptor": (
                f"Based on {overall_first_time_fix_total} completed visits"
                if first_time_fix_display
                else "Record first-time-fix outcome on completed visits to populate this metric."
            ),
            "tone": (
                "slate"
                if not first_time_fix_display
                else ("emerald" if first_time_fix_rate_value and first_time_fix_rate_value >= 90 else "amber")
            ),
        }
    )
    kpis.append(
        {
            "label": "On-time completion",
            "value": on_time_display or "—",
            "descriptor": (
                f"Across {overall_on_time_total} completed visits"
                if on_time_display
                else "Capture on-time status when closing visits to see this KPI."
            ),
            "tone": (
                "slate"
                if not on_time_display
                else ("emerald" if on_time_rate_value and on_time_rate_value >= 90 else "amber")
            ),
        }
    )
    if unassigned_open:
        kpis.append(
            {
                "label": "Unassigned visits",
                "value": str(unassigned_open),
                "descriptor": "Assign technicians to clear these visits from the queue.",
                "tone": "rose",
            }
        )

    calendar_candidates = [
        entry
        for entry in entries
        if entry["status"] != "completed" and isinstance(entry.get("date"), datetime.date)
    ]
    calendar_candidates.sort(key=lambda item: item["date"])
    calendar_items = []
    for entry in calendar_candidates:
        lift = entry["lift"]
        label_bits = []
        if lift.customer and lift.customer.company_name:
            label_bits.append(lift.customer.company_name)
        if lift.lift_code:
            label_bits.append(lift.lift_code)
        label = " · ".join(label_bits) or (lift.lift_code or f"Lift #{lift.id}")
        delta_days = (entry["date"] - today).days
        calendar_items.append(
            {
                "label": label,
                "type": "Overdue" if entry.get("is_overdue") else "Scheduled",
                "date": entry["date"].strftime("%d %b %Y"),
                "delta": _format_delta_label(delta_days),
            }
        )

    if entries and not calendar_items:
        calendar_empty_message = "All tracked visits are completed."
    elif not entries:
        calendar_empty_message = "Add service visits to lifts to build the preventive calendar."
    else:
        calendar_empty_message = "No upcoming visits logged."

    filters = []
    for branch in sorted(branches):
        filters.append(f"Branch · {branch}")
    for technician in sorted(technicians_assigned):
        filters.append(f"Technician · {technician}")
    if not filters:
        filters.append("Add branches and technician assignments to unlock filters.")
    filters = filters[:8]

    chart_sets = {
        "complaints_by_category": [],
        "tasks_by_status": [],
        "parts_consumption": [],
        "technician_workload": [],
    }
    chart_notes = {
        "complaints_by_category": "Log support tickets with categories to populate this chart.",
        "tasks_by_status": "Add service visits to lifts to see task status distribution.",
        "parts_consumption": "Capture parts usage on service tasks to view monthly consumption.",
        "technician_workload": "Assign technicians to service visits to see workload split.",
    }

    category_counts = Counter()
    for ticket in _filter_other_department_records(CUSTOMER_SUPPORT_TICKETS):
        category_value = clean_str(ticket.get("category")) or "Uncategorised"
        category_counts[category_value] += 1
    if category_counts:
        chart_sets["complaints_by_category"] = [
            {"label": label, "value": count}
            for label, count in category_counts.most_common()
        ]
        chart_notes["complaints_by_category"] = ""

    status_items = []
    for status_key in ("scheduled", "completed", "overdue"):
        count = status_counts.get(status_key, 0)
        if count:
            status_label = SERVICE_VISIT_STATUS_LABELS.get(status_key, status_key.title())
            status_items.append({"label": status_label, "value": count})
    if status_items:
        chart_sets["tasks_by_status"] = status_items
        chart_notes["tasks_by_status"] = ""

    workload_items = []
    for stat in technician_stats.values():
        if stat["open"] > 0:
            workload_items.append({"label": stat["name"], "value": stat["open"]})
    if workload_items:
        chart_sets["technician_workload"] = sorted(
            workload_items, key=lambda item: item["value"], reverse=True
        )
        chart_notes["technician_workload"] = ""

    technician_cards = []
    for key, stat in technician_stats.items():
        total_handled = stat["completed"] + stat["open"]
        if key == "__unassigned__" or total_handled == 0:
            continue
        first_time_fix_stat = _format_percentage(
            stat["first_time_fix_success"], stat["first_time_fix_total"]
        )
        on_time_stat = _format_percentage(
            stat["on_time_success"], stat["on_time_total"]
        )
        travel_average = (
            stat["travel_minutes_total"] / stat["travel_entries"]
            if stat["travel_entries"]
            else None
        )
        repair_average = (
            stat["repair_minutes_total"] / stat["repair_entries"]
            if stat["repair_entries"]
            else None
        )
        if stat["ratings"]:
            rating_value = sum(stat["ratings"]) / len(stat["ratings"])
            rating_display = f"{rating_value:.1f}".rstrip("0").rstrip(".")
        else:
            rating_value = None
            rating_display = "—"
        notes = []
        if stat["completed"] == 0:
            notes.append(
                "Complete visits assigned to this technician to track closure metrics."
            )
        if stat["first_time_fix_total"] == 0:
            notes.append("Record first-time-fix outcome on completed visits.")
        if stat["on_time_total"] == 0:
            notes.append("Capture on-time status when closing visits.")
        if stat["travel_entries"] == 0:
            notes.append("Log travel time against visits to compute averages.")
        if stat["repair_entries"] == 0:
            notes.append("Log repair duration to compute averages.")
        if not stat["ratings"]:
            notes.append("Collect customer feedback ratings to track satisfaction.")
        technician_cards.append(
            {
                "name": stat["name"],
                "tasks_closed": stat["completed"],
                "first_time_fix_rate": first_time_fix_stat or "—",
                "on_time": on_time_stat or "—",
                "travel_time": _format_minutes_display(travel_average),
                "repair_time": _format_minutes_display(repair_average),
                "rating_display": rating_display,
                "rating_value": rating_value,
                "rating_stars": int(round(rating_value)) if rating_value is not None else 0,
                "rating_note": None if rating_value is not None else "No rating captured yet.",
                "notes": " • ".join(notes),
            }
        )

    technician_cards.sort(key=lambda item: item["tasks_closed"], reverse=True)
    technician_empty_message = (
        "Assign technicians to service visits to populate performance metrics."
        if not technician_cards
        else ""
    )

    return {
        "kpis": kpis,
        "chart_sets": chart_sets,
        "chart_notes": chart_notes,
        "calendar_items": calendar_items,
        "calendar_empty_message": calendar_empty_message,
        "filters": filters,
        "technicians": technician_cards,
        "technician_empty_message": technician_empty_message,
    }


@app.route("/service")
@login_required
def service_home():
    _module_visibility_required("service")
    payload = build_service_overview_payload()
    return render_template("service/overview.html", **payload)


@app.route("/service/overview")
@login_required
def service_overview():
    _module_visibility_required("service")
    return redirect(url_for("service_home"))


SERVICE_TASK_PRIORITY_OPTIONS = ["Low", "Medium", "High", "Urgent"]
SERVICE_TASK_STATUS_OPTIONS = ["Open", "In progress", "Waiting", "Completed", "Closed"]
SERVICE_TASK_CALL_TYPE_OPTIONS = ["Complaint", "AMC", "Repair", "Install Support"]


def _parse_json_list(value):
    if not value:
        return []
    try:
        parsed = json.loads(value)
    except (TypeError, ValueError):
        return []
    return parsed if isinstance(parsed, list) else []


def _service_task_worklog_entries(task):
    entries = []
    for raw_line in (task.worklog or "").splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if " - " in line:
            stamp, label = line.split(" - ", 1)
            entries.append({"time": stamp.strip(), "label": label.strip()})
        else:
            entries.append({"time": "", "label": line})
    return entries


def _service_task_payload(task):
    assigned_techs = [str(item).strip() for item in _parse_json_list(task.assigned_techs_json) if str(item).strip()]
    parts_used = []
    for item in _parse_json_list(task.parts_used_json):
        if not isinstance(item, dict):
            continue
        part_name = clean_str(item.get("part_name") or item.get("name"))
        qty = clean_str(item.get("qty"))
        notes = clean_str(item.get("notes"))
        if not part_name:
            continue
        parts_used.append({"name": part_name, "qty": qty or "1", "notes": notes})

    return {
        "id": task.id,
        "task_code": task.task_code,
        "site": task.site or "Site not specified",
        "client": task.customer.company_name if task.customer else "Customer pending",
        "lift_id": task.lift.lift_code if task.lift else "—",
        "call_type": task.call_type or "Complaint",
        "priority": task.priority or "Medium",
        "owner_display": task.owner_user.display_name if task.owner_user else "Unassigned",
        "technician_display": ", ".join(assigned_techs) if assigned_techs else "Unassigned",
        "status": task.status or "Open",
        "worklog": _service_task_worklog_entries(task),
        "parts_used": parts_used,
        "requires_media": bool(task.requires_media),
        "requires_media_label": "Photos mandatory" if task.requires_media else "Flexible",
        "created_at": task.created_at,
        "closed_at": task.closed_at,
        "model": task,
    }


def _next_service_task_code(task_id):
    return f"CS-{1000 + int(task_id)}"


@app.route("/service/tasks")
@login_required
def service_tasks():
    _module_visibility_required("service")
    tasks = (
        ServiceTask.query.options(
            joinedload(ServiceTask.customer),
            joinedload(ServiceTask.lift),
            joinedload(ServiceTask.owner_user),
        )
        .order_by(ServiceTask.created_at.desc(), ServiceTask.id.desc())
        .all()
    )
    return render_template(
        "service/tasks.html",
        tasks=[_service_task_payload(task) for task in tasks],
        customers=Customer.query.order_by(func.lower(Customer.company_name)).all(),
        lifts=Lift.query.order_by(func.lower(Lift.lift_code)).limit(200).all(),
        users=User.query.filter(User.active.is_(True)).order_by(func.lower(User.username)).all(),
        call_types=SERVICE_TASK_CALL_TYPE_OPTIONS,
        priority_options=SERVICE_TASK_PRIORITY_OPTIONS,
    )


@app.route("/service/tasks/create", methods=["POST"])
@login_required
def service_task_create():
    _module_visibility_required("service")

    site = clean_str(request.form.get("site"))
    call_type = clean_str(request.form.get("call_type")) or "Complaint"
    priority = clean_str(request.form.get("priority")) or "Medium"

    if not site:
        flash("Site is required to create a service task.", "error")
        return redirect(url_for("service_tasks"))

    if priority not in SERVICE_TASK_PRIORITY_OPTIONS:
        priority = "Medium"

    customer_id = _parse_optional_int(request.form.get("customer_id"))
    lift_id = _parse_optional_int(request.form.get("lift_id"))

    assigned_raw = clean_str(request.form.get("assigned_techs"))
    assigned_techs = [item.strip() for item in (assigned_raw or "").split(",") if item.strip()]

    task = ServiceTask(
        task_code=f"CS-TEMP-{uuid.uuid4().hex[:6]}",
        customer_id=customer_id,
        lift_id=lift_id,
        site=site,
        call_type=call_type,
        priority=priority,
        owner_user_id=current_user.id,
        assigned_techs_json=json.dumps(assigned_techs),
        status="Open",
        worklog="",
        parts_used_json="[]",
        requires_media=_parse_bool_payload(request.form.get("requires_media"), default=False),
    )
    db.session.add(task)
    db.session.flush()
    task.task_code = _next_service_task_code(task.id)
    db.session.commit()

    flash(f"Service task {task.task_code} created.", "success")
    return redirect(url_for("service_task_detail", task_id=task.id))


@app.route("/service/tasks/<int:task_id>")
@login_required
def service_task_detail(task_id):
    _module_visibility_required("service")
    task = ServiceTask.query.options(
        joinedload(ServiceTask.customer),
        joinedload(ServiceTask.lift),
        joinedload(ServiceTask.owner_user),
    ).get_or_404(task_id)

    return render_template(
        "service/task_detail.html",
        task=_service_task_payload(task),
        priority_options=SERVICE_TASK_PRIORITY_OPTIONS,
        status_options=SERVICE_TASK_STATUS_OPTIONS,
    )


@app.route("/service/tasks/<int:task_id>/update", methods=["POST"])
@login_required
def service_task_update(task_id):
    _module_visibility_required("service")
    task = ServiceTask.query.get_or_404(task_id)

    priority = clean_str(request.form.get("priority"))
    status = clean_str(request.form.get("status"))
    note = clean_str(request.form.get("worklog_note"))

    if priority in SERVICE_TASK_PRIORITY_OPTIONS:
        task.priority = priority
    if status in SERVICE_TASK_STATUS_OPTIONS:
        task.status = status
        if status == "Closed" and not task.closed_at:
            task.closed_at = datetime.datetime.utcnow()
    if note:
        stamp = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M")
        existing = (task.worklog or "").strip()
        line = f"{stamp} - {note}"
        task.worklog = f"{existing}\n{line}" if existing else line

    db.session.commit()
    flash("Service task updated.", "success")
    return redirect(url_for("service_task_detail", task_id=task.id))


@app.route("/service/tasks/<int:task_id>/parts", methods=["POST"])
@login_required
def service_task_parts(task_id):
    _module_visibility_required("service")
    task = ServiceTask.query.get_or_404(task_id)

    part_name = clean_str(request.form.get("part_name"))
    qty = clean_str(request.form.get("qty")) or "1"
    notes = clean_str(request.form.get("notes"))

    if not part_name:
        flash("Part name is required.", "error")
        return redirect(url_for("service_task_detail", task_id=task.id))

    parts = _parse_json_list(task.parts_used_json)
    parts.append({"part_name": part_name, "qty": qty, "notes": notes})
    task.parts_used_json = json.dumps(parts)
    db.session.commit()

    flash("Part usage added.", "success")
    return redirect(url_for("service_task_detail", task_id=task.id))


@app.route("/service/tasks/<int:task_id>/close", methods=["POST"])
@login_required
def service_task_close(task_id):
    _module_visibility_required("service")
    task = ServiceTask.query.get_or_404(task_id)
    task.status = "Closed"
    task.closed_at = datetime.datetime.utcnow()
    db.session.commit()
    flash(f"{task.task_code} was closed.", "success")
    return redirect(url_for("service_task_detail", task_id=task.id))


@app.route("/service/customers")
@login_required
def service_customers():
    _module_visibility_required("service")
    search_query = (request.args.get("q") or "").strip()

    query = _customer_query_for_export(search_query)
    query = query.options(joinedload(Customer.lifts))

    customers = query.all()
    for customer in customers:
        open_lifts = [lift for lift in customer.lifts if is_lift_open(lift)]
        customer.open_lifts = open_lifts
    next_customer_code = generate_next_customer_code()
    return render_template(
        "service/customers.html",
        customers=customers,
        search_query=search_query,
        next_customer_code=next_customer_code,
    )


@app.route("/service/customers/export")
@login_required
def service_customers_export():
    _module_visibility_required("service")
    if not current_user.is_admin:
        abort(403)

    search_query = (request.args.get("q") or "").strip()
    customers = _customer_query_for_export(search_query).all()

    timestamp = datetime.datetime.utcnow().strftime("%Y%m%d")
    filename = f"customers_export_{timestamp}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_customer_export_workbook(customers)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_rows = [_customer_upload_row(customer) for customer in customers]
    csv_output = _build_csv_output(CUSTOMER_UPLOAD_TEMPLATE_HEADERS, csv_rows)
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/service/lifts/export")
@login_required
def service_lifts_export():
    _module_visibility_required("service")
    if not current_user.is_admin:
        abort(403)

    search_query = (request.args.get("q") or "").strip()
    query = Lift.query.options(joinedload(Lift.customer))

    if search_query:
        like = f"%{search_query.lower()}%"
        query = query.filter(
            or_(
                func.lower(Lift.lift_code).like(like),
                func.lower(Lift.customer_code).like(like),
                func.lower(Lift.city).like(like),
                func.lower(Lift.state).like(like),
                func.lower(Lift.route).like(like),
                func.lower(Lift.lift_type).like(like),
                func.lower(Lift.lift_brand).like(like),
                func.lower(Lift.status).like(like),
            )
        )

    lifts = query.order_by(func.lower(Lift.lift_code)).all()

    timestamp = datetime.datetime.utcnow().strftime("%Y%m%d")
    filename = f"lifts_export_{timestamp}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_lift_export_workbook(lifts)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_rows = [_lift_export_row(lift) for lift in lifts]
    csv_output = _build_csv_output(AMC_LIFT_TEMPLATE_HEADERS, csv_rows)
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/service/customers/create", methods=["POST"])
@login_required
def service_customers_create():
    _module_visibility_required("service")

    redirect_url = request.form.get("next") or url_for("service_customers")

    customer_code = generate_next_customer_code()
    company_name = clean_str(request.form.get("company_name"))
    category_value = clean_str(request.form.get("category"))
    branch_value, branch_error = validate_branch(request.form.get("branch"))
    if branch_error:
        flash(branch_error, "error")
        return redirect(redirect_url)

    if not company_name:
        flash("Company name is required.", "error")
        return redirect(redirect_url)

    existing = Customer.query.filter(func.lower(Customer.customer_code) == customer_code.lower()).first()
    if existing:
        flash("Another customer already uses that customer code. Please try again.", "error")
        return redirect(redirect_url)

    customer = Customer(
        customer_code=customer_code,
        company_name=company_name,
        contact_person=clean_str(request.form.get("contact_person")),
        phone=clean_str(request.form.get("phone")),
        mobile=clean_str(request.form.get("mobile")),
        email=clean_str(request.form.get("email")),
        gst_no=clean_str(request.form.get("gst_no")),
        billing_address_line1=clean_str(request.form.get("billing_address_line1")),
        billing_address_line2=clean_str(request.form.get("billing_address_line2")),
        city=clean_str(request.form.get("city")),
        state=clean_str(request.form.get("state")),
        pincode=clean_str(request.form.get("pincode")),
        country="India",
        sector=category_value,
        branch=branch_value,
        notes=clean_str(request.form.get("notes")),
        office_address_line1=clean_str(request.form.get("office_address_line1")),
        office_address_line2=clean_str(request.form.get("office_address_line2")),
        office_city=clean_str(request.form.get("office_city")),
        office_state=clean_str(request.form.get("office_state")),
        office_pincode=clean_str(request.form.get("office_pincode")),
        office_country="India",
    )

    db.session.add(customer)
    db.session.commit()

    flash(f"Customer {customer.customer_code} created.", "success")
    return redirect(redirect_url)


@app.route("/service/customers/<int:customer_id>")
@login_required
def service_customer_detail(customer_id):
    _module_visibility_required("service")

    customer = db.session.get(Customer, customer_id)
    if not customer:
        flash("Customer not found.", "error")
        return redirect(url_for("service_customers"))

    lifts = (
        Lift.query.filter_by(customer_code=customer.customer_code)
        .order_by(func.lower(Lift.lift_code))
        .options(joinedload(Lift.customer))
        .all()
    )

    customer.open_lifts = [lift for lift in lifts if is_lift_open(lift)]
    comments = (
        CustomerComment.query.filter_by(customer_id=customer.id)
        .order_by(CustomerComment.created_at.desc())
        .all()
    )
    return render_template(
        "service/customer_detail.html",
        customer=customer,
        lifts=lifts,
        comments=comments,
    )


@app.route("/service/customers/<int:customer_id>/update", methods=["POST"])
@login_required
def service_customer_update(customer_id):
    _module_visibility_required("service")

    customer = db.session.get(Customer, customer_id)
    if not customer:
        flash("Customer not found.", "error")
        return redirect(url_for("service_customers"))

    company_name = clean_str(request.form.get("company_name"))
    category_value = clean_str(request.form.get("category"))
    branch_value, branch_error = validate_branch(request.form.get("branch"))
    if branch_error:
        flash(branch_error, "error")
        return redirect(url_for("service_customer_detail", customer_id=customer.id))

    if not company_name:
        flash("Company name is required.", "error")
        return redirect(url_for("service_customer_detail", customer_id=customer.id))

    customer.company_name = company_name
    customer.contact_person = clean_str(request.form.get("contact_person"))
    customer.phone = clean_str(request.form.get("phone"))
    customer.mobile = clean_str(request.form.get("mobile"))
    customer.email = clean_str(request.form.get("email"))
    customer.gst_no = clean_str(request.form.get("gst_no"))
    customer.sector = category_value
    customer.branch = branch_value
    customer.notes = clean_str(request.form.get("notes"))

    db.session.commit()

    flash("Customer updated.", "success")
    return redirect(url_for("service_customer_detail", customer_id=customer.id))


@app.route("/service/customers/<int:customer_id>/address", methods=["POST"])
@login_required
def service_customer_update_address(customer_id):
    _module_visibility_required("service")

    customer = db.session.get(Customer, customer_id)
    if not customer:
        flash("Customer not found.", "error")
        return redirect(url_for("service_customers"))

    address_type = (request.form.get("address_type") or "").strip().lower()
    redirect_url = url_for("service_customer_detail", customer_id=customer.id)

    if address_type == "billing":
        customer.billing_address_line1 = clean_str(request.form.get("billing_address_line1"))
        customer.billing_address_line2 = clean_str(request.form.get("billing_address_line2"))
        customer.city = clean_str(request.form.get("city"))
        customer.state = clean_str(request.form.get("state"))
        customer.pincode = clean_str(request.form.get("pincode"))
        customer.country = "India"
        success_message = "Billing address updated."
    elif address_type == "office":
        customer.office_address_line1 = clean_str(request.form.get("office_address_line1"))
        customer.office_address_line2 = clean_str(request.form.get("office_address_line2"))
        customer.office_city = clean_str(request.form.get("office_city"))
        customer.office_state = clean_str(request.form.get("office_state"))
        customer.office_pincode = clean_str(request.form.get("office_pincode"))
        customer.office_country = "India"
        success_message = "Office address updated."
    else:
        flash("Unknown address type.", "error")
        return redirect(redirect_url)

    db.session.commit()
    flash(success_message, "success")
    return redirect(redirect_url)


@app.route("/service/customers/<int:customer_id>/delete", methods=["POST"])
@login_required
def service_customer_delete(customer_id):
    _module_visibility_required("service")

    if not current_user.is_admin:
        abort(403)

    customer = db.session.get(Customer, customer_id)
    if not customer:
        flash("Customer not found.", "error")
        return redirect(url_for("service_customers"))

    redirect_url = request.form.get("next") or url_for("service_customers")
    if not redirect_url.startswith("/"):
        redirect_url = url_for("service_customers")

    lifts = (
        Lift.query.options(subqueryload(Lift.attachments))
        .filter_by(customer_code=customer.customer_code)
        .all()
    )
    for lift in lifts:
        delete_lift_record(lift)

    db.session.delete(customer)
    db.session.commit()

    flash(f"Customer {customer.customer_code} deleted.", "success")
    return redirect(redirect_url)


@app.route("/service/customers/<int:customer_id>/comments", methods=["POST"])
@login_required
def service_customer_add_comment(customer_id):
    _module_visibility_required("service")

    customer = db.session.get(Customer, customer_id)
    if not customer:
        flash("Customer not found.", "error")
        return redirect(url_for("service_customers"))

    body = (request.form.get("body") or "").strip()
    if not body:
        flash("Comment cannot be empty.", "error")
        return redirect(url_for("service_customer_detail", customer_id=customer.id))

    comment = CustomerComment(
        customer=customer,
        body=body,
        author=current_user if current_user.is_authenticated else None,
    )
    db.session.add(comment)
    db.session.commit()

    flash("Comment added.", "success")
    return redirect(url_for("service_customer_detail", customer_id=customer.id))


AMC_LIFT_TEMPLATE_FALLBACK_B64 = """
UEsDBBQAAAAIANV+bFtGx01IlQAAAM0AAAAQAAAAZG9jUHJvcHMvYXBwLnhtbE3PTQvCMAwG4L9S
dreZih6kDkQ9ip68zy51hbYpbYT67+0EP255ecgboi6JIia2mEXxLuRtMzLHDUDWI/o+y8qhiqHk
e64x3YGMsRoPpB8eA8OibdeAhTEMOMzit7Dp1C5GZ3XPlkJ3sjpRJsPiWDQ6sScfq9wcChDneiU+
ixNLOZcrBf+LU8sVU57mym/8ZAW/B7oXUEsDBBQAAAAIANV+bFuI4JN86gAAAMsBAAARAAAAZG9j
UHJvcHMvY29yZS54bWylkcFOwzAMhl9l6r11064coi4Xpp1AQmISiFvkeFtE00aJUbu3py1bB4Ib
x/j//NlWavQSu0BPofMU2FJcDa5po0S/SU7MXgJEPJHTMRuJdgwPXXCax2c4gtf4ro8ERZ7fgSPW
RrOGSZj6xZhclAYXpf8IzSwwCNSQo5YjiEzAjWUKLv7ZMCcLOUS7UH3fZ305c+NGAl4fH57n5VPb
RtYtUqJqgxIDae6Cmi7y56Gp4Vuxvsz+KpBZjRMknz1tkmvyUt5v97tEFXlRpUKkotiLSlZruS7f
JteP/pvQdcYe7D+MV4Gq4de/qU9QSwMEFAAAAAgA1X5sW5lcnCMQBgAAnCcAABMAAAB4bC90aGVt
ZS90aGVtZTEueG1s7Vpbc9o4FH7vr9B4Z/ZtC8Y2gba0E3Npdtu0mYTtTh+FEViNbHlkkYR/v0c2
EMuWDe2STbqbPAQs6fvORUfn6Dh58+4uYuiGiJTyeGDZL9vWu7cv3uBXMiQRQTAZp6/wwAqlTF61
WmkAwzh9yRMSw9yCiwhLeBTL1lzgWxovI9bqtNvdVoRpbKEYR2RgfV4saEDQVFFab18gtOUfM/gV
y1SNZaMBE1dBJrmItPL5bMX82t4+Zc/pOh0ygW4wG1ggf85vp+ROWojhVMLEwGpnP1Zrx9HSSICC
yX2UBbpJ9qPTFQgyDTs6nVjOdnz2xO2fjMradDRtGuDj8Xg4tsvSi3AcBOBRu57CnfRsv6RBCbSj
adBk2PbarpGmqo1TT9P3fd/rm2icCo1bT9Nrd93TjonGrdB4Db7xT4fDronGq9B062kmJ/2ua6Tp
FmhCRuPrehIVteVA0yAAWHB21szSA5ZeKfp1lBrZHbvdQVzwWO45iRH+xsUE1mnSGZY0RnKdkAUO
ADfE0UxQfK9BtorgwpLSXJDWzym1UBoImsiB9UeCIcXcr/31l7vJpDN6nX06zmuUf2mrAaftu5vP
k/xz6OSfp5PXTULOcLwsCfH7I1thhyduOxNyOhxnQnzP9vaRpSUyz+/5CutOPGcfVpawXc/P5J6M
ciO73fZYffZPR24j16nAsyLXlEYkRZ/ILbrkETi1SQ0yEz8InYaYalAcAqQJMZahhvi0xqwR4BN9
t74IyN+NiPerb5o9V6FYSdqE+BBGGuKcc+Zz0Wz7B6VG0fZVvNyjl1gVAZcY3zSqNSzF1niVwPGt
nDwdExLNlAsGQYaXJCYSqTl+TUgT/iul2v6c00DwlC8k+kqRj2mzI6d0Js3oMxrBRq8bdYdo0jx6
/gX5nDUKHJEbHQJnG7NGIYRpu/AerySOmq3CEStCPmIZNhpytRaBtnGphGBaEsbReE7StBH8Waw1
kz5gyOzNkXXO1pEOEZJeN0I+Ys6LkBG/HoY4SprtonFYBP2eXsNJweiCy2b9uH6G1TNsLI73R9QX
SuQPJqc/6TI0B6OaWQm9hFZqn6qHND6oHjIKBfG5Hj7lengKN5bGvFCugnsB/9HaN8Kr+ILAOX8u
fc+l77n0PaHStzcjfWfB04tb3kZuW8T7rjHa1zQuKGNXcs3Ix1SvkynYOZ/A7P1oPp7x7frZJISv
mlktIxaQS4GzQSS4/IvK8CrECehkWyUJy1TTZTeKEp5CG27pU/VKldflr7kouDxb5OmvoXQ+LM/5
PF/ntM0LM0O3ckvqtpS+tSY4SvSxzHBOHssMO2c8kh22d6AdNfv2XXbkI6UwU5dDuBpCvgNtup3c
OjiemJG5CtNSkG/D+enFeBriOdkEuX2YV23n2NHR++fBUbCj7zyWHceI8qIh7qGGmM/DQ4d5e1+Y
Z5XGUDQUbWysJCxGt2C41/EsFOBkYC2gB4OvUQLyUlVgMVvGAyuQonxMjEXocOeXXF/j0ZLj26Zl
tW6vKXcZbSJSOcJpmBNnq8reZbHBVR3PVVvysL5qPbQVTs/+Wa3InwwRThYLEkhjlBemSqLzGVO+
5ytJxFU4v0UzthKXGLzj5sdxTlO4Ena2DwIyubs5qXplMWem8t8tDAksW4hZEuJNXe3V55ucrnoi
dvqXd8Fg8v1wyUcP5TvnX/RdQ65+9t3j+m6TO0hMnHnFEQF0RQIjlRwGFhcy5FDukpAGEwHNlMlE
8AKCZKYcgJj6C73yDLkpFc6tPjl/RSyDhk5e0iUSFIqwDAUhF3Lj7++TaneM1/osgW2EVDJk1RfK
Q4nBPTNyQ9hUJfOu2iYLhdviVM27Gr4mYEvDem6dLSf/217UPbQXPUbzo5ngHrOHc5t6uMJFrP9Y
1h75Mt85cNs63gNe5hMsQ6R+wX2KioARq2K+uq9P+SWcO7R78YEgm/zW26T23eAMfNSrWqVkKxE/
Swd8H5IGY4xb9DRfjxRiraaxrcbaMQx5gFjzDKFmON+HRZoaM9WLrDmNCm9B1UDlP9vUDWj2DTQc
kQVeMZm2NqPkTgo83P7vDbDCxI7h7Yu/AVBLAwQUAAAACADVfmxb7y5T53ECAABaBQAAGAAAAHhs
L3dvcmtzaGVldHMvc2hlZXQxLnhtbIVUbW/aMBD+K6d82iRKoBRaoRCJwqpVGhJq1Vb7aOILseqX
1Haa8u93NiVttcGQUM7n8/M8d75z1hr77CpED29KajdLKu/raZq6okLFXN/UqGmnNFYxT0u7TV1t
kfF4SMn0fDCYpIoJneRZ9K1tnpnGS6FxbcE1SjG7u0Zp2lkyTA6OO7GtfHSkeVazLd6jf6jpAC3T
DocLhdoJo8FiOUvmw+n8Kp6IEY8CW/fJhpDMxpjnsLjls2QQNKHEwgcIRp9XXKCUAYmUvLyDJh+k
4eRn+wB/E/MneRvmcGHkk+C+miUkhmPJGunvTPsT33Maf0hcMs/yzJoWbEg2z4pgRPaYPIULHUp1
7y3tCuLz+Xy1AClKD00tDePgUdWSecxST9pCTFrQn1A76FEHPToCeiOkBF8hBPRfhO5gf++t8BUY
jXvKGi0QZv8E10XHdXGEa23Nq+AY6YrGeaMIFd88Ws0k3C6htEZ93X1P1div7sJwTDVTeErQuBM0
PiLokUnBY+bOM984dFOYx3bowY+3WljkPbhDjS3pW6PmQm97sGBUsmvmhDtBPunIJ/8l541loRWJ
fQg7ZLYH5/HrejA6GBcHY3ww9rGwEcpoX8ld53lpmKWiBs8E4uYppZed0ssjSqlb0YGi4sMGQWj4
Tb+z1epsSVcWJ6APaxoatFQwcGhfRYHA6RQNV4E19dRgeDYanLqsq07F1dHu+Zth56BgOqgqDL0f
tFMzqiXFfMP+tg8roymo94RcoyPr+z8lpJ9mMrw5K2a3QjuQWJKSQf+S+sfuh3i/8KaOY7oxnvox
mhW9fWhDAO2XxvhuER6R7jnN/wBQSwMEFAAAAAgA1X5sW5J2+ZcYBAAATxIAABgAAAB4bC93b3Jr
c2hlZXRzL3NoZWV0Mi54bWyVmG1v4jgQx7+KxauedDSxgT4JkFrobrtbemyhT69OLhnAamJnHVPK
ffpzQsJWZZykVVUS4t9/xjPDjEt3rfRrsgQw5D0KZdJrLI2JzzwvmS0h4smhikHaJ3OlI27srV54
SayBBxkUhR7z/SMv4kI2+t3svbHud9XKhELCWJNkFUVcby4gVOtegzaKN+7EYmmyN7x+N+YLmIC5
jy1gb72dTiAikIlQkmiY9xrn9OyZZUS24kHAOvlwTdLNvCj1mt5cB72Gn/oEIcxMKsHtyxsMIAxT
JevJ71y08cdoSn68LuS/Zfu37r3wBAYqfBSBWfYaJw0SwJyvQnOn1leQ76mTCc5UmGR/yXq7mFnX
Z6vEqCinreFIyO0rfy+C8YGgJw6C5QSrTbRyolWbaOdEuzbRyYnOZ8K586OcONojqIM4zonj2sRJ
TpzU3sdpTpzWJqhfpNCvz+zSXj/vtEg8rZ95WqSe7uWe+S6mSD6tn31apJ/u5d/NFAVA9yrAzRQl
QPdroO1iiiKg9auAFmVA9+rAWc+sqAO2VwdO31hRB2yvDtipi9k1gL06aDl9K+qA7dVBy/XZYUUd
sPp1wIo6YNs68LaNMGujQ254v6vVmugUsILpRdaMs2Zmu6eQ6eSYGG2fCsuZ/iCzAppcvhvQkofk
etj1jFVOn3uzXOWiXOVGzA0ZqAAQdFCO7uxmGqjxYc0tOBy4rInf8gjDv5XjFysRBkIuiEceRBhy
cqsOEZXv5SoTYYCcB4GGJLGRkEAoInL1VRGGiFxXhEOYDUL9qDBtuMGC97McGws5w5N2Uw7e2UMQ
ho1q1Ol0E2PobUVceMxnNjbkIAadKJn8hWj8U1fjdYHh44ogxwABOYg81Pavcvh8NCBpllYJwt7V
YrUhB8/2pzkaNYdDzIdJtc5wpXl6YkToaTV9KYMqH+4rSs6eS0FrG8gJ6DcxAzLkGywmD1/XsR+/
A9ypx6+KTe3hnBxcXZ2NRpjeU7neLbybP36toCpmzxVyysCnEHl2zuyGDdsNG2fl30+mzcunadP3
scZ28ZnL5mE2PZxzw4pR1mpj86LECx934NI9nngUh0CuZWDnhBaf47AdES6asnNsFlQZG4f8P471
f+fGQBptZ+j5G8gV1tyuXeR3hRn68bXlP13L234Lj/fN1wyMXMtHdzdYK3ctP8F6tmtxp40V19iZ
60Mf68rObpb9w4z1YhfBfNZu+vYXC+jE6da/G+Aa67YldjpNv9VsYXbunZlQMuCbvx8hkJDYK6yj
On3sYC3Tudo/87FQP5UH7hgP3LPziAES1vYzFdj2KST5RbEG6H04eadftIy4XgiZkBDmVtQ/PLbH
dL395mJ7Y1ScneZflLGnzuxyCTwAnS6wz+fK9triJj3g775D6v8PUEsDBBQAAAAIANV+bFsX/Mrx
iwIAAHgLAAANAAAAeGwvc3R5bGVzLnhtbN1W246bMBD9FcQHlCS0KFQJUhspUqW2Wmnz0FcTDLHk
CzVmS/r19dgOJLsZtq3Ul4ISxnN85u6QTWfOnD6eKDXRILjstvHJmPZ9knTHExWke6NaKi1SKy2I
sUvdJF2rKak6IAmerBaLLBGEybjYyF7shemio+ql2caLOEqKTa3kpEpjr7B7iaDRE+HbeEc4KzXz
m4lg/Oz1K6c5Kq50ZGw0dBsvnar76TcswxJCDbYEk0o7beLd+O8yEG7pb1/ZGBD36OwOxvmYyCr2
imLTEmOolnu78CSnfYkF+XBubSKNJufl6l18xXAP66ZUuqJ6dLSML6piw2ltgKFZc3KCUS08SmWM
EiBVjDRKEh/JhRYEa/tIOX+Eln+rbxwMdeR796lybYOML6KNKojeTFiAg2tz3viV3fTv7LbsSZmP
vU1IuvX3Xhn6oGnNBrce6ikAzPzy35pf4eZJ2/LzB84aKagv7m97LDbkwot+aNIe6GDGSRzqUO6x
0q7uN00ctRGcrW38Fc4sv0qp7Bk3TIbViVUVlS97ae0bUtpfhRsHdldFa9JzcxjBbTzJX2jFepGP
ux4g67Brkj/D4C6z6WBbZ0xWdKDVLix1UzoxsoJ1Gy7HeA7t3YVAKMuDCAQg6gsNA2V5Hurrf8xr
jeflQTTC9X1ojbPWOMvz7kI7d6O+EFZuLyTlPE/TLEPLu9vdD2OH1jDL4IMYRCMEDuoLvP1p5WcG
YGZsXpkNtMuzY4OmPDOiaMozlQcIqSFw8hwZANQXcNCmoBMFQSC+YNQQVppCn9EI0WM+A+U5CsGQ
ItObZVihMriRfqGHKE3zHIEARMJIUxSCAzsDoWFAICiUpv5F+ux9llzec8n0X7v4BVBLAwQUAAAA
CADVfmxbt0frisAAAAAWAgAACwAAAF9yZWxzLy5yZWxznZJLbgIxDECvEmVfTKnEAjGs2LBDiAu4
ieejmcSRY8T09o3YwCBoEUv/np4trw80oHYcc9ulbMYwxFzZVjWtALJrKWCecaJYKjVLQC2hNJDQ
9dgQLObzJcgtw27Wt0xz/En0CpHrunO0ZXcKFPUB+K7DmiNKQ1rZcYAzS//N3M8K1Jqdr6zs/Kc1
8KbM8/UgkKJHRXAs9JGkTIt2lK8+nt2+pPOlY2K0eN/o//PQqBQ9+b+dMKWJ0tdFCSZvsPkFUEsD
BBQAAAAIANV+bFt9A0CpSAEAAHECAAAPAAAAeGwvd29ya2Jvb2sueG1sjZFvS8MwEMa/SskHsN3Q
gWMdyIY6mH9wsvdpe12PJbmSXDfdpzdJqRYE8VVyzx2/PM9lcSZ7LIiOyYdWxs1tLhrmdp6mrmxA
S3dFLRjfq8lqyb60h5TqGktYU9lpMJxOs2yWWlCSkYxrsHWip/2H5VoLsnINAGvVo7REI5aLwdmr
TdJxRQxleCmoQdkjnN3PQCiTEzosUCF/5iLeFYhEo0GNF6hykYnENXR+JIsXMizVrrSkVC4mfWMP
lrH8Je+CzXdZuKiwLN5C5lzMMg+s0TqOE5EvvckT+OG+6pjuUTHYtWR4sNS1aA4R42OkoxxxFcOZ
GKkhFxvj2HYxtQtOfGdT9a7Y40YZ7Rx9w26qHjyG3D2tki3WPCZM/yBMe2uDnwpqNFA9e5YLDb+d
0n9NOKKX6fXN5NZvoVNq5bUXsyVZfQccfmf5BVBLAwQUAAAACADVfmxbq15yLrQAAACNAgAAGgAA
AHhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzxZJNCoMwEEavEnIAR23poqirbtwWLxB0/MHEhMyU
6u0rulChi26kq/BNyPseTJInasWdHajtHInR6IFS2TK7OwCVLRpFgXU4zDe19UbxHH0DTpW9ahDi
MLyB3zNkluyZopgc/kK0dd2V+LDly+DAX8Dwtr6nFpGlKJRvkFMJo97GBMsRBTNZirxKpc+rSAr4
t1F8MIrPNCKeNNKms+ZD/+XMfp7f4la/xHV4XMt1kYDD78s+UEsDBBQAAAAIANV+bFul4RtYHwEA
AGAEAAATAAAAW0NvbnRlbnRfVHlwZXNdLnhtbMVUy07DMBD8lcjXKnbpgQNqeqFcoQd+wCSbxopf
8m5L+vdsEloJVFqqIHGJFe/szHjH8vL1EAGzzlmPhWiI4oNSWDbgNMoQwXOlDslp4t+0VVGXrd6C
Wszn96oMnsBTTj2HWC3XUOudpeyp4200wRcigUWRPY7AXqsQOkZrSk1cV3tffVPJPxUkdw4YbEzE
GQNEps5KDKUfFY6NL3tIyVSQbXSiZ+0YpjqrkA4WUF7mOOMy1LUpoQrlznGLxJhAV9gAkLNyJJ1d
kSYeMozfu8kGBpqLigzdpBCRU0twu94xlr47j0wEicyVQ54kmXvyCaFPvILqt+I84feQ2iETVMMy
fcxfcz7x32pk8Z9G3kJo//rC96t02viTATU8LKsPUEsBAhQDFAAAAAgA1X5sW0bHTUiVAAAAzQAA
ABAAAAAAAAAAAAAAAIABAAAAAGRvY1Byb3BzL2FwcC54bWxQSwECFAMUAAAACADVfmxbiOCTfOoA
AADLAQAAEQAAAAAAAAAAAAAAgAHDAAAAZG9jUHJvcHMvY29yZS54bWxQSwECFAMUAAAACADVfmxb
mVycIxAGAACcJwAAEwAAAAAAAAAAAAAAgAHcAQAAeGwvdGhlbWUvdGhlbWUxLnhtbFBLAQIUAxQA
AAAIANV+bFvvLlPncQIAAFoFAAAYAAAAAAAAAAAAAACAgR0IAAB4bC93b3Jrc2hlZXRzL3NoZWV0
MS54bWxQSwECFAMUAAAACADVfmxbknb5lxgEAABPEgAAGAAAAAAAAAAAAAAAgIHECgAAeGwvd29y
a3NoZWV0cy9zaGVldDIueG1sUEsBAhQDFAAAAAgA1X5sWxf8yvGLAgAAeAsAAA0AAAAAAAAAAAAA
AIABEg8AAHhsL3N0eWxlcy54bWxQSwECFAMUAAAACADVfmxbt0frisAAAAAWAgAACwAAAAAAAAAA
AAAAgAHIEQAAX3JlbHMvLnJlbHNQSwECFAMUAAAACADVfmxbfQNAqUgBAABxAgAADwAAAAAAAAAA
AAAAgAGxEgAAeGwvd29ya2Jvb2sueG1sUEsBAhQDFAAAAAgA1X5sW6teci60AAAAjQIAABoAAAAA
AAAAAAAAAIABJhQAAHhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzUEsBAhQDFAAAAAgA1X5sW6Xh
G1gfAQAAYAQAABMAAAAAAAAAAAAAAIABEhUAAFtDb250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAoA
CgCEAgAAYhYAAAAA
"""
CUSTOMER_TEMPLATE_FALLBACK_B64 = """
UEsDBBQAAAAIANV+bFtGx01IlQAAAM0AAAAQAAAAZG9jUHJvcHMvYXBwLnhtbE3PTQvCMAwG4L9S
dreZih6kDkQ9ip68zy51hbYpbYT67+0EP255ecgboi6JIia2mEXxLuRtMzLHDUDWI/o+y8qhiqHk
e64x3YGMsRoPpB8eA8OibdeAhTEMOMzit7Dp1C5GZ3XPlkJ3sjpRJsPiWDQ6sScfq9wcChDneiU+
ixNLOZcrBf+LU8sVU57mym/8ZAW/B7oXUEsDBBQAAAAIANV+bFuI4JN86gAAAMsBAAARAAAAZG9j
UHJvcHMvY29yZS54bWylkcFOwzAMhl9l6r11064coi4Xpp1AQmISiFvkeFtE00aJUbu3py1bB4Ib
x/j//NlWavQSu0BPofMU2FJcDa5po0S/SU7MXgJEPJHTMRuJdgwPXXCax2c4gtf4ro8ERZ7fgSPW
RrOGSZj6xZhclAYXpf8IzSwwCNSQo5YjiEzAjWUKLv7ZMCcLOUS7UH3fZ305c+NGAl4fH57n5VPb
RtYtUqJqgxIDae6Cmi7y56Gp4Vuxvsz+KpBZjRMknz1tkmvyUt5v97tEFXlRpUKkotiLSlZruS7f
JteP/pvQdcYe7D+MV4Gq4de/qU9QSwMEFAAAAAgA1X5sW5lcnCMQBgAAnCcAABMAAAB4bC90aGVt
ZS90aGVtZTEueG1s7Vpbc9o4FH7vr9B4Z/ZtC8Y2gba0E3Npdtu0mYTtTh+FEViNbHlkkYR/v0c2
EMuWDe2STbqbPAQs6fvORUfn6Dh58+4uYuiGiJTyeGDZL9vWu7cv3uBXMiQRQTAZp6/wwAqlTF61
WmkAwzh9yRMSw9yCiwhLeBTL1lzgWxovI9bqtNvdVoRpbKEYR2RgfV4saEDQVFFab18gtOUfM/gV
y1SNZaMBE1dBJrmItPL5bMX82t4+Zc/pOh0ygW4wG1ggf85vp+ROWojhVMLEwGpnP1Zrx9HSSICC
yX2UBbpJ9qPTFQgyDTs6nVjOdnz2xO2fjMradDRtGuDj8Xg4tsvSi3AcBOBRu57CnfRsv6RBCbSj
adBk2PbarpGmqo1TT9P3fd/rm2icCo1bT9Nrd93TjonGrdB4Db7xT4fDronGq9B062kmJ/2ua6Tp
FmhCRuPrehIVteVA0yAAWHB21szSA5ZeKfp1lBrZHbvdQVzwWO45iRH+xsUE1mnSGZY0RnKdkAUO
ADfE0UxQfK9BtorgwpLSXJDWzym1UBoImsiB9UeCIcXcr/31l7vJpDN6nX06zmuUf2mrAaftu5vP
k/xz6OSfp5PXTULOcLwsCfH7I1thhyduOxNyOhxnQnzP9vaRpSUyz+/5CutOPGcfVpawXc/P5J6M
ciO73fZYffZPR24j16nAsyLXlEYkRZ/ILbrkETi1SQ0yEz8InYaYalAcAqQJMZahhvi0xqwR4BN9
t74IyN+NiPerb5o9V6FYSdqE+BBGGuKcc+Zz0Wz7B6VG0fZVvNyjl1gVAZcY3zSqNSzF1niVwPGt
nDwdExLNlAsGQYaXJCYSqTl+TUgT/iul2v6c00DwlC8k+kqRj2mzI6d0Js3oMxrBRq8bdYdo0jx6
/gX5nDUKHJEbHQJnG7NGIYRpu/AerySOmq3CEStCPmIZNhpytRaBtnGphGBaEsbReE7StBH8Waw1
kz5gyOzNkXXO1pEOEZJeN0I+Ys6LkBG/HoY4SprtonFYBP2eXsNJweiCy2b9uH6G1TNsLI73R9QX
SuQPJqc/6TI0B6OaWQm9hFZqn6qHND6oHjIKBfG5Hj7lengKN5bGvFCugnsB/9HaN8Kr+ILAOX8u
fc+l77n0PaHStzcjfWfB04tb3kZuW8T7rjHa1zQuKGNXcs3Ix1SvkynYOZ/A7P1oPp7x7frZJISv
mlktIxaQS4GzQSS4/IvK8CrECehkWyUJy1TTZTeKEp5CG27pU/VKldflr7kouDxb5OmvoXQ+LM/5
PF/ntM0LM0O3ckvqtpS+tSY4SvSxzHBOHssMO2c8kh22d6AdNfv2XXbkI6UwU5dDuBpCvgNtup3c
OjiemJG5CtNSkG/D+enFeBriOdkEuX2YV23n2NHR++fBUbCj7zyWHceI8qIh7qGGmM/DQ4d5e1+Y
Z5XGUDQUbWysJCxGt2C41/EsFOBkYC2gB4OvUQLyUlVgMVvGAyuQonxMjEXocOeXXF/j0ZLj26Zl
tW6vKXcZbSJSOcJpmBNnq8reZbHBVR3PVVvysL5qPbQVTs/+Wa3InwwRThYLEkhjlBemSqLzGVO+
5ytJxFU4v0UzthKXGLzj5sdxTlO4Ena2DwIyubs5qXplMWem8t8tDAksW4hZEuJNXe3V55ucrnoi
dvqXd8Fg8v1wyUcP5TvnX/RdQ65+9t3j+m6TO0hMnHnFEQF0RQIjlRwGFhcy5FDukpAGEwHNlMlE
8AKCZKYcgJj6C73yDLkpFc6tPjl/RSyDhk5e0iUSFIqwDAUhF3Lj7++TaneM1/osgW2EVDJk1RfK
Q4nBPTNyQ9hUJfOu2iYLhdviVM27Gr4mYEvDem6dLSf/217UPbQXPUbzo5ngHrOHc5t6uMJFrP9Y
1h75Mt85cNs63gNe5hMsQ6R+wX2KioARq2K+uq9P+SWcO7R78YEgm/zW26T23eAMfNSrWqVkKxE/
Swd8H5IGY4xb9DRfjxRiraaxrcbaMQx5gFjzDKFmON+HRZoaM9WLrDmNCm9B1UDlP9vUDWj2DTQc
kQVeMZm2NqPkTgo83P7vDbDCxI7h7Yu/AVBLAwQUAAAACADVfmxbx0021wkCAAAwBAAAGAAAAHhs
L3dvcmtzaGVldHMvc2hlZXQxLnhtbIVUwW7bMAz9FcLnLU7XJhsKx0CarlsxBAhSbDsrNh0LkURX
ouPu70c5iZvDkh0MiyL13uOz6Kwjvws1IsObNS7Mkpq5uU/TUNRoVRhRg04yFXmrWEK/TUPjUZX9
IWvST+PxNLVKuyTP+r2VzzNq2WiHKw+htVb5Pw9oqJslN8lpY623NfcbaZ41aosvyD8bOSBhOuCU
2qILmhx4rGbJ/OZ+Pu1P9BW/NHbhbA2xmQ3RLgbP5SwZR01osOAIoeS1xwUaE5FEyesRNHknjSfP
1yf4p75/kbdRARdkfuuS61nyJYESK9UaXlP3HY89Td4lPipWeeapAx+bzbMiLnr2vnkp1y5a9cJe
slr4OF+0gcmih7YxpEpgtI1RjFnKoi3WpIU8gjpA3w7QtxdAn7QxwDXCCT3A4bt3mmsgh1CcaBt5
BHd0he9u4Lu7wLfytNclgnLw9Y3RO2UGanh+BCawqgGjKw5Qtl67LcyXi2PP4Rr5ZCCf/M/BgkoM
oLzoaJk+btGhFydL0BUYrBg2RrndCH4gNtEdC63Try3GfHPooLwmZTpImV6QspZZQLGaWlNKx1zU
0ZLDXYSAfq8LFLelaAQPXjnJW1EPG+w/ClXwjdQHWLZ2o/Q/paRnNy1O0lL5rXah709mYPRZXPKH
q3kImJr+8m2IxaV+WctEo48Fkq+IeAjiaAw/ifwvUEsDBBQAAAAIANV+bFvWeAQ/ugMAAOUQAAAY
AAAAeGwvd29ya3NoZWV0cy9zaGVldDIueG1snZhrc9o4FIb/ioavncSWuKYDzHJJWroNoUCSTr8p
tgBNZInKIoR/v7Kx2cz2yIj9AtblOZJ8Xl5JdPdKv6Ybxgx6T4RMe7WNMdvPQZBGG5bQ9FptmbQt
K6UTamxRr4N0qxmNcygRAQnDVpBQLmv9bl430/2u2hnBJZtplO6ShOrDkAm179VwrayY8/XG5BVB
v7ula7Zg5nFrAVsMTnFinjCZciWRZqtebYA/P5OcyHs8cbZPPzyjbDEvSr1mhUncq4XZnJhgkclC
UPv1xkZMiCySncnvImjt30Ez8uNzGf4uX7+d3gtN2UiJZx6bTa/WqaGYrehOmLnaf2XFmpp5wEiJ
NP9E+2NnYqce7VKjkoK2AydcHr/pe/kyPhC44yBIQRBvol4QdW+iURANb6JZEE1volUQLW+iXRBt
b6JTEJ3/EqThIG4K4sabwGGZwtB7XviUdv+84zLx2D/zuEw99s89LpOP/bOPy/Rj//zjUgDYXwG4
lAD21wAuRYD/VEHdxZQywH/qwMWQUgfEXwek1AG54Pd/MgB/HZBSB+Sog+BoULm9jamh/a5We6Qz
wAbMHnKTzE3GuhqXmaMvjLat3HKmf/tumJZUoFE+HNNoMu4GxkbO2oOoiDKsjnKCRypmAD46g6tk
S+UBTWkC0eNztDR2W0AzplMlAf62mp9tlISGvavG7tULFxD35cwbt/usALCv1diXxRJNFcBNqrkh
F7ZqjQZxrFmaou+2HWEgzrf/EYcAcf4+ky1uDgD1vZpaGGqgd31/JrVcRrAip+c0tZNGQxN9qAbn
9tQEjTc7sz57vFEa4H6cyYqmMtoA3LyamyrDUgBbVGMPqxWP2HktLS8PA0np0SuMQ1FPXrBLWM9e
NKivwFrwyYfJyYedUntcLK9ufy6vwhB6lcMKLoSRkdvsabIVDE1kbA1bc1ACYxc9EOwdjai2GwZk
si7s0w2+6tTJFSb1RrPVhoy2Cr3ptFvNRp3gELJaF6m26V/suNrrSCWQ3bpQ0h4MR+PbbLp3+FcT
clwXiskAMlZX94mU6o3m15oZ1a+Qlzp3A0UhE72s+72reyOsw8qaupcSc2iIh8tmNKs4IdjjRcQp
tHP+uGyQuXO3sFdJe4ZAv3e5yMXBXljfsitpRIUA3dJp5ztuGKqHkKktndDrIatCS7W3s4Ds8LJ1
Pl3W/fkSNRw9Lvhw7syu//dUr7lMkWArGym8bttLhD7ep48Fo7b5WfZFGXtezB83jMZMZx1s+0rZ
faksZMfb0z8b/X8AUEsDBBQAAAAIANV+bFsX/MrxiwIAAHgLAAANAAAAeGwvc3R5bGVzLnhtbN1W
246bMBD9FcQHlCS0KFQJUhspUqW2Wmnz0FcTDLHkCzVmS/r19dgOJLsZtq3Ul4ISxnN85u6QTWfO
nD6eKDXRILjstvHJmPZ9knTHExWke6NaKi1SKy2IsUvdJF2rKak6IAmerBaLLBGEybjYyF7shemi
o+ql2caLOEqKTa3kpEpjr7B7iaDRE+HbeEc4KzXzm4lg/Oz1K6c5Kq50ZGw0dBsvnar76TcswxJC
DbYEk0o7beLd+O8yEG7pb1/ZGBD36OwOxvmYyCr2imLTEmOolnu78CSnfYkF+XBubSKNJufl6l18
xXAP66ZUuqJ6dLSML6piw2ltgKFZc3KCUS08SmWMEiBVjDRKEh/JhRYEa/tIOX+Eln+rbxwMdeR7
96lybYOML6KNKojeTFiAg2tz3viV3fTv7LbsSZmPvU1IuvX3Xhn6oGnNBrce6ikAzPzy35pf4eZJ
2/LzB84aKagv7m97LDbkwot+aNIe6GDGSRzqUO6x0q7uN00ctRGcrW38Fc4sv0qp7Bk3TIbViVUV
lS97ae0bUtpfhRsHdldFa9JzcxjBbTzJX2jFepGPux4g67Brkj/D4C6z6WBbZ0xWdKDVLix1Uzox
soJ1Gy7HeA7t3YVAKMuDCAQg6gsNA2V5Hurrf8xrjeflQTTC9X1ojbPWOMvz7kI7d6O+EFZuLyTl
PE/TLEPLu9vdD2OH1jDL4IMYRCMEDuoLvP1p5WcGYGZsXpkNtMuzY4OmPDOiaMozlQcIqSFw8hwZ
ANQXcNCmoBMFQSC+YNQQVppCn9EI0WM+A+U5CsGQItObZVihMriRfqGHKE3zHIEARMJIUxSCAzsD
oWFAICiUpv5F+ux9llzec8n0X7v4BVBLAwQUAAAACADVfmxbt0frisAAAAAWAgAACwAAAF9yZWxz
Ly5yZWxznZJLbgIxDECvEmVfTKnEAjGs2LBDiAu4ieejmcSRY8T09o3YwCBoEUv/np4trw80oHYc
c9ulbMYwxFzZVjWtALJrKWCecaJYKjVLQC2hNJDQ9dgQLObzJcgtw27Wt0xz/En0CpHrunO0ZXcK
FPUB+K7DmiNKQ1rZcYAzS//N3M8K1Jqdr6zs/Kc18KbM8/UgkKJHRXAs9JGkTIt2lK8+nt2+pPOl
Y2K0eN/o//PQqBQ9+b+dMKWJ0tdFCSZvsPkFUEsDBBQAAAAIANV+bFtGlf0ARQEAAHECAAAPAAAA
eGwvd29ya2Jvb2sueG1sjZFhS8MwEIb/SskPsF3RgWPdF4c6EBUn+5611/VYkiuX66b79SYt1YIg
fkruvePJ+16WZ+LjnuiYfFjj/IIL1Yi0izT1ZQNW+ytqwYVeTWy1hJIPKdU1lrCmsrPgJM2zbJ4y
GC1IzjfYejXQ/sPyLYOufAMg1gwoq9Gp1XJ09spJOq1IoIwvRTUqO4Sz/xmIZXJCj3s0KJ+F6u8G
VGLRocULVIXKVOIbOj8S44WcaLMtmYwp1Gxo7IAFy1/yNtp813vfK6L3bzFzoeZZANbIXvqJnq+D
yROE4aHqhO7RCPBaCzwwdS26Q48JMdJJjn4V45k4baFQG+eFuz61j05CZ1MNriTgJhl5gaHBm2oA
TyF3nReywFNC/gchH6yNfiqo0UH1HFg+NsJ2yvA18ei95Nc3s9uwhc6Yu6C9uCfS1XfA8XdWX1BL
AwQUAAAACADVfmxbq15yLrQAAACNAgAAGgAAAHhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzxZJN
CoMwEEavEnIAR23poqirbtwWLxB0/MHEhMyU6u0rulChi26kq/BNyPseTJInasWdHajtHInR6IFS
2TK7OwCVLRpFgXU4zDe19UbxHH0DTpW9ahDiMLyB3zNkluyZopgc/kK0dd2V+LDly+DAX8Dwtr6n
FpGlKJRvkFMJo97GBMsRBTNZirxKpc+rSAr4t1F8MIrPNCKeNNKms+ZD/+XMfp7f4la/xHV4XMt1
kYDD78s+UEsDBBQAAAAIANV+bFul4RtYHwEAAGAEAAATAAAAW0NvbnRlbnRfVHlwZXNdLnhtbMVU
y07DMBD8lcjXKnbpgQNqeqFcoQd+wCSbxopf8m5L+vdsEloJVFqqIHGJFe/szHjH8vL1EAGzzlmP
hWiI4oNSWDbgNMoQwXOlDslp4t+0VVGXrd6CWszn96oMnsBTTj2HWC3XUOudpeyp4200wRcigUWR
PY7AXqsQOkZrSk1cV3tffVPJPxUkdw4YbEzEGQNEps5KDKUfFY6NL3tIyVSQbXSiZ+0YpjqrkA4W
UF7mOOMy1LUpoQrlznGLxJhAV9gAkLNyJJ1dkSYeMozfu8kGBpqLigzdpBCRU0twu94xlr47j0wE
icyVQ54kmXvyCaFPvILqt+I84feQ2iETVMMyfcxfcz7x32pk8Z9G3kJo//rC96t02viTATU8LKsP
UEsBAhQDFAAAAAgA1X5sW0bHTUiVAAAAzQAAABAAAAAAAAAAAAAAAIABAAAAAGRvY1Byb3BzL2Fw
cC54bWxQSwECFAMUAAAACADVfmxbiOCTfOoAAADLAQAAEQAAAAAAAAAAAAAAgAHDAAAAZG9jUHJv
cHMvY29yZS54bWxQSwECFAMUAAAACADVfmxbmVycIxAGAACcJwAAEwAAAAAAAAAAAAAAgAHcAQAA
eGwvdGhlbWUvdGhlbWUxLnhtbFBLAQIUAxQAAAAIANV+bFvHTTbXCQIAADAEAAAYAAAAAAAAAAAA
AACAgR0IAAB4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWxQSwECFAMUAAAACADVfmxb1ngEP7oDAADl
EAAAGAAAAAAAAAAAAAAAgIFcCgAAeGwvd29ya3NoZWV0cy9zaGVldDIueG1sUEsBAhQDFAAAAAgA
1X5sWxf8yvGLAgAAeAsAAA0AAAAAAAAAAAAAAIABTA4AAHhsL3N0eWxlcy54bWxQSwECFAMUAAAA
CADVfmxbt0frisAAAAAWAgAACwAAAAAAAAAAAAAAgAECEQAAX3JlbHMvLnJlbHNQSwECFAMUAAAA
CADVfmxbRpX9AEUBAABxAgAADwAAAAAAAAAAAAAAgAHrEQAAeGwvd29ya2Jvb2sueG1sUEsBAhQD
FAAAAAgA1X5sW6teci60AAAAjQIAABoAAAAAAAAAAAAAAIABXRMAAHhsL19yZWxzL3dvcmtib29r
LnhtbC5yZWxzUEsBAhQDFAAAAAgA1X5sW6XhG1gfAQAAYAQAABMAAAAAAAAAAAAAAIABSRQAAFtD
b250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAoACgCEAgAAmRUAAAAA
"""


def _serve_base64_excel_template(encoded_value, filename):
    if not encoded_value:
        return None
    output = BytesIO(base64.b64decode(encoded_value))
    output.seek(0)
    return send_file(
        output,
        as_attachment=True,
        download_name=filename,
        mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )


@app.route("/service/lifts/upload-template")
@login_required
def service_lifts_upload_template():
    _module_visibility_required("service")

    filename = f"amc_lifts_template_{datetime.datetime.utcnow():%Y%m%d}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_amc_lift_upload_workbook()
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_output = _build_csv_output(
        AMC_LIFT_TEMPLATE_HEADERS,
        [["" for _ in AMC_LIFT_TEMPLATE_HEADERS]],
    )
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/service/customers/upload-template")
@login_required
def service_customers_upload_template():
    _module_visibility_required("service")

    filename = f"customers_template_{datetime.datetime.utcnow():%Y%m%d}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_customer_upload_workbook()
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_output = _build_csv_output(
        CUSTOMER_UPLOAD_TEMPLATE_HEADERS,
        [["" for _ in CUSTOMER_UPLOAD_TEMPLATE_HEADERS]],
    )
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/service/customers/upload", methods=["POST"])
@login_required
def service_customers_upload():
    _module_visibility_required("service")

    pending_token = request.form.get("pending_token")
    action = request.form.get("action")

    if pending_token:
        pending_uploads = session.get("pending_uploads", {})
        pending = pending_uploads.get(pending_token)
        if not pending or pending.get("type") != "service_customers":
            flash("The upload preview has expired. Please re-upload the file.", "error")
            return redirect(url_for("service_customers"))

        file_path = pending.get("path")
        if not file_path:
            file_path = _build_pending_upload_path(
                pending.get("token"), pending.get("extension")
            )
        if not file_path or not os.path.exists(file_path):
            pending_uploads.pop(pending_token, None)
            session["pending_uploads"] = pending_uploads
            session.modified = True
            flash("The staged upload file was not found. Please try uploading again.", "error")
            return redirect(url_for("service_customers"))

        if action == "discard":
            pending_uploads.pop(pending_token, None)
            session["pending_uploads"] = pending_uploads
            session.modified = True
            try:
                os.remove(file_path)
            except OSError:
                pass
            flash("Customer upload discarded.", "info")
            return redirect(url_for("service_customers"))

        if action != "merge":
            flash("Select a valid action for the upload.", "error")
            return redirect(url_for("service_customers"))

        try:
            outcome = process_customer_upload_file(
                file_path,
                apply_changes=True,
            )
        except UploadStageTimeoutError as exc:
            flash(str(exc), "error")
            return redirect(url_for("service_customers"))

        pending_uploads.pop(pending_token, None)
        session["pending_uploads"] = pending_uploads
        session.modified = True

        try:
            os.remove(file_path)
        except OSError:
            pass

        if outcome.created_count or outcome.updated_count:
            flash(
                f"Customer upload complete: {outcome.created_count} added, {outcome.updated_count} updated.",
                "success",
            )
        elif outcome.processed_rows and not outcome.row_errors:
            flash("No changes were detected in the uploaded workbook.", "info")
        else:
            flash("No rows were imported from the uploaded workbook.", "info")

        for message in outcome.row_errors[:25]:
            flash(message, "error")
        if len(outcome.row_errors) > 25:
            flash(
                f"Additional {len(outcome.row_errors) - 25} errors were omitted from the alert. Check the file and retry.",
                "warning",
            )

        return redirect(url_for("service_customers"))

    upload = request.files.get("customer_upload_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(url_for("service_customers"))

    saved_token = None
    saved_extension = None
    saved_path = None
    try:
        saved_token, saved_extension = save_pending_upload_file(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
        saved_path = _build_pending_upload_path(saved_token, saved_extension)
        outcome = process_customer_upload_file(
            saved_path,
            apply_changes=False,
        )
    except MissingDependencyError:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(OPENPYXL_MISSING_MESSAGE, "error")
        return redirect(url_for("service_customers"))
    except ValueError:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "Upload the .xlsx or .csv template exported from the customer upload modal.",
            "error",
        )
        return redirect(url_for("service_customers"))
    except UploadStageTimeoutError as exc:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(str(exc), "error")
        return redirect(url_for("service_customers"))
    except Exception:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "Could not read the uploaded workbook. Ensure it is a valid .xlsx or .csv file.",
            "error",
        )
        return redirect(url_for("service_customers"))

    if not outcome.header_map:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash("The uploaded workbook is missing header labels.", "error")
        return redirect(url_for("service_customers"))

    missing_headers = []
    if "Company Name" not in outcome.header_map:
        missing_headers.append("Company Name")
    if "Customer Code" not in outcome.header_map and "External Customer ID" not in outcome.header_map:
        missing_headers.append("Customer Code / External Customer ID")
    if missing_headers:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "The uploaded workbook is missing required columns: "
            + ", ".join(missing_headers)
            + ".",
            "error",
        )
        return redirect(url_for("service_customers"))

    pending_token = uuid.uuid4().hex
    pending_uploads = session.get("pending_uploads", {})
    pending_uploads[pending_token] = {
        "type": "service_customers",
        "token": saved_token,
        "extension": saved_extension,
        "original_filename": upload.filename,
    }
    session["pending_uploads"] = pending_uploads
    session.modified = True

    return redirect(
        url_for(
            "service_upload_review",
            upload_type="customers",
            pending_token=pending_token,
        )
    )

@app.route("/service/lifts/upload", methods=["POST"])
@login_required
def service_lifts_upload():
    _module_visibility_required("service")

    pending_token = request.form.get("pending_token")
    action = request.form.get("action")

    if pending_token:
        pending_uploads = session.get("pending_uploads", {})
        pending = pending_uploads.get(pending_token)
        if not pending or pending.get("type") != "service_lifts":
            flash("The upload preview has expired. Please re-upload the file.", "error")
            return redirect(url_for("service_lifts"))

        file_path = pending.get("path")
        if not file_path:
            file_path = _build_pending_upload_path(
                pending.get("token"), pending.get("extension")
            )
        if not file_path or not os.path.exists(file_path):
            pending_uploads.pop(pending_token, None)
            session["pending_uploads"] = pending_uploads
            session.modified = True
            flash("The staged upload file was not found. Please try uploading again.", "error")
            return redirect(url_for("service_lifts"))

        if action == "discard":
            pending_uploads.pop(pending_token, None)
            session["pending_uploads"] = pending_uploads
            session.modified = True
            try:
                os.remove(file_path)
            except OSError:
                pass
            flash("Lift upload discarded.", "info")
            return redirect(url_for("service_lifts"))

        if action != "merge":
            flash("Select a valid action for the upload.", "error")
            return redirect(url_for("service_lifts"))

        try:
            outcome = process_lift_upload_file(
                file_path,
                apply_changes=True,
            )
        except UploadStageTimeoutError as exc:
            flash(str(exc), "error")
            return redirect(url_for("service_lifts"))

        pending_uploads.pop(pending_token, None)
        session["pending_uploads"] = pending_uploads
        session.modified = True

        try:
            os.remove(file_path)
        except OSError:
            pass

        if outcome.created_count or outcome.updated_count:
            flash(
                f"AMC lift upload complete: {outcome.created_count} added, {outcome.updated_count} updated.",
                "success",
            )
        elif outcome.processed_rows and not outcome.row_errors:
            flash("No changes were detected in the uploaded workbook.", "info")
        else:
            flash("No rows were imported from the uploaded workbook.", "info")

        for message in outcome.row_errors[:25]:
            flash(message, "error")
        if len(outcome.row_errors) > 25:
            flash(
                f"Additional {len(outcome.row_errors) - 25} errors were omitted from the alert. Check the file and retry.",
                "warning",
            )

        return redirect(url_for("service_lifts"))

    upload = request.files.get("amc_lift_file")
    try:
        _validate_upload_stream(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
    except UploadValidationError as exc:
        flash(str(exc), "error")
        return redirect(url_for("service_lifts"))

    saved_token = None
    saved_extension = None
    saved_path = None
    try:
        saved_token, saved_extension = save_pending_upload_file(
            upload,
            allowed_extensions={".xlsx", ".csv"},
            allow_office_processing=True,
        )
        saved_path = _build_pending_upload_path(saved_token, saved_extension)
        outcome = process_lift_upload_file(
            saved_path,
            apply_changes=False,
        )
    except MissingDependencyError:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(OPENPYXL_MISSING_MESSAGE, "error")
        return redirect(url_for("service_lifts"))
    except ValueError:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "Upload the .xlsx or .csv template exported from the AMC lifts modal.",
            "error",
        )
        return redirect(url_for("service_lifts"))
    except UploadStageTimeoutError as exc:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(str(exc), "error")
        return redirect(url_for("service_lifts"))
    except Exception:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "Could not read the uploaded workbook. Ensure it is a valid .xlsx or .csv file.",
            "error",
        )
        return redirect(url_for("service_lifts"))

    header_map = outcome.header_map
    if not header_map:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash("The uploaded workbook is missing header labels.", "error")
        return redirect(url_for("service_lifts"))

    missing_headers = [
        column
        for column in ["AMC Status", "AMC Duration"]
        if column not in header_map
    ]
    if (
        "Customer External ID" not in header_map
        and "Customer Code" not in header_map
        and "Customer Name" not in header_map
    ):
        missing_headers.append("Customer External ID / Customer Code / Customer Name")
    if missing_headers:
        file_path = saved_path or _build_pending_upload_path(saved_token, saved_extension)
        if file_path:
            try:
                os.remove(file_path)
            except OSError:
                pass
        flash(
            "The uploaded workbook is missing required columns: "
            + ", ".join(missing_headers)
            + ".",
            "error",
        )
        return redirect(url_for("service_lifts"))

    pending_token = uuid.uuid4().hex
    pending_uploads = session.get("pending_uploads", {})
    pending_uploads[pending_token] = {
        "type": "service_lifts",
        "token": saved_token,
        "extension": saved_extension,
        "original_filename": upload.filename,
    }
    session["pending_uploads"] = pending_uploads
    session.modified = True

    return redirect(
        url_for(
            "service_upload_review",
            upload_type="lifts",
            pending_token=pending_token,
        )
    )


@app.route("/service/upload-review/<upload_type>/<pending_token>")
@login_required
def service_upload_review(upload_type, pending_token):
    _module_visibility_required("service")

    upload_key = (upload_type or "").strip().lower()
    config_map = {
        "customers": {
            "session_type": "service_customers",
            "processor": process_customer_upload_file,
            "redirect_endpoint": "service_customers",
            "confirm_endpoint": "service_customers_upload",
            "review_title": "Review customer upload",
            "invalid_template_message": (
                "Upload the .xlsx or .csv template exported from the customer upload modal."
            ),
            "read_error_message": (
                "Could not read the staged workbook. Ensure it is a valid .xlsx or .csv file."
            ),
        },
        "lifts": {
            "session_type": "service_lifts",
            "processor": process_lift_upload_file,
            "redirect_endpoint": "service_lifts",
            "confirm_endpoint": "service_lifts_upload",
            "review_title": "Review AMC lift upload",
            "invalid_template_message": (
                "Upload the .xlsx or .csv template exported from the AMC lifts modal."
            ),
            "read_error_message": (
                "Could not read the staged workbook. Ensure it is a valid .xlsx or .csv file."
            ),
        },
    }

    config = config_map.get(upload_key)
    if not config:
        abort(404)

    pending_uploads = session.get("pending_uploads", {})
    pending = pending_uploads.get(pending_token)
    if not pending or pending.get("type") != config["session_type"]:
        flash("The upload preview has expired. Please re-upload the file.", "error")
        return redirect(url_for(config["redirect_endpoint"]))

    file_path = pending.get("path")
    if not file_path:
        file_path = _build_pending_upload_path(
            pending.get("token"), pending.get("extension")
        )
    if not file_path or not os.path.exists(file_path):
        _clear_pending_upload(pending_token, remove_file=True)
        flash("The staged upload file was not found. Please try uploading again.", "error")
        return redirect(url_for(config["redirect_endpoint"]))

    try:
        outcome = config["processor"](file_path, apply_changes=False)
    except MissingDependencyError:
        _clear_pending_upload(pending_token, remove_file=True)
        flash(OPENPYXL_MISSING_MESSAGE, "error")
        return redirect(url_for(config["redirect_endpoint"]))
    except ValueError:
        _clear_pending_upload(pending_token, remove_file=True)
        flash(config["invalid_template_message"], "error")
        return redirect(url_for(config["redirect_endpoint"]))
    except UploadStageTimeoutError as exc:
        _clear_pending_upload(pending_token, remove_file=True)
        flash(str(exc), "error")
        return redirect(url_for(config["redirect_endpoint"]))
    except Exception:
        _clear_pending_upload(pending_token, remove_file=True)
        flash(config["read_error_message"], "error")
        return redirect(url_for(config["redirect_endpoint"]))

    return render_template(
        "service/upload_review.html",
        review_title=config["review_title"],
        original_filename=pending.get("original_filename"),
        confirm_url=url_for(config["confirm_endpoint"]),
        pending_token=pending_token,
        created_items=outcome.created_items,
        updated_items=outcome.updated_items,
        created_count=outcome.created_count,
        updated_count=outcome.updated_count,
        row_errors=outcome.row_errors,
        processed_rows=outcome.processed_rows,
        upload_type=upload_key,
    )


@app.route("/service/lifts")
@login_required
def service_lifts():
    _module_visibility_required("service")

    search_query = (request.args.get("q") or "").strip()
    query = Lift.query.options(
        joinedload(Lift.customer),
        subqueryload(Lift.attachments),
        subqueryload(Lift.comments),
    )

    if search_query:
        like = f"%{search_query.lower()}%"
        query = query.filter(
            or_(
                func.lower(Lift.lift_code).like(like),
                func.lower(Lift.customer_code).like(like),
                func.lower(Lift.city).like(like),
                func.lower(Lift.state).like(like),
                func.lower(Lift.route).like(like),
                func.lower(Lift.lift_type).like(like),
                func.lower(Lift.lift_brand).like(like),
                func.lower(Lift.status).like(like),
            )
        )

    lifts = query.order_by(func.lower(Lift.lift_code)).all()
    customers = Customer.query.order_by(func.lower(Customer.company_name)).all()
    service_routes = ServiceRoute.query.order_by(
        func.lower(ServiceRoute.state), func.lower(ServiceRoute.branch)
    ).all()
    next_lift_code = generate_next_lift_code()
    next_customer_code = generate_next_customer_code()
    dropdown_options = get_dropdown_options_map()
    g_plus_options = get_service_dropdown_options("g_plus", active_only=True)
    lift_brand_dropdown_options = get_service_dropdown_options("lift_brand", active_only=True)

    return render_template(
        "service/lifts.html",
        lifts=lifts,
        customers=customers,
        service_routes=service_routes,
        search_query=search_query,
        next_lift_code=next_lift_code,
        next_customer_code=next_customer_code,
        service_contracts=SERVICE_CONTRACTS,
        service_day_options=SERVICE_PREFERRED_DAY_OPTIONS,
        dropdown_options=dropdown_options,
        dropdown_meta=DROPDOWN_FIELD_DEFINITIONS,
        g_plus_options=g_plus_options,
        lift_brand_dropdown_options=lift_brand_dropdown_options,
        amc_duration_choices=AMC_DURATION_CHOICES,
        amc_duration_months=AMC_DURATION_MONTHS,
        amc_status_options=AMC_STATUS_OPTIONS,
    )


@app.route("/service/lifts/create", methods=["POST"])
@login_required
def service_lifts_create():
    _module_visibility_required("service")

    redirect_url = request.form.get("next") or url_for("service_lifts")

    lift_code = generate_next_lift_code()

    customer_code = request.form.get("customer_code", "").strip()
    if not customer_code:
        flash("Select a valid customer from the list.", "error")
        return redirect(redirect_url)

    customer = Customer.query.filter_by(customer_code=customer_code).first()
    if not customer:
        flash("Select a valid customer from the list.", "error")
        return redirect(redirect_url)

    route_value = clean_str(request.form.get("route"))
    if route_value:
        valid_route = ServiceRoute.query.filter(func.lower(ServiceRoute.state) == route_value.lower()).first()
        if not valid_route:
            flash("Select a valid service route from the dropdown.", "error")
            return redirect(redirect_url)
        route_value = valid_route.state

    capacity_persons, error = parse_int_field(request.form.get("capacity_persons"), "Capacity (persons)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    capacity_kg, error = parse_int_field(request.form.get("capacity_kg"), "Capacity (kg)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    speed_mps, error = parse_float_field(request.form.get("speed_mps"), "Speed (m/s)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    install_date, error = parse_date_field(request.form.get("install_date"), "Install date")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_expiry, error = parse_date_field(request.form.get("warranty_expiry"), "Warranty expiry")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_start_date, error = parse_date_field(
        request.form.get("warranty_start_date"), "Warranty start date"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_end_date, error = parse_date_field(
        request.form.get("warranty_end_date"), "Warranty end date"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    if (
        warranty_start_date
        and warranty_end_date
        and warranty_end_date < warranty_start_date
    ):
        flash("Warranty end date cannot be earlier than warranty start date.", "error")
        return redirect(redirect_url)

    amc_start, error = parse_date_field(request.form.get("amc_start"), "AMC start")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    amc_duration_value = clean_str(request.form.get("amc_duration_key"))
    amc_duration_key = amc_duration_value.lower() if amc_duration_value else None
    if amc_duration_key and amc_duration_key not in AMC_DURATION_MONTHS:
        flash("Select a valid AMC duration option.", "error")
        return redirect(redirect_url)
    computed_amc_end = calculate_amc_end_date(amc_start, amc_duration_key)

    preferred_date, error = parse_preferred_service_date(
        request.form.get("preferred_service_date")
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    preferred_time, error = parse_optional_service_time(
        request.form.get("preferred_service_time"), "Preferred service time"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    preferred_days_raw = request.form.getlist("preferred_service_days")
    preferred_days, day_error = parse_preferred_service_days(preferred_days_raw)
    if day_error:
        flash(day_error, "error")
        return redirect(redirect_url)

    g_plus_value, error = validate_service_dropdown_value(
        "g_plus", request.form.get("building_floors"), "Floors"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    lift_brand_value, error = validate_service_dropdown_value(
        "lift_brand", request.form.get("lift_brand"), "Lift Brand"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    contract_input = clean_str(request.form.get("amc_contract_id"))
    amc_contract_id = None
    if contract_input:
        contract_record = get_service_contract_by_id(contract_input)
        if not contract_record:
            flash("Select a valid AMC contract.", "error")
            return redirect(redirect_url)
        amc_contract_id = contract_record.get("id")


    lift = Lift(
        lift_code=lift_code,
        external_lift_id=clean_str(request.form.get("external_lift_id")),
        customer_code=customer_code,
        site_address_line1=clean_str(request.form.get("site_address_line1")),
        site_address_line2=clean_str(request.form.get("site_address_line2")),
        city=clean_str(request.form.get("city")),
        state=clean_str(request.form.get("state")),
        pincode=clean_str(request.form.get("pincode")),
        geo_location=clean_str(request.form.get("geo_location")),
        country="India",
        building_villa_number=clean_str(request.form.get("building_villa_number")),
        route=route_value,
        building_floors=g_plus_value,
        lift_type=clean_str(request.form.get("lift_type")),
        lift_brand=lift_brand_value,
        capacity_persons=capacity_persons,
        capacity_kg=capacity_kg,
        speed_mps=speed_mps,
        machine_type=clean_str(request.form.get("machine_type")),
        machine_brand=clean_str(request.form.get("machine_brand")),
        controller_brand=clean_str(request.form.get("controller_brand")),
        door_type=clean_str(request.form.get("door_type")),
        door_finish=clean_str(request.form.get("door_finish")),
        cabin_finish=clean_str(request.form.get("cabin_finish")),
        power_supply=clean_str(request.form.get("power_supply")),
        install_date=install_date,
        warranty_start_date=warranty_start_date,
        warranty_end_date=warranty_end_date,
        warranty_expiry=warranty_expiry,
        amc_status=clean_str(request.form.get("amc_status")),
        amc_start=amc_start,
        amc_end=computed_amc_end,
        amc_duration_key=amc_duration_key,
        amc_contract_id=amc_contract_id,
        qr_code_url=clean_str(request.form.get("qr_code_url")),
        status=clean_str(request.form.get("status")),
        remarks=clean_str(request.form.get("remarks")),
        preferred_service_date=preferred_date,
        preferred_service_time=preferred_time,
        last_updated_by=current_user.id if current_user.is_authenticated else None,
    )
    lift.preferred_service_days = preferred_days
    lift.set_capacity_display()

    db.session.add(lift)
    db.session.commit()

    flash(f"Lift {lift.lift_code} created.", "success")
    return redirect(redirect_url)


@app.route("/service/lifts/<int:lift_id>")
@login_required
def service_lift_detail(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    payload = build_lift_payload(lift)
    attachments = (
        LiftFile.query.filter_by(lift_id=lift.id)
        .order_by(LiftFile.created_at.desc())
        .all()
    )
    comments = (
        LiftComment.query.filter_by(lift_id=lift.id)
        .order_by(LiftComment.created_at.desc())
        .all()
    )

    customers = Customer.query.order_by(func.lower(Customer.company_name)).all()
    service_routes = ServiceRoute.query.order_by(
        func.lower(ServiceRoute.state), func.lower(ServiceRoute.branch)
    ).all()
    dropdown_options = get_dropdown_options_map()
    service_team_users = get_assignable_users_for_module("service")

    return render_template(
        "service/lift_detail.html",
        lift=lift,
        payload=payload,
        attachments=attachments,
        comments=comments,
        customers=customers,
        service_routes=service_routes,
        service_contracts=SERVICE_CONTRACTS,
        service_day_options=SERVICE_PREFERRED_DAY_OPTIONS,
        service_visit_status_options=SERVICE_VISIT_STATUS_OPTIONS,
        dropdown_options=dropdown_options,
        dropdown_meta=DROPDOWN_FIELD_DEFINITIONS,
        amc_duration_choices=AMC_DURATION_CHOICES,
        amc_duration_months=AMC_DURATION_MONTHS,
        service_type_options=SERVICE_TYPE_OPTIONS,
        current_user_is_service_manager=_user_is_service_manager(current_user),
        service_team_users=service_team_users,
    )


@app.post("/service/lifts/<int:lift_id>/schedule/generate")
@login_required
def service_lift_generate_schedule(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lift_detail", lift_id=lift.id)
    contract = get_service_contract_by_id(lift.amc_contract_id)
    services_per_year = int(contract.get("services_per_year") or 0) if contract else 0

    if not lift.amc_start or services_per_year < 1:
        flash("Set AMC start date and services/year to generate schedule.", "warning")
        return redirect(redirect_url)

    schedule_entries = []
    for idx in range(services_per_year):
        month_offset = int((12 * idx) / services_per_year)
        visit_date = add_months(lift.amc_start, month_offset)
        if not visit_date:
            continue
        service_type = SERVICE_TYPE_OPTIONS[idx % len(SERVICE_TYPE_OPTIONS)][0]
        schedule_entries.append(
            {
                "date": visit_date.isoformat(),
                "route": lift.route,
                "status": "scheduled",
                "service_type": service_type,
                "details_json": None,
                "slip_url": None,
                "slip_label": None,
            }
        )

    lift.service_schedule = schedule_entries
    lift.last_updated_by = current_user.id if current_user.is_authenticated else None
    db.session.commit()

    flash("Schedule generated", "success")
    return redirect(redirect_url)


@app.post("/service/visits/<int:lift_id>/<visit_date_str>/assign")
@login_required
def service_visit_assign(lift_id: int, visit_date_str: str):
    """
    Assign or reassign a service visit (including breakdown calls) to a route.

    The visit is identified by lift_id + visit_date.
    This updates the 'route' field in lift.service_schedule
    so that the dashboard picks it up automatically.
    """
    if not _user_is_service_manager(current_user):
        abort(403)

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    try:
        visit_date = datetime.datetime.strptime(visit_date_str, "%Y-%m-%d").date()
    except ValueError:
        flash("Invalid visit date.", "error")
        return redirect(url_for("service_lift_detail", lift_id=lift.id))

    route_name = (request.form.get("service_route") or "").strip()
    if not route_name:
        flash("Please select a route.", "error")
        return redirect(url_for("service_lift_detail", lift_id=lift.id))

    schedule = lift.service_schedule or []
    updated = False

    for entry in schedule:
        entry_date = _coerce_date(entry.get("date"))
        if entry_date != visit_date:
            continue

        status_value = clean_str(entry.get("status")) or "scheduled"
        status_key = status_value.lower()
        if status_key in {"completed", "cancelled"}:
            # Do not assign completed/cancelled visits
            continue

        entry["route"] = route_name
        updated = True

    if not updated:
        flash("No matching open service visit found to assign.", "warning")
        return redirect(url_for("service_lift_detail", lift_id=lift.id))

    lift.service_schedule = schedule
    db.session.commit()

    flash("Service visit assigned to route.", "success")
    return redirect(url_for("service_lift_detail", lift_id=lift.id))


@app.route("/service/lifts/<int:lift_id>/edit")
@login_required
def service_lift_edit(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    customers = Customer.query.order_by(func.lower(Customer.company_name)).all()
    service_routes = ServiceRoute.query.order_by(
        func.lower(ServiceRoute.state), func.lower(ServiceRoute.branch)
    ).all()
    attachments = (
        LiftFile.query.filter_by(lift_id=lift.id)
        .order_by(LiftFile.created_at.desc())
        .all()
    )
    comments = (
        LiftComment.query.filter_by(lift_id=lift.id)
        .order_by(LiftComment.created_at.desc())
        .all()
    )
    dropdown_options = get_dropdown_options_map()
    g_plus_options = get_service_dropdown_options("g_plus", active_only=True)
    lift_brand_dropdown_options = get_service_dropdown_options("lift_brand", active_only=True)
    current_custom_g_plus = service_dropdown_custom_value("g_plus", lift.building_floors)
    current_custom_lift_brand = service_dropdown_custom_value("lift_brand", lift.lift_brand)
    return render_template(
        "service/lift_edit.html",
        lift=lift,
        customers=customers,
        service_routes=service_routes,
        attachments=attachments,
        comments=comments,
        service_contracts=SERVICE_CONTRACTS,
        service_day_options=SERVICE_PREFERRED_DAY_OPTIONS,
        dropdown_options=dropdown_options,
        dropdown_meta=DROPDOWN_FIELD_DEFINITIONS,
        g_plus_options=g_plus_options,
        lift_brand_dropdown_options=lift_brand_dropdown_options,
        current_custom_g_plus=current_custom_g_plus,
        current_custom_lift_brand=current_custom_lift_brand,
        amc_duration_choices=AMC_DURATION_CHOICES,
        amc_duration_months=AMC_DURATION_MONTHS,
        service_type_options=SERVICE_TYPE_OPTIONS,
    )


@app.route("/service/lifts/<int:lift_id>/update", methods=["POST"])
@login_required
def service_lift_update(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lift_detail", lift_id=lift.id)
    form_section = (request.form.get("form_section") or "full").strip().lower()

    if form_section == "summary":
        customer_code_input = clean_str(request.form.get("customer_code"))
        if customer_code_input:
            new_customer_code = customer_code_input.upper()
            customer = Customer.query.filter(
                func.lower(Customer.customer_code) == new_customer_code.lower()
            ).first()
            if not customer:
                flash("Select a valid customer from the list or create a new customer.", "error")
                return redirect(redirect_url)
            lift.customer_code = new_customer_code
        else:
            lift.customer_code = None

        install_date, error = parse_date_field(request.form.get("install_date"), "Completion date")
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        warranty_expiry, error = parse_date_field(request.form.get("warranty_expiry"), "Warranty expiry")
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        lift.external_lift_id = clean_str(request.form.get("external_lift_id"))
        lift.site_address_line1 = clean_str(request.form.get("site_address_line1"))
        lift.site_address_line2 = clean_str(request.form.get("site_address_line2"))
        lift.building_villa_number = clean_str(request.form.get("building_villa_number"))
        lift.city = clean_str(request.form.get("city"))
        lift.state = clean_str(request.form.get("state"))
        lift.pincode = clean_str(request.form.get("pincode"))
        lift.geo_location = clean_str(request.form.get("geo_location"))
        lift.country = "India"
        lift.install_date = install_date
        lift.warranty_expiry = warranty_expiry
        lift.qr_code_url = clean_str(request.form.get("qr_code_url"))
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None

        db.session.commit()
        flash("Lift summary updated.", "success")
        return redirect(redirect_url)

    if form_section == "specifications":
        capacity_persons, error = parse_int_field(
            request.form.get("capacity_persons"), "Capacity (persons)"
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        capacity_kg, error = parse_int_field(request.form.get("capacity_kg"), "Capacity (kg)")
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        speed_mps, error = parse_float_field(request.form.get("speed_mps"), "Speed (m/s)")
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        g_plus_value, error = validate_service_dropdown_value(
            "g_plus", request.form.get("building_floors"), "Floors"
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        lift_brand_value, error = validate_service_dropdown_value(
            "lift_brand", request.form.get("lift_brand"), "Lift Brand"
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        existing_custom_g_plus = clean_str(request.form.get("building_floors_existing_custom"))
        if (
            not g_plus_value
            and existing_custom_g_plus
            and clean_str(lift.building_floors)
            and existing_custom_g_plus.lower() == clean_str(lift.building_floors).lower()
            and service_dropdown_custom_value("g_plus", existing_custom_g_plus)
        ):
            g_plus_value = existing_custom_g_plus

        existing_custom_lift_brand = clean_str(request.form.get("lift_brand_existing_custom"))
        if (
            not lift_brand_value
            and existing_custom_lift_brand
            and clean_str(lift.lift_brand)
            and existing_custom_lift_brand.lower() == clean_str(lift.lift_brand).lower()
            and service_dropdown_custom_value("lift_brand", existing_custom_lift_brand)
        ):
            lift_brand_value = existing_custom_lift_brand

        lift.lift_type = clean_str(request.form.get("lift_type"))
        lift.lift_brand = lift_brand_value
        lift.building_floors = g_plus_value
        lift.capacity_persons = capacity_persons
        lift.capacity_kg = capacity_kg
        lift.speed_mps = speed_mps
        lift.machine_type = clean_str(request.form.get("machine_type"))
        lift.machine_brand = clean_str(request.form.get("machine_brand"))
        lift.controller_brand = clean_str(request.form.get("controller_brand"))
        lift.door_type = clean_str(request.form.get("door_type"))
        lift.door_finish = clean_str(request.form.get("door_finish"))
        lift.cabin_finish = clean_str(request.form.get("cabin_finish"))
        lift.power_supply = clean_str(request.form.get("power_supply"))
        lift.remarks = clean_str(request.form.get("remarks"))
        lift.set_capacity_display()
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None

        db.session.commit()
        flash("Lift specifications updated.", "success")
        return redirect(redirect_url)

    if form_section == "amc_details":
        route_value = clean_str(request.form.get("route"))
        if route_value:
            valid_route = ServiceRoute.query.filter(
                func.lower(ServiceRoute.state) == route_value.lower()
            ).first()
            if not valid_route:
                flash("Select a valid service route from the dropdown.", "error")
                return redirect(redirect_url)
            route_value = valid_route.state
        else:
            route_value = None

        amc_start, error = parse_date_field(request.form.get("amc_start"), "AMC start date")
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        amc_duration_value = clean_str(request.form.get("amc_duration_key"))
        amc_duration_key = amc_duration_value.lower() if amc_duration_value else None
        if amc_duration_key and amc_duration_key not in AMC_DURATION_MONTHS:
            flash("Select a valid AMC duration option.", "error")
            return redirect(redirect_url)
        computed_amc_end = calculate_amc_end_date(amc_start, amc_duration_key)

        preferred_date, error = parse_preferred_service_date(
            request.form.get("preferred_service_date")
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        preferred_time, error = parse_optional_service_time(
            request.form.get("preferred_service_time"), "Preferred PM time"
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        preferred_days_raw = request.form.getlist("preferred_service_days")
        preferred_days, day_error = parse_preferred_service_days(preferred_days_raw)
        if day_error:
            flash(day_error, "error")
            return redirect(redirect_url)

        contract_input = clean_str(request.form.get("amc_contract_id"))
        amc_contract_id = None
        if contract_input:
            contract_record = get_service_contract_by_id(contract_input)
            if not contract_record:
                flash("Select a valid AMC contract.", "error")
                return redirect(redirect_url)
            amc_contract_id = contract_record.get("id")

        last_service_date, error = parse_date_field(
            request.form.get("last_service_date"), "Last service date"
        )
        if error:
            flash(error, "error")
            return redirect(redirect_url)

        lift.amc_status = clean_str(request.form.get("amc_status"))
        lift.amc_start = amc_start
        lift.amc_end = computed_amc_end
        lift.amc_duration_key = amc_duration_key
        lift.amc_contract_id = amc_contract_id
        lift.route = route_value
        lift.preferred_service_date = preferred_date
        lift.preferred_service_time = preferred_time
        lift.preferred_service_days = preferred_days
        lift.last_service_date = last_service_date
        lift.notes = clean_str(request.form.get("service_notes"))
        lift.status = clean_str(request.form.get("status"))
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None

        db.session.commit()
        flash("AMC details updated.", "success")
        return redirect(redirect_url)

    if form_section == "service_schedule":
        dates = request.form.getlist("service_date")
        routes = request.form.getlist("service_route")
        statuses = request.form.getlist("service_status")
        service_types = request.form.getlist("service_type")
        service_details = request.form.getlist("service_details")
        slip_existing_values = request.form.getlist("service_slip_existing")
        slip_labels = request.form.getlist("service_slip_label")
        slip_files = request.files.getlist("service_slip_file")
        max_len = max(
            len(dates),
            len(routes),
            len(statuses),
            len(service_types),
            len(service_details),
            len(slip_existing_values),
            len(slip_labels),
            len(slip_files),
        )
        schedule_entries = []
        static_root = os.path.join(BASE_DIR, "static")
        for idx in range(max_len):
            date_value = dates[idx] if idx < len(dates) else ""
            route_value = clean_str(routes[idx]) if idx < len(routes) else None
            status_value = clean_str(statuses[idx]) if idx < len(statuses) else None
            service_type_value = clean_str(service_types[idx]) if idx < len(service_types) else None
            details_text = clean_str(service_details[idx]) if idx < len(service_details) else None
            slip_value = (
                clean_str(slip_existing_values[idx])
                if idx < len(slip_existing_values)
                else None
            )
            slip_label = (
                clean_str(slip_labels[idx]) if idx < len(slip_labels) else None
            )
            uploaded_file = slip_files[idx] if idx < len(slip_files) else None

            normalized_route = None
            if route_value:
                valid_route = ServiceRoute.query.filter(
                    func.lower(ServiceRoute.state) == route_value.lower()
                ).first()
                if not valid_route:
                    flash(f"Select a valid service route for row {idx + 1}.", "error")
                    return redirect(redirect_url)
                normalized_route = valid_route.state
            elif lift.route:
                normalized_route = lift.route

            status_key = (
                status_value.lower()
                if status_value and status_value.lower() in SERVICE_VISIT_STATUS_LABELS
                else "scheduled"
            )

            if uploaded_file and getattr(uploaded_file, "filename", None):
                if not uploaded_file.filename:
                    uploaded_file = None
            if uploaded_file and uploaded_file.filename:
                if status_key != "completed":
                    flash(
                        f"Slip upload is allowed only for completed visits (row {idx + 1}).",
                        "error",
                    )
                    return redirect(redirect_url)
                safe_name = secure_filename(uploaded_file.filename)
                if not safe_name:
                    flash(
                        "The uploaded service slip file name is not valid.",
                        "error",
                    )
                    return redirect(redirect_url)
                if not allowed_file(safe_name, kind="attachment"):
                    flash(
                        "Unsupported file type for service slip. Upload images, videos or documents only.",
                        "error",
                    )
                    return redirect(redirect_url)
                upload_root = os.path.join(
                    app.config["UPLOAD_FOLDER"], "service_slips", str(lift.id)
                )
                os.makedirs(upload_root, exist_ok=True)
                unique_name = f"{uuid.uuid4().hex}_{safe_name}"
                destination_path = os.path.join(upload_root, unique_name)
                uploaded_file.save(destination_path)
                slip_value = (
                    os.path.relpath(destination_path, static_root)
                    .replace(os.sep, "/")
                    .lstrip("/")
                )
                slip_label = uploaded_file.filename
            if slip_value and isinstance(slip_value, str) and not slip_value.lower().startswith(("http://", "https://")):
                normalized_value = slip_value.lstrip("/")
                if normalized_value.startswith("static/"):
                    normalized_value = normalized_value.split("static/", 1)[1]
                slip_value = normalized_value or None
            if not any([date_value, normalized_route, status_value, service_type_value, details_text, slip_value, slip_label]):
                continue
            if not date_value:
                flash(
                    f"Service date is required for each scheduled visit (row {idx + 1}).",
                    "error",
                )
                return redirect(redirect_url)
            visit_date, error = parse_date_field(
                date_value, f"Service date (row {idx + 1})"
            )
            if error:
                flash(error, "error")
                return redirect(redirect_url)
            if service_type_value and service_type_value not in SERVICE_TYPE_LABELS:
                flash(f"Select a valid service type for row {idx + 1}.", "error")
                return redirect(redirect_url)
            schedule_entries.append(
                {
                    "date": visit_date.isoformat() if visit_date else None,
                    "route": normalized_route,
                    "status": status_key,
                    "slip_url": slip_value,
                    "slip_label": slip_label,
                    "service_type": service_type_value,
                    "details_json": details_text,
                }
            )
        lift.service_schedule = schedule_entries
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None
        db.session.commit()
        flash("Service schedule updated.", "success")
        return redirect(redirect_url)

    if form_section == "amc_contacts":
        names = request.form.getlist("contact_name")
        designations = request.form.getlist("contact_designation")
        phones = request.form.getlist("contact_phone")
        emails = request.form.getlist("contact_email")
        max_len = max(len(names), len(designations), len(phones), len(emails))
        contacts = []
        for idx in range(max_len):
            name = clean_str(names[idx]) if idx < len(names) else None
            designation = clean_str(designations[idx]) if idx < len(designations) else None
            phone = clean_str(phones[idx]) if idx < len(phones) else None
            email = clean_str(emails[idx]) if idx < len(emails) else None
            if not any([name, designation, phone, email]):
                continue
            contacts.append(
                {
                    "name": name,
                    "designation": designation,
                    "phone": phone,
                    "email": email,
                }
            )
        lift.amc_contacts = contacts
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None
        db.session.commit()
        flash("AMC contacts updated.", "success")
        return redirect(redirect_url)

    if form_section == "lifetime_metrics":
        labels = request.form.getlist("metric_label")
        displays = request.form.getlist("metric_display")
        max_len = max(len(labels), len(displays))
        metrics = []
        for idx in range(max_len):
            label = clean_str(labels[idx]) if idx < len(labels) else None
            display_raw = displays[idx] if idx < len(displays) else ""
            display = display_raw.strip() if isinstance(display_raw, str) else None
            if not label and not display:
                continue
            metrics.append({"label": label or "Metric", "display": display or "—"})
        lift.lifetime_metrics = metrics
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None
        db.session.commit()
        flash("Lifetime value metrics updated.", "success")
        return redirect(redirect_url)

    if form_section == "timeline":
        timeline_date, error = parse_date_field(request.form.get("timeline_date"), "Timeline date")
        if error:
            flash(error, "error")
            return redirect(redirect_url)
        title = clean_str(request.form.get("timeline_title")) or "Update"
        detail = clean_str(request.form.get("timeline_detail"))
        category = clean_str(request.form.get("timeline_category")) or "Update"
        entries = list(lift.timeline_entries)
        actor_info = timeline_actor_context()
        entries.insert(
            0,
            {
                "date": timeline_date,
                "title": title,
                "detail": detail,
                "category": category,
                **actor_info,
            },
        )
        lift.timeline_entries = entries
        lift.last_updated_by = current_user.id if current_user.is_authenticated else None
        db.session.commit()
        flash("Timeline entry added.", "success")
        return redirect(redirect_url)

    # Fallback to full update
    customer_code_input = clean_str(request.form.get("customer_code"))
    if customer_code_input:
        new_customer_code = customer_code_input.upper()
        customer = Customer.query.filter(func.lower(Customer.customer_code) == new_customer_code.lower()).first()
        if not customer:
            flash("Select a valid customer from the list or create a new customer.", "error")
            return redirect(redirect_url)
        lift.customer_code = new_customer_code
    else:
        lift.customer_code = None

    route_value = clean_str(request.form.get("route"))
    if route_value:
        valid_route = ServiceRoute.query.filter(func.lower(ServiceRoute.state) == route_value.lower()).first()
        if not valid_route:
            flash("Select a valid service route from the dropdown.", "error")
            return redirect(redirect_url)
        route_value = valid_route.state

    capacity_persons, error = parse_int_field(request.form.get("capacity_persons"), "Capacity (persons)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    capacity_kg, error = parse_int_field(request.form.get("capacity_kg"), "Capacity (kg)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    speed_mps, error = parse_float_field(request.form.get("speed_mps"), "Speed (m/s)")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    install_date, error = parse_date_field(request.form.get("install_date"), "Install date")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_expiry, error = parse_date_field(request.form.get("warranty_expiry"), "Warranty expiry")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_start_date, error = parse_date_field(
        request.form.get("warranty_start_date"), "Warranty start date"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    warranty_end_date, error = parse_date_field(
        request.form.get("warranty_end_date"), "Warranty end date"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    if (
        warranty_start_date
        and warranty_end_date
        and warranty_end_date < warranty_start_date
    ):
        flash("Warranty end date cannot be earlier than warranty start date.", "error")
        return redirect(redirect_url)

    amc_start, error = parse_date_field(request.form.get("amc_start"), "AMC start")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    amc_duration_value = clean_str(request.form.get("amc_duration_key"))
    amc_duration_key = amc_duration_value.lower() if amc_duration_value else None
    if amc_duration_key and amc_duration_key not in AMC_DURATION_MONTHS:
        flash("Select a valid AMC duration option.", "error")
        return redirect(redirect_url)
    computed_amc_end = calculate_amc_end_date(amc_start, amc_duration_key)

    preferred_date, error = parse_preferred_service_date(
        request.form.get("preferred_service_date")
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    preferred_time, error = parse_optional_service_time(
        request.form.get("preferred_service_time"), "Preferred service time"
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    preferred_days_raw = request.form.getlist("preferred_service_days")
    preferred_days, day_error = parse_preferred_service_days(preferred_days_raw)
    if day_error:
        flash(day_error, "error")
        return redirect(redirect_url)

    contract_input = clean_str(request.form.get("amc_contract_id"))
    amc_contract_id = None
    if contract_input:
        contract_record = get_service_contract_by_id(contract_input)
        if not contract_record:
            flash("Select a valid AMC contract.", "error")
            return redirect(redirect_url)
        amc_contract_id = contract_record.get("id")

    lift.external_lift_id = clean_str(request.form.get("external_lift_id"))
    lift.site_address_line1 = clean_str(request.form.get("site_address_line1"))
    lift.site_address_line2 = clean_str(request.form.get("site_address_line2"))
    lift.city = clean_str(request.form.get("city"))
    lift.state = clean_str(request.form.get("state"))
    lift.pincode = clean_str(request.form.get("pincode"))
    lift.geo_location = clean_str(request.form.get("geo_location"))
    lift.country = "India"
    lift.building_villa_number = clean_str(request.form.get("building_villa_number"))
    lift.route = route_value
    lift.building_floors = clean_str(request.form.get("building_floors"))
    lift.lift_type = clean_str(request.form.get("lift_type"))
    lift.capacity_persons = capacity_persons
    lift.capacity_kg = capacity_kg
    lift.speed_mps = speed_mps
    lift.machine_type = clean_str(request.form.get("machine_type"))
    lift.machine_brand = clean_str(request.form.get("machine_brand"))
    lift.controller_brand = clean_str(request.form.get("controller_brand"))
    lift.door_type = clean_str(request.form.get("door_type"))
    lift.door_finish = clean_str(request.form.get("door_finish"))
    lift.cabin_finish = clean_str(request.form.get("cabin_finish"))
    lift.power_supply = clean_str(request.form.get("power_supply"))
    lift.install_date = install_date
    lift.warranty_start_date = warranty_start_date
    lift.warranty_end_date = warranty_end_date
    lift.warranty_expiry = warranty_expiry
    lift.amc_status = clean_str(request.form.get("amc_status"))
    lift.amc_start = amc_start
    lift.amc_end = computed_amc_end
    lift.amc_duration_key = amc_duration_key
    lift.amc_contract_id = amc_contract_id
    lift.qr_code_url = clean_str(request.form.get("qr_code_url"))
    lift.status = clean_str(request.form.get("status"))
    lift.remarks = clean_str(request.form.get("remarks"))
    service_notes_value = request.form.get("service_notes")
    if service_notes_value is not None:
        lift.notes = clean_str(service_notes_value)
    elif "notes" in request.form:
        lift.notes = clean_str(request.form.get("notes"))
    lift.preferred_service_date = preferred_date
    lift.preferred_service_time = preferred_time
    lift.preferred_service_days = preferred_days
    lift.last_updated_by = current_user.id if current_user.is_authenticated else None
    lift.set_capacity_display()

    db.session.commit()

    flash("Lift details updated.", "success")
    return redirect(redirect_url)


@app.route("/service/lifts/<int:lift_id>/delete", methods=["POST"])
@login_required
def service_lift_delete(lift_id):
    _module_visibility_required("service")

    if not current_user.is_admin:
        abort(403)

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lifts")
    if not redirect_url.startswith("/"):
        redirect_url = url_for("service_lifts")

    delete_lift_record(lift)
    db.session.commit()

    flash(f"Lift {lift.lift_code} deleted.", "success")
    return redirect(redirect_url)


@app.route("/service/lifts/<int:lift_id>/notes", methods=["POST"])
@login_required
def service_lift_update_notes(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lift_detail", lift_id=lift.id)

    lift.remarks = clean_str(request.form.get("remarks"))

    preferred_date, error = parse_preferred_service_date(
        request.form.get("preferred_service_date")
    )
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    preferred_time_raw = request.form.get("preferred_service_time")
    preferred_time, error = parse_optional_service_time(preferred_time_raw, "Preferred service time")
    if error:
        flash(error, "error")
        return redirect(redirect_url)

    if "preferred_service_days" in request.form:
        preferred_days_raw = request.form.getlist("preferred_service_days")
        preferred_days, day_error = parse_preferred_service_days(preferred_days_raw)
        if day_error:
            flash(day_error, "error")
            return redirect(redirect_url)
        lift.preferred_service_days = preferred_days

    lift.preferred_service_date = preferred_date
    lift.preferred_service_time = preferred_time
    db.session.commit()

    flash("Preferences updated.", "success")
    return redirect(redirect_url)


@app.route("/service/lifts/<int:lift_id>/comments", methods=["POST"])
@login_required
def service_lift_add_comment(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lift_detail", lift_id=lift.id)
    body = (request.form.get("body") or "").strip()
    if not body:
        flash("Comment cannot be empty.", "error")
        return redirect(redirect_url)

    comment = LiftComment(
        lift=lift,
        body=body,
        author=current_user if current_user.is_authenticated else None,
    )
    db.session.add(comment)
    db.session.commit()

    flash("Comment added.", "success")
    return redirect(redirect_url)


@app.route("/service/lifts/<int:lift_id>/files", methods=["POST"])
@login_required
def service_lift_upload_file(lift_id):
    _module_visibility_required("service")

    lift = db.session.get(Lift, lift_id)
    if not lift:
        flash("Lift not found.", "error")
        return redirect(url_for("service_lifts"))

    redirect_url = request.form.get("next") or url_for("service_lift_detail", lift_id=lift.id)

    uploaded_file = request.files.get("attachment")
    if not uploaded_file or not uploaded_file.filename:
        flash("Select a file to upload.", "error")
        return redirect(redirect_url)

    safe_name = secure_filename(uploaded_file.filename)
    if not safe_name:
        flash("The selected file name is not valid.", "error")
        return redirect(redirect_url)

    if not allowed_file(safe_name, kind="attachment"):
        flash("Unsupported file type. Upload images, videos or documents only.", "error")
        return redirect(redirect_url)

    upload_root = os.path.join(app.config["UPLOAD_FOLDER"], "lifts", str(lift.id))
    os.makedirs(upload_root, exist_ok=True)

    unique_name = f"{uuid.uuid4().hex}_{safe_name}"
    destination_path = os.path.join(upload_root, unique_name)
    uploaded_file.save(destination_path)

    static_root = os.path.join(BASE_DIR, "static")
    stored_relative = os.path.relpath(destination_path, static_root).replace(os.sep, "/")

    category = (request.form.get("category") or "other").strip().lower()
    if category not in {"document", "media", "other"}:
        category = "other"

    record = LiftFile(
        lift=lift,
        original_filename=uploaded_file.filename,
        stored_path=stored_relative,
        content_type=uploaded_file.mimetype,
        file_size=os.path.getsize(destination_path),
        label=clean_str(request.form.get("label")),
        description=clean_str(request.form.get("description")),
        category=category,
        uploaded_by=current_user if current_user.is_authenticated else None,
    )
    db.session.add(record)
    db.session.commit()

    flash("File uploaded.", "success")
    return redirect(redirect_url)


@app.route("/service/complaints")
@login_required
def service_complaints():
    _module_visibility_required("service")
    return render_template("service/complaints.html", complaints=SERVICE_COMPLAINTS)


@app.route("/service/contracts/export")
@login_required
def service_contracts_export():
    _module_visibility_required("service")
    if not current_user.is_admin:
        abort(403)

    timestamp = datetime.datetime.utcnow().strftime("%Y%m%d")
    filename = f"contracts_export_{timestamp}.xlsx"

    if OPENPYXL_AVAILABLE:
        workbook = build_contract_export_workbook(SERVICE_CONTRACTS)
        output = BytesIO()
        workbook.save(output)
        output.seek(0)
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    csv_rows = [_contract_export_row(contract) for contract in SERVICE_CONTRACTS]
    csv_output = _build_csv_output(SERVICE_CONTRACT_EXPORT_HEADERS, csv_rows)
    return send_file(
        csv_output,
        as_attachment=True,
        download_name=filename.replace(".xlsx", ".csv"),
        mimetype="text/csv",
    )


@app.route("/service/contracts")
@login_required
def service_contracts():
    _module_visibility_required("service")
    contracts = []
    for contract in SERVICE_CONTRACTS:
        contracts.append(
            {
                **contract,
                "start_display": contract.get("start").strftime("%d %b %Y") if isinstance(contract.get("start"), datetime.date) else "—",
                "end_display": contract.get("end").strftime("%d %b %Y") if isinstance(contract.get("end"), datetime.date) else "—",
                "renewal_display": contract.get("renewal").strftime("%d %b %Y") if isinstance(contract.get("renewal"), datetime.date) else "—",
            }
        )
    return render_template("service/contracts.html", contracts=contracts)


@app.route("/service/parts-materials")
@login_required
def service_parts_materials():
    _module_visibility_required("service")
    ledger = SERVICE_PARTS_LEDGER
    return render_template(
        "service/parts_materials.html",
        stock_alerts=ledger.get("stock_alerts", []),
        consumption=ledger.get("consumption", []),
        returns=ledger.get("returns", []),
    )


def _count_unscheduled_amc_lifts():
    base_query = Lift.query.filter(Lift.next_service_due.is_(None))
    total_without_due = base_query.count()
    lifts_with_schedule = (
        base_query.filter(Lift.service_schedule_json.isnot(None))
        .options(load_only(Lift.id, Lift.service_schedule_json))
        .all()
    )
    scheduled_via_json = sum(
        1
        for lift in lifts_with_schedule
        if isinstance(lift.next_amc_date, datetime.date)
    )
    return total_without_due - scheduled_via_json


@app.route("/service/preventive-maintenance")
@login_required
def service_preventive_maintenance():
    _module_visibility_required("service")
    snapshot = get_service_schedule_snapshot()
    today = snapshot["today"]

    def preference_warning(lift_obj, visit_date=None):
        if not lift_obj:
            return None
        messages = []
        if lift_obj.preferred_service_date:
            preferred_display = format_preferred_service_date(
                lift_obj.preferred_service_date
            )
            if isinstance(visit_date, datetime.date):
                if not preferred_service_date_matches(
                    lift_obj.preferred_service_date, visit_date
                ):
                    messages.append(f"Prefers {preferred_display}")
            else:
                messages.append(f"Prefers {preferred_display}")
        if lift_obj.preferred_service_time:
            messages.append(
                f"Prefers {lift_obj.preferred_service_time.strftime('%H:%M')}"
            )
        for day_key in lift_obj.preferred_service_days:
            if day_key and day_key in SERVICE_PREFERRED_DAY_LABELS and day_key != "any":
                day_label = SERVICE_PREFERRED_DAY_LABELS.get(day_key)
                if isinstance(visit_date, datetime.date):
                    if visit_date.strftime("%A").lower() != day_key:
                        messages.append(f"Prefers {day_label}")
                else:
                    messages.append(f"Prefers {day_label}")
                break
        if messages:
            return " · ".join(messages)
        return None

    upcoming = []
    overdue = []
    for entry in snapshot["entries"]:
        visit_date = entry.get("date")
        if not isinstance(visit_date, datetime.date):
            continue
        if entry.get("status") == "completed":
            continue
        lift = entry.get("lift")
        site_name = (
            (lift.customer.company_name if lift and lift.customer else None)
            or (lift.customer.customer_code if lift and lift.customer else None)
            or (lift.customer_code if lift and lift.customer_code else None)
            or (lift.city if lift and lift.city else None)
            or "—"
        )
        base_payload = {
            "site": site_name,
            "lift": (lift.lift_code if lift and lift.lift_code else (f"Lift #{lift.id}" if lift else "Lift")),
            "technician": entry.get("technician") or "Unassigned",
            "checklist": entry.get("checklist") or "—",
            "preference_warning": preference_warning(lift, visit_date),
            "_sort_date": visit_date,
        }
        if visit_date >= today:
            upcoming.append(
                {
                    **base_payload,
                    "visit_display": visit_date.strftime("%d %b %Y"),
                }
            )
        else:
            overdue.append(
                {
                    **base_payload,
                    "due_display": visit_date.strftime("%d %b %Y"),
                    "days_overdue": (today - visit_date).days,
                }
            )

    upcoming.sort(key=lambda item: item.get("_sort_date"))
    overdue.sort(key=lambda item: item.get("_sort_date"))
    for collection in (upcoming, overdue):
        for item in collection:
            item.pop("_sort_date", None)

    checklist_counts = Counter(
        entry.get("checklist")
        for entry in snapshot["entries"]
        if entry.get("checklist")
    )
    checklists = [
        {
            "name": name,
            "items": count,
            "photo_rules": "Logged via service schedule",
        }
        for name, count in sorted(checklist_counts.items())
    ]

    overdue_count = 0
    today_count = 0
    week_count = 0
    upcoming_count = 0

    for entry in snapshot["entries"]:
        visit_date = entry.get("date")
        if not isinstance(visit_date, datetime.date):
            continue
        status_key = (entry.get("status") or "scheduled").strip().lower()
        if status_key in {"completed", "cancelled"}:
            continue

        if visit_date < today:
            overdue_count += 1
        elif visit_date == today:
            today_count += 1
            upcoming_count += 1
        else:
            upcoming_count += 1
            delta_days = (visit_date - today).days
            if delta_days <= 7:
                week_count += 1

    unscheduled_count = _count_unscheduled_amc_lifts()

    summary = {
        "overdue": overdue_count,
        "today": today_count,
        "week": week_count,
        "upcoming": upcoming_count,
        "unscheduled": unscheduled_count,
    }

    return render_template(
        "service/preventive_maintenance.html",
        upcoming=upcoming,
        overdue=overdue,
        checklists=checklists,
        summary=summary,
        today=today,
    )


@app.route("/service/automations")
@login_required
def service_automations():
    _module_visibility_required("service")
    roles = []
    for role, capabilities in SERVICE_AUTOMATIONS.get("roles", {}).items():
        roles.append({"role": role, "capabilities": capabilities})
    return render_template(
        "service/automations.html",
        flows=SERVICE_AUTOMATIONS.get("flows", []),
        roles=roles,
        config_options=SERVICE_AUTOMATIONS.get("config", []),
    )


# ---------------------- SRT MODULE ----------------------
@app.route("/srt")
@login_required
def srt_overview():
    _module_visibility_required("srt")
    status_filter = request.args.get("status", "all").lower()
    today = datetime.date.today()

    tasks = []
    for task in SRT_SAMPLE_TASKS:
        due_date = task.get("due_date")
        due_in = (due_date - today).days if due_date else None
        due_date_display = due_date.strftime("%d %b %Y") if due_date else ""
        due_date_iso = due_date.isoformat() if due_date else ""
        tasks.append(
            {
                **task,
                "due_in": due_in,
                "due_date_display": due_date_display,
                "due_date_iso": due_date_iso,
            }
        )

    status_key_map = {
        "scheduled": "scheduled",
        "site-visited": "site visited",
        "site_visited": "site visited",
        "pending-civil": "pending civil work",
        "pending_civil": "pending civil work",
        "ready": "ready for installation",
        "closed": "closed",
    }
    if status_filter in status_key_map:
        status_value = status_key_map[status_filter]
        filtered_tasks = [task for task in tasks if task["status"].lower() == status_value]
    elif status_filter in {"pending", "open"}:
        filtered_tasks = [task for task in tasks if task["status"].lower() != "closed"]
    else:
        filtered_tasks = [task for task in tasks if task["status"].lower() != "closed"]

    summary = {
        "total_pending": sum(1 for task in tasks if task["status"].lower() != "closed"),
        "high_priority": sum(1 for task in tasks if task["priority"].lower() == "high" and task["status"].lower() != "closed"),
        "due_this_week": sum(
            1
            for task in tasks
            if task["status"].lower() != "closed"
            and task.get("due_in") is not None
            and 0 <= task["due_in"] <= 7
        ),
        "oldest_age": max((task["age_days"] for task in tasks), default=0),
    }

    site_options = sorted(
        (
            {
                "key": site.get("key"),
                "name": site.get("name"),
            }
            for site in SRT_SITES
        ),
        key=lambda item: (item.get("name") or "").lower(),
    )

    return render_template(
        "srt_overview.html",
        tasks=filtered_tasks,
        status_filter=status_filter,
        summary=summary,
        site_options=site_options,
        team_members=SRT_TEAM_MEMBERS,
    )


@app.route("/srt/settings", methods=["GET", "POST"])
@app.route("/srt/form-templates", methods=["GET", "POST"], endpoint="srt_form_templates")
@login_required
def srt_settings():
    _module_visibility_required("srt")
    global SRT_FORM_TEMPLATES

    active_tab = request.args.get("tab", "form-templates").lower() or "form-templates"
    if active_tab not in {"form-templates", "notifications"}:
        active_tab = "form-templates"

    if request.method == "POST":
        action = request.form.get("action", "").lower()
        name = (request.form.get("name") or "").strip()
        category = (request.form.get("category") or "General").strip() or "General"
        description = (request.form.get("description") or "").strip()
        usage_count_raw = request.form.get("usage_count")
        schema_json = (request.form.get("schema_json") or "").strip()

        usage_count = 0
        try:
            if usage_count_raw is not None and usage_count_raw != "":
                usage_count = max(0, int(usage_count_raw))
        except ValueError:
            usage_count = 0

        schema_payload = _default_srt_schema()
        if schema_json:
            try:
                loaded = json.loads(schema_json)
            except json.JSONDecodeError:
                loaded = _default_srt_schema()
            schema_payload = loaded

        schema = copy.deepcopy(_normalise_srt_schema(schema_payload))
        today = datetime.date.today()

        if action == "create":
            if not name:
                flash("Template name is required.", "error")
            else:
                template_id = slugify(name)
                if any(template["id"] == template_id for template in SRT_FORM_TEMPLATES):
                    template_id = f"{template_id}-{_random_digits(4)}"

                SRT_FORM_TEMPLATES.append(
                    {
                        "id": template_id,
                        "name": name,
                        "category": category or "General",
                        "description": description,
                        "usage_count": usage_count,
                        "last_updated": today,
                        "schema": schema,
                    }
                )
                _persist_srt_form_templates()
                flash("SRT form template added.", "success")

        elif action == "delete":
            template_id = request.form.get("template_id")
            if not template_id:
                flash("Template not found.", "error")
            else:
                updated_templates = [
                    item for item in SRT_FORM_TEMPLATES if item["id"] != template_id
                ]
                if len(updated_templates) == len(SRT_FORM_TEMPLATES):
                    flash("Template not found.", "error")
                else:
                    SRT_FORM_TEMPLATES = updated_templates
                    _persist_srt_form_templates()
                    flash("Template deleted.", "success")

        elif action == "update":
            template_id = request.form.get("template_id")
            template = next((item for item in SRT_FORM_TEMPLATES if item["id"] == template_id), None)
            if not template:
                flash("Template not found.", "error")
            elif not name:
                flash("Template name is required.", "error")
            else:
                template.update(
                    {
                        "name": name,
                        "category": category or "General",
                        "description": description,
                        "usage_count": usage_count,
                        "last_updated": today,
                        "schema": schema,
                    }
                )
                _persist_srt_form_templates()
                flash("Template updated.", "success")

        return redirect(url_for("srt_settings", tab="form-templates"))

    templates_normalised = []
    for template in SRT_FORM_TEMPLATES:
        template.setdefault("schema", _default_srt_schema())
        normalised_schema = copy.deepcopy(_normalise_srt_schema(template["schema"]))
        template["schema"] = normalised_schema
        templates_normalised.append(
            {
                **template,
                "schema": copy.deepcopy(normalised_schema),
            }
        )

    templates_normalised.sort(key=lambda item: item["name"].lower())

    return render_template(
        "srt_settings.html",
        templates=templates_normalised,
        active_tab=active_tab,
    )


@app.route("/srt/sites")
@login_required
def srt_sites():
    _module_visibility_required("srt")
    selected_key = request.args.get("site")

    sites = []
    site_map = {}
    for site in sorted(SRT_SITES, key=lambda item: item["name"].lower()):
        site_copy = {key: value for key, value in site.items() if key != "additional_contacts"}
        contacts = [dict(contact) for contact in site.get("additional_contacts", [])]
        site_copy["additional_contacts"] = contacts
        site_copy["tasks"] = [
            dict(task)
            for task in SRT_SAMPLE_TASKS
            if task.get("site") == site["name"]
        ]
        site_copy.setdefault("client_contact", {})
        site_copy.setdefault("form_update", {})
        site_copy.setdefault("updates", [])
        site_copy.setdefault("interactions", [])
        site_map[site["key"]] = site_copy
        sites.append(site_copy)

    if not sites:
        selected_site = None
    else:
        if selected_key and selected_key in site_map:
            selected_site = site_map[selected_key]
        else:
            selected_site = sites[0]
            selected_key = selected_site["key"]

    return render_template(
        "srt_sites.html",
        sites=sites,
        selected_site_key=selected_key,
        team_members=SRT_TEAM_MEMBERS,
    )


@app.route("/srt/task", methods=["POST"])
@login_required
def srt_task_create():
    _module_visibility_required("srt")
    site_name = (request.form.get("site_name") or "").strip()
    summary = (request.form.get("summary") or "").strip()
    task_name = (request.form.get("name") or "").strip()
    priority = (request.form.get("priority") or "Normal").strip().title() or "Normal"
    owner = (request.form.get("owner") or "Unassigned").strip() or "Unassigned"
    due_date_raw = request.form.get("due_date")

    due_date = None
    if due_date_raw:
        try:
            due_date = datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date()
        except ValueError:
            due_date = None

    if not site_name or not task_name or not summary:
        flash("Site, task name and summary are required to create a task.", "error")
        return redirect(url_for("srt_sites"))

    existing_ids = {task["id"] for task in SRT_SAMPLE_TASKS}
    task_id = f"SRT-{_random_digits(4)}"
    while task_id in existing_ids:
        task_id = f"SRT-{_random_digits(4)}"

    SRT_SAMPLE_TASKS.insert(
        0,
        {
            "id": task_id,
            "site": site_name,
            "name": task_name,
            "summary": summary,
            "priority": priority,
            "status": SRT_STATUS_OPTIONS[0],
            "due_date": due_date,
            "owner": owner or "Unassigned",
            "age_days": 0,
        },
    )

    actor_name = None
    actor_role = None
    if current_user.is_authenticated:
        actor_name = current_user.display_name
        actor_role = "admin" if current_user.is_admin else "user"
    elif owner and owner != "Unassigned":
        actor_name = owner
        actor_role = "user"

    _log_srt_activity(
        task_id,
        type="status",
        label="Task created",
        detail=f"{task_name} — {summary}" if summary else task_name,
        actor=actor_name or "System",
        actor_role=actor_role,
    )

    flash("SRT task added to the board.", "success")

    redirect_to = request.form.get("redirect_to")
    if redirect_to and redirect_to.startswith("/"):
        return redirect(redirect_to)

    return redirect(url_for("srt_sites", site=slugify(site_name)))


@app.route("/srt/task/<task_id>/data")
@login_required
def srt_task_data(task_id):
    _module_visibility_required("srt")
    task = _get_srt_task(task_id)
    if not task:
        return jsonify({"ok": False, "message": "Task not found."}), 404

    today = datetime.date.today()
    due_date = task.get("due_date")
    due_in = (due_date - today).days if due_date else None

    timeline_entries = []
    for event in SRT_TASK_ACTIVITY.get(task_id, []):
        enriched = apply_actor_context(event)
        raw_timestamp = event.get("timestamp") or datetime.datetime.utcnow()
        if isinstance(raw_timestamp, str):
            try:
                timestamp_value = datetime.datetime.fromisoformat(raw_timestamp)
            except ValueError:
                timestamp_value = datetime.datetime.utcnow()
        else:
            timestamp_value = raw_timestamp
        timeline_entries.append(
            {
                "type": enriched.get("type", event.get("type", "update")),
                "label": enriched.get("label") or event.get("label") or "Update",
                "detail": enriched.get("detail") or event.get("detail"),
                "actor": enriched.get("actor"),
                "actor_role": enriched.get("actor_role"),
                "actor_label": enriched.get("actor_label"),
                "comment": event.get("comment"),
                "attachment_label": event.get("attachment_label"),
                "attachment_url": event.get("attachment_url"),
                "timestamp": timestamp_value.isoformat(),
                "timestamp_display": timestamp_value.strftime("%d %b %Y • %H:%M"),
                "_sort_timestamp": timestamp_value,
            }
        )

    timeline = sorted(
        timeline_entries,
        key=lambda item: item.get("_sort_timestamp") or datetime.datetime.utcnow(),
        reverse=True,
    )
    for entry in timeline:
        entry.pop("_sort_timestamp", None)

    task_payload = {
        "id": task["id"],
        "site": task["site"],
        "name": task.get("name") or "",
        "summary": task["summary"],
        "priority": task["priority"],
        "status": task["status"],
        "owner": task["owner"],
        "due_date": due_date.isoformat() if due_date else None,
        "due_date_display": due_date.strftime("%d %b %Y") if due_date else "",
        "due_in": due_in,
    }

    return jsonify({"ok": True, "task": task_payload, "timeline": timeline})


@app.route("/srt/task/<task_id>/update", methods=["POST"])
@login_required
def srt_task_update(task_id):
    _module_visibility_required("srt")
    task = _get_srt_task(task_id)
    if not task:
        flash("Task not found.", "error")
        return redirect(url_for("srt_overview"))

    redirect_to = request.form.get("redirect_to") or url_for("srt_overview")
    if not redirect_to.startswith("/"):
        redirect_to = url_for("srt_overview")

    status_raw = (request.form.get("status") or task.get("status") or "").strip()
    normalized = status_raw.lower()
    status_map = {
        "scheduled": "Scheduled",
        "site visited": "Site Visited",
        "pending civil work": "Pending Civil Work",
        "ready for installation": "Ready for Installation",
        "closed": "Closed",
    }
    if normalized in {"site_visited", "site-visited"}:
        normalized = "site visited"
    if normalized in {"pending_civil_work", "pending-civil-work"}:
        normalized = "pending civil work"
    if normalized in {"ready_for_installation", "ready-for-installation"}:
        normalized = "ready for installation"
    status = status_map.get(normalized, status_raw.title())
    if status not in SRT_STATUS_OPTIONS:
        status = task.get("status") or SRT_STATUS_OPTIONS[0]

    owner = (request.form.get("owner") or task.get("owner") or "").strip() or "Unassigned"
    due_date_raw = request.form.get("due_date")
    due_date = None
    if due_date_raw:
        try:
            due_date = datetime.datetime.strptime(due_date_raw, "%Y-%m-%d").date()
        except ValueError:
            due_date = task.get("due_date")
    else:
        due_date = None

    comment = (request.form.get("comment") or "").strip()
    attachment_label = (request.form.get("attachment_label") or "").strip()
    attachment_url = (request.form.get("attachment_url") or "").strip()

    original_status = task.get("status")
    original_owner = task.get("owner")
    original_due = task.get("due_date")

    events = []
    actor_info = timeline_actor_context()

    if status != original_status:
        events.append(
            {
                "type": "status",
                "label": f"Status updated to {status}",
                "detail": f"{original_status or '—'} → {status}",
                "actor": actor_info.get("actor"),
                "actor_role": actor_info.get("actor_role"),
            }
        )
        task["status"] = status

    if owner != original_owner:
        events.append(
            {
                "type": "assignment",
                "label": "Owner reassigned",
                "detail": f"{original_owner or 'Unassigned'} → {owner or 'Unassigned'}",
                "actor": actor_info.get("actor"),
                "actor_role": actor_info.get("actor_role"),
            }
        )
        task["owner"] = owner or "Unassigned"

    if due_date != original_due:
        new_due_display = due_date.strftime("%d %b %Y") if due_date else "No due date"
        old_due_display = original_due.strftime("%d %b %Y") if original_due else "No due date"
        events.append(
            {
                "type": "due_date",
                "label": "Due date updated",
                "detail": f"{old_due_display} → {new_due_display}",
                "actor": actor_info.get("actor"),
                "actor_role": actor_info.get("actor_role"),
            }
        )
        task["due_date"] = due_date

    if comment:
        events.append(
            {
                "type": "comment",
                "label": "Comment added",
                "comment": comment,
                "actor": actor_info.get("actor"),
                "actor_role": actor_info.get("actor_role"),
            }
        )

    if attachment_url:
        events.append(
            {
                "type": "attachment",
                "label": attachment_label or "Attachment uploaded",
                "attachment_label": attachment_label or attachment_url,
                "attachment_url": attachment_url,
                "actor": actor_info.get("actor"),
                "actor_role": actor_info.get("actor_role"),
            }
        )

    if not events:
        flash("No updates were made to the task.", "info")
        return redirect(redirect_to)

    for event in events:
        _log_srt_activity(task_id, **event)

    flash("Task updated successfully.", "success")
    return redirect(redirect_to)


# ---------------------- QC TABS ----------------------


def _get_qc_summary_cards():
    status_counts = dict(
        db.session.query(QCWork.status, func.count(QCWork.id))
        .group_by(QCWork.status)
        .all()
    )
    total = sum(status_counts.values())
    return {
        "total": total,
        "pending": status_counts.get("Pending Inspection", 0),
        "inspection_done": status_counts.get("Inspection Done", 0),
        "rectification_pending": status_counts.get("Rectification Pending", 0),
        "closed": status_counts.get("Closed", 0),
    }


@app.route("/qc")
@login_required
def qc_overview():
    _module_visibility_required("qc")
    summary_cards = _get_qc_summary_cards()
    return render_template(
        "qc_overview.html",
        summary_cards=summary_cards,
    )


@app.route("/qc/tasks")
@login_required
def qc_home():
    _module_visibility_required("qc")
    status = request.args.get("status", "open")
    status_order = case(
        (QCWork.status == "Pending Inspection", 0),
        (QCWork.status == "Inspection Done", 1),
        (QCWork.status == "Rectification Pending", 2),
        (QCWork.status == "Closed", 3),
        else_=4
    )
    query = QCWork.query.order_by(
        status_order,
        QCWork.due_date.asc().nullslast(),
        QCWork.created_at.desc()
    )
    if status == "open":
        query = query.filter(QCWork.status != "Closed")
    elif status == "closed":
        query = query.filter(QCWork.status == "Closed")

    work_items = query.all()
    templates = FormSchema.query.order_by(
        FormSchema.is_primary.desc(), FormSchema.name.asc()
    ).all()
    users = get_assignable_users_for_module("qc", order_by="username")
    projects = Project.query.order_by(Project.name.asc()).all()
    work_ids = [item.id for item in work_items if item.id]

    def calculate_completion_percentage(submission):
        if not submission:
            return 0
        try:
            data = json.loads(submission.data_json or "{}")
        except Exception:
            return 0

        total = 0
        filled = 0

        def visit(value):
            nonlocal total, filled
            if isinstance(value, dict):
                for v in value.values():
                    visit(v)
            elif isinstance(value, list):
                for item in value:
                    visit(item)
            else:
                total += 1
                if value is None:
                    return
                if isinstance(value, str):
                    if value.strip():
                        filled += 1
                elif value:
                    filled += 1

        visit(data)
        if total == 0:
            return 0
        return round((filled / total) * 100)

    submission_map = {}
    if work_ids:
        submissions = (
            Submission.query
            .filter(Submission.work_id.in_(work_ids))
            .order_by(Submission.created_at.desc())
            .all()
        )
        for sub in submissions:
            if sub.work_id not in submission_map:
                submission_map[sub.work_id] = sub

    for item in work_items:
        item.completion_percent = calculate_completion_percentage(
            submission_map.get(item.id)
        )

    return render_template(
        "qc.html",
        work_items=work_items,
        templates=templates,
        users=users,
        projects=projects,
        STAGES=STAGES,
        LIFT_TYPES=LIFT_TYPES,
        status_filter=status,
    )


def _render_qc_settings(default_tab="settings"):
    active_tab = request.args.get("tab") or default_tab
    sort = (request.args.get("sort") or "name").lower()
    direction = (request.args.get("direction") or "asc").lower()
    sort_map = {
        "name": FormSchema.name,
        "stage": FormSchema.stage,
        "lift_type": FormSchema.lift_type,
        "updated_at": FormSchema.updated_at,
        "is_primary": FormSchema.is_primary,
    }
    sort_column = sort_map.get(sort, FormSchema.name)
    ordered_column = sort_column.desc() if direction == "desc" else sort_column.asc()
    forms = FormSchema.query.order_by(ordered_column, FormSchema.id.asc()).all()
    return render_template(
        "qc_settings.html",
        active_tab=active_tab,
        forms=forms,
        sort=sort,
        direction=direction,
    )


@app.route("/qc/settings")
@login_required
def qc_settings():
    _module_visibility_required("qc")
    return _render_qc_settings()


@app.route("/qc/work/new", methods=["POST"])
@login_required
def qc_work_new():
    _module_visibility_required("qc")
    site_name = (request.form.get("site_name") or "").strip()
    template_id = request.form.get("template_id", type=int)
    stage = (request.form.get("stage") or "").strip()
    lift_type = (request.form.get("lift_type") or "").strip()
    due = (request.form.get("due_date") or "").strip()
    owner_id = request.form.get("owner_id", type=int) or getattr(current_user, "id", None)
    assigned_to = request.form.get("assigned_to", type=int)
    project_id = request.form.get("project_id", type=int)
    planned_start = (request.form.get("planned_start_date") or "").strip()
    duration_raw = (request.form.get("planned_duration_days") or "").strip()
    client_name = None
    address = None

    project = db.session.get(Project, project_id) if project_id else None
    if project:
        site_name = site_name or project.site_name or project.name
        client_name = client_name or (project.customer_name or "")
        address = address or (project.site_address or "")
        lift_type = lift_type or (project.lift_type or "")

    if not site_name or not template_id:
        flash("Site name and Template are required.", "error")
        return redirect(url_for("qc_home"))

    due_dt = None
    if due:
        try:
            due_dt = datetime.datetime.strptime(due, "%Y-%m-%d")
        except Exception:
            flash("Invalid due date format.", "error")
            return redirect(url_for("qc_home"))

    planned_start_date = None
    if planned_start:
        try:
            planned_start_date = datetime.datetime.strptime(planned_start, "%Y-%m-%d").date()
        except ValueError:
            flash("Invalid planned start date format.", "error")
            return redirect(url_for("qc_home"))

    duration_days = None
    if duration_raw:
        try:
            duration_days = int(duration_raw)
        except ValueError:
            flash("Duration must be a whole number of days.", "error")
            return redirect(url_for("qc_home"))
        if duration_days < 0:
            flash("Duration must be zero or positive.", "error")
            return redirect(url_for("qc_home"))

    if due_dt is None:
        if planned_start_date and duration_days is not None:
            due_dt = datetime.datetime.combine(planned_start_date, datetime.time.min) + datetime.timedelta(days=duration_days)
        elif duration_days is not None:
            due_dt = datetime.datetime.utcnow() + datetime.timedelta(days=duration_days)

    template = db.session.get(FormSchema, template_id)

    owner_user = None
    if owner_id:
        owner_user = db.session.get(User, owner_id)
        if not owner_user or not owner_user.is_active:
            flash("Choose a valid owner for the task.", "error")
            return redirect(url_for("qc_home"))

    assignee_user = None
    if assigned_to:
        assignee_user = db.session.get(User, assigned_to)
        if not assignee_user or not assignee_user.can_be_assigned_module("qc"):
            flash("Choose an assignee who is available for QC tasks.", "error")
            return redirect(url_for("qc_home"))

    project_task = None
    if project:
        project_task = ProjectTask(
            project_id=project.id,
            name=site_name,
            description=None,
            order_index=ProjectTask.query.filter_by(project_id=project.id).count() + 1,
            duration_days=duration_days,
            module="qc",
            task_subtype="qc",
            assignee_id=assigned_to if assignee_user else None,
        )
        db.session.add(project_task)
        db.session.flush()

    work = QCWork(
        site_name=site_name,
        client_name=client_name or None,
        address=address or None,
        template_id=template_id,
        stage=stage or (template.stage if template else None),
        lift_type=lift_type or (template.lift_type if template else None),
        project_id=project.id if project else None,
        project_task_id=project_task.id if project_task else None,
        due_date=due_dt,
        created_by=owner_user.id if owner_user else current_user.id,
        assigned_to=assigned_to if assignee_user else None,
        name=site_name,
        status=QC_STATUS_OPTIONS[0],
        planned_start_date=planned_start_date,
        planned_duration_days=duration_days,
        milestone=None
    )
    db.session.add(work)
    db.session.flush()
    if project_task:
        project_task.linked_record_type = "qc_task"
        project_task.linked_record_id = work.id
    log_work_event(
        work.id,
        "created",
        actor_id=current_user.id,
        details={
            "site_name": work.site_name,
            "assigned_to": assigned_to,
            "due_date": work.due_date.strftime("%Y-%m-%d") if work.due_date else None,
            "project_id": work.project_id,
            "planned_start_date": planned_start_date.strftime("%Y-%m-%d") if planned_start_date else None,
            "planned_duration_days": duration_days
        }
    )
    if assignee_user:
        log_work_event(
            work.id,
            "assigned",
            actor_id=current_user.id,
            details={"assigned_to": assigned_to}
        )
        create_notification(
            assignee_user.id,
            f"You have been assigned a new task: {work.display_title}",
            url_for("qc_work_detail", work_id=work.id),
            commit=False,
        )
    db.session.commit()
    flash("QC work created.", "success")
    return redirect(url_for("qc_work_detail", work_id=work.id))


@app.route("/qc/work/<int:work_id>")
@login_required
def qc_work_detail(work_id):
    _module_visibility_required("qc")
    work = QCWork.query.get_or_404(work_id)
    submissions = Submission.query.filter_by(work_id=work_id).order_by(Submission.created_at.desc()).all()
    for submission in submissions:
        try:
            submission.photo_count = len(json.loads(submission.photos_json or "[]"))
        except Exception:
            submission.photo_count = 0
        try:
            submission.video_count = len(json.loads(submission.videos_json or "[]"))
        except Exception:
            submission.video_count = 0
    users = get_assignable_users_for_module("qc", order_by="username")
    comments = (
        QCWorkComment.query
        .filter_by(work_id=work_id)
        .order_by(QCWorkComment.created_at.desc())
        .all()
    )
    for comment in comments:
        try:
            comment.attachments = json.loads(comment.attachments_json or "[]")
        except Exception:
            comment.attachments = []
        comment.has_attachments = bool(comment.attachments)
    logs = QCWorkLog.query.filter_by(work_id=work_id).order_by(QCWorkLog.created_at.desc()).all()
    for log in logs:
        try:
            log.details = json.loads(log.details_json or "{}")
        except Exception:
            log.details = {}
        if isinstance(log.details, dict):
            if "assigned_to" in log.details:
                user_id = log.details.get("assigned_to")
                if user_id:
                    user_obj = db.session.get(User, user_id)
                    log.details["assigned_to"] = user_obj.username if user_obj else user_id
                else:
                    log.details["assigned_to"] = "Unassigned"
            if "from" in log.details:
                prev_id = log.details.get("from")
                if prev_id:
                    user_obj = db.session.get(User, prev_id)
                    log.details["from"] = user_obj.username if user_obj else prev_id
                elif prev_id is None:
                    log.details["from"] = "Unassigned"
            if "to" in log.details:
                next_id = log.details.get("to")
                if next_id:
                    user_obj = db.session.get(User, next_id)
                    log.details["to"] = user_obj.username if user_obj else next_id
                elif next_id is None:
                    log.details["to"] = "Unassigned"
    attachment_entries = []
    for comment in comments:
        for item in getattr(comment, "attachments", []) or []:
            web_path = item.get("web_path") or (
                item.get("path", "").split("static/", 1)[1]
                if "path" in item and "static/" in item.get("path", "")
                else item.get("path")
            )
            attachment_entries.append({
                "name": item.get("name") or "Attachment",
                "web_path": web_path,
                "comment_id": comment.id,
                "author": comment.author.username if comment.author else "Unknown",
                "created_at": comment.created_at,
                "body": (comment.body[:160] + ("…" if len(comment.body) > 160 else "")) if comment.body else None,
            })

    attachment_entries.sort(key=lambda entry: entry["created_at"], reverse=True)
    return render_template(
        "qc_work_detail.html",
        work=work,
        submissions=submissions,
        users=users,
        comments=comments,
        logs=logs,
        attachments=attachment_entries
    )


@app.route("/qc/work/<int:work_id>/assign", methods=["POST"])
@login_required
def qc_work_assign(work_id):
    _module_visibility_required("qc")
    work = QCWork.query.get_or_404(work_id)
    assigned_to = request.form.get("assigned_to", type=int)
    assignee_user = None
    if assigned_to:
        assignee_user = db.session.get(User, assigned_to)
        if not assignee_user or not assignee_user.can_be_assigned_module("qc"):
            flash("Choose an assignee who is available for QC tasks.", "error")
            return redirect(url_for("qc_work_detail", work_id=work.id))
    previous = work.assigned_to
    work.assigned_to = assigned_to if assignee_user else None
    if previous != work.assigned_to:
        db.session.flush()
        log_work_event(
            work.id,
            "assignment_updated",
            actor_id=current_user.id,
            details={"from": previous, "to": work.assigned_to}
        )
        if previous and previous != work.assigned_to:
            create_notification(
                previous,
                f"Task '{work.display_title}' has been reassigned.",
                url_for("qc_work_detail", work_id=work.id),
                commit=False,
            )
        if work.assigned_to and work.assigned_to != previous and work.assigned_to != current_user.id:
            create_notification(
                work.assigned_to,
                f"You have been assigned task '{work.display_title}'.",
                url_for("qc_work_detail", work_id=work.id),
                commit=False,
            )
        db.session.commit()
        flash("Assignment updated.", "success")
    else:
        db.session.rollback()
        flash("Assignment unchanged.", "info")
    return redirect(url_for("qc_work_detail", work_id=work.id))


@app.route("/qc/work/<int:work_id>/comment", methods=["POST"])
@login_required
def qc_work_comment(work_id):
    work = QCWork.query.get_or_404(work_id)
    body = (request.form.get("body") or "").strip()
    if not body and not request.files.getlist("attachments"):
        flash("Add a comment or attachment.", "error")
        return redirect(url_for("qc_work_detail", work_id=work.id))

    attachments = []
    for f in request.files.getlist("attachments"):
        if f and f.filename:
            if not allowed_file(f.filename, kind="attachment"):
                flash(f"Unsupported file type for {f.filename}.", "error")
                return redirect(url_for("qc_work_detail", work_id=work.id))
            fname = secure_filename(f.filename)
            dest_name = f"{datetime.datetime.utcnow().timestamp()}_{fname}"
            dest = os.path.join(app.config["UPLOAD_FOLDER"], dest_name)
            f.save(dest)
            rel_path = dest.split("static/", 1)[1] if "static/" in dest else dest
            attachments.append({"path": dest, "name": fname, "web_path": rel_path})

    comment = QCWorkComment(
        work_id=work.id,
        author_id=current_user.id,
        body=body,
        attachments_json=json.dumps(attachments, ensure_ascii=False)
    )
    db.session.add(comment)
    db.session.flush()
    log_details = {"comment_id": comment.id}
    if body:
        snippet = body if len(body) <= 160 else body[:157] + "…"
        log_details["body"] = snippet
    if attachments:
        log_details["attachments"] = [item.get("name") for item in attachments if item.get("name")]
    log_work_event(
        work.id,
        "comment_added",
        actor_id=current_user.id,
        details=log_details
    )
    if work.assigned_to and work.assigned_to != current_user.id:
        create_notification(
            work.assigned_to,
            f"New comment on task '{work.display_title}' by {current_user.display_name}.",
            f"{url_for('qc_work_detail', work_id=work.id)}#comments",
            commit=False,
        )
    db.session.commit()
    flash("Comment added.", "success")
    return redirect(url_for("qc_work_detail", work_id=work.id))


@app.route("/qc/work/<int:work_id>/status/<string:action>", methods=["POST"])
@login_required
def qc_work_status(work_id, action):
    _module_visibility_required("qc")
    """Progress status for work."""
    work = QCWork.query.get_or_404(work_id)
    if action not in {"inspect", "rectify", "close", "reopen"}:
        flash("Invalid action.", "error")
        return redirect(url_for("qc_work_detail", work_id=work.id))

    from_status = work.status or QC_STATUS_OPTIONS[0]
    if action == "inspect":
        if from_status != "Pending Inspection":
            flash(f"Cannot mark inspection done: current status is {work.status}.", "error")
            return redirect(url_for("qc_work_detail", work_id=work.id))
        new_status = "Inspection Done"
    elif action == "rectify":
        if from_status != "Inspection Done":
            flash(f"Cannot mark rectification pending: current status is {work.status}.", "error")
            return redirect(url_for("qc_work_detail", work_id=work.id))
        new_status = "Rectification Pending"
    elif action == "close":
        if from_status != "Rectification Pending":
            flash(f"Cannot close: current status is {work.status}.", "error")
            return redirect(url_for("qc_work_detail", work_id=work.id))
        new_status = "Closed"
    else:  # reopen
        if from_status != "Closed":
            flash(f"Cannot reopen: current status is {work.status}.", "error")
            return redirect(url_for("qc_work_detail", work_id=work.id))
        new_status = "Rectification Pending"

    work.status = new_status
    db.session.flush()
    log_work_event(
        work.id,
        "status_changed",
        actor_id=current_user.id,
        from_status=from_status,
        to_status=new_status
    )
    if new_status == "Closed":
        release_dependent_tasks(work, actor_id=current_user.id)
    if work.assigned_to and work.assigned_to != current_user.id:
        create_notification(
            work.assigned_to,
            f"Task '{work.display_title}' was updated by {current_user.display_name}.",
            url_for("qc_work_detail", work_id=work.id),
            commit=False,
        )
    db.session.commit()
    flash(f"Work status changed to {new_status}.", "success")
    return redirect(url_for("qc_work_detail", work_id=work.id))
# ----------------------------------------------------


@app.route("/qc/recent-submissions")
@login_required
def qc_recent_submissions():
    _module_visibility_required("qc")
    submissions = (
        Submission.query
        .order_by(Submission.created_at.desc())
        .limit(50)
        .all()
    )
    return render_template(
        "qc_recent_submissions.html",
        submissions=submissions
    )


@app.route("/customer-support/sarv-test")
@login_required
def customer_support_sarv_test():
    _module_visibility_required("customer_support")
    calls = CallLog.query.order_by(CallLog.created_at.desc()).limit(50).all()
    return render_template("customer_support_sarv_test.html", calls=calls)


@app.route("/calls/demo")
@login_required
def calls_demo():
    return redirect(url_for("customer_support_sarv_test"))


@app.route("/customer-support/sarv/update-records", methods=["POST"])
@login_required
def customer_support_sarv_update_records():
    _module_visibility_required("customer_support")

    errors = []
    checked = 0
    updated = 0

    recordings = (
        CallRecording.query
        .options(joinedload(CallRecording.call_log))
        .order_by(CallRecording.created_at.desc())
        .all()
    )

    for recording in recordings:
        checked += 1

        local_missing = not recording.local_file_path
        if recording.local_file_path and current_app:
            local_path = os.path.join(current_app.static_folder, recording.local_file_path)
            local_missing = not os.path.exists(local_path)

        if not local_missing and recording.download_status == "success":
            continue

        try:
            download_call_recording(recording)
            updated += 1
        except Exception as exc:  # pragma: no cover - defensive logging
            db.session.rollback()
            recording.download_status = "failed"
            recording.download_error = str(exc)[:250]
            db.session.commit()
            errors.append(
                f"Recording {recording.id} ({recording.sarv_file_path}) failed: {recording.download_error}"
            )

    status = "ok" if not errors else "error"
    return jsonify({"checked": checked, "updated": updated, "errors": errors, "status": status})


@app.cli.command("initdb")
def initdb():
    """Initialize database and seed sample data"""
    bootstrap_db()
    print("Database initialized with default users and sample form.")


_bootstrap_lock = threading.Lock()
_bootstrapped = False


def ensure_bootstrap():
    global _bootstrapped
    if _bootstrapped:
        return
    with _bootstrap_lock:
        if _bootstrapped:
            return
        try:
            bootstrap_db()
            _bootstrapped = True
        except Exception as exc:
            app.logger.exception("Database bootstrap failed: %s", exc)


@app.before_request
def _ensure_db_ready():
    ensure_bootstrap()


if __name__ == "__main__":
    with app.app_context():
        bootstrap_db()
    app.run(debug=True)
